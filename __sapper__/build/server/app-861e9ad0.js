'use strict';

var index = require('./index-eb65fe33.js');
var index$1 = require('./index-a6b4e1c5.js');
var index$2 = require('./index-9f24c7af.js');

const CONTEXT_KEY = {};

const preload = () => ({});

/* src\components\PreloadingIndicator.svelte generated by Svelte v3.12.0 */

const css = {
	code: ".progress-container.svelte-3253v6{position:absolute;top:0;left:0;width:100%;height:4px;z-index:999}.progress.svelte-3253v6{position:absolute;left:0;top:0;height:100%;background-color:var(--prime);transition:width 0.4s}.fade.svelte-3253v6{position:fixed;width:100%;height:100%;background-color:rgba(255,255,255,0.3);pointer-events:none;z-index:998;animation:svelte-3253v6-fade 0.4s}@keyframes svelte-3253v6-fade{from{opacity:0 }to{opacity:1 }}",
	map: "{\"version\":3,\"file\":\"PreloadingIndicator.svelte\",\"sources\":[\"PreloadingIndicator.svelte\"],\"sourcesContent\":[\"<script>\\r\\n\\timport { onMount } from 'svelte';\\r\\n\\r\\n\\tlet p = 0;\\r\\n\\tlet visible = false;\\r\\n\\r\\n\\tonMount(() => {\\r\\n\\t\\tfunction next() {\\r\\n\\t\\t\\tvisible = true;\\r\\n\\t\\t\\tp += 0.1;\\r\\n\\r\\n\\t\\t\\tconst remaining = 1 - p;\\r\\n\\t\\t\\tif (remaining > 0.15) setTimeout(next, 500 / remaining);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tsetTimeout(next, 250);\\r\\n\\t});\\r\\n</script>\\r\\n\\r\\n<style>\\r\\n\\t.progress-container {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\ttop: 0;\\r\\n\\t\\tleft: 0;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 4px;\\r\\n\\t\\tz-index: 999;\\r\\n\\t}\\r\\n\\r\\n\\t.progress {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\tleft: 0;\\r\\n\\t\\ttop: 0;\\r\\n\\t\\theight: 100%;\\r\\n\\t\\tbackground-color: var(--prime);\\r\\n\\t\\ttransition: width 0.4s;\\r\\n\\t}\\r\\n\\r\\n\\t.fade {\\r\\n\\t\\tposition: fixed;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%;\\r\\n\\t\\tbackground-color: rgba(255,255,255,0.3);\\r\\n\\t\\tpointer-events: none;\\r\\n\\t\\tz-index: 998;\\r\\n\\t\\tanimation: fade 0.4s;\\r\\n\\t}\\r\\n\\r\\n\\t@keyframes fade {\\r\\n\\t\\tfrom { opacity: 0 }\\r\\n\\t\\tto { opacity: 1 }\\r\\n\\t}\\r\\n</style>\\r\\n\\r\\n{#if visible}\\r\\n\\t<div class=\\\"progress-container\\\">\\r\\n\\t\\t<div class=\\\"progress\\\" style=\\\"width: {p * 100}%\\\"></div>\\r\\n\\t</div>\\r\\n{/if}\\r\\n\\r\\n{#if p >= 0.4}\\r\\n\\t<div class=\\\"fade\\\"></div>\\r\\n{/if}\"],\"names\":[],\"mappings\":\"AAoBC,mBAAmB,cAAC,CAAC,AACpB,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,GAAG,CACX,OAAO,CAAE,GAAG,AACb,CAAC,AAED,SAAS,cAAC,CAAC,AACV,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,IAAI,OAAO,CAAC,CAC9B,UAAU,CAAE,KAAK,CAAC,IAAI,AACvB,CAAC,AAED,KAAK,cAAC,CAAC,AACN,QAAQ,CAAE,KAAK,CACf,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CACvC,cAAc,CAAE,IAAI,CACpB,OAAO,CAAE,GAAG,CACZ,SAAS,CAAE,kBAAI,CAAC,IAAI,AACrB,CAAC,AAED,WAAW,kBAAK,CAAC,AAChB,IAAI,AAAC,CAAC,AAAC,OAAO,CAAE,CAAC,CAAC,CAAC,AACnB,EAAE,AAAC,CAAC,AAAC,OAAO,CAAE,CAAC,CAAC,CAAC,AAClB,CAAC\"}"
};

const PreloadingIndicator = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let p = 0;
	let visible = false;

	index.onMount(() => {
		function next() {
			visible = true;
			p += 0.1;

			const remaining = 1 - p;
			if (remaining > 0.15) setTimeout(next, 500 / remaining);
		}

		setTimeout(next, 250);
	});

	$$result.css.add(css);

	return `${ visible ? `<div class="progress-container svelte-3253v6">
			<div class="progress svelte-3253v6" style="width: ${index.escape(p * 100)}%"></div>
		</div>` : `` }

	${ p >= 0.4 ? `<div class="fade svelte-3253v6"></div>` : `` }`;
});

/* src\routes\_layout.svelte generated by Svelte v3.12.0 */

const css$1 = {
	code: "main.svelte-hxszvy{position:relative;margin:0 auto;padding:var(--nav-h) 0 0 0;overflow-x:hidden}",
	map: "{\"version\":3,\"file\":\"_layout.svelte\",\"sources\":[\"_layout.svelte\"],\"sourcesContent\":[\"<script>\\r\\n\\timport { setContext } from 'svelte';\\r\\n\\timport { stores } from '@sapper/app';\\r\\n\\timport { Icon, Icons, Nav, NavItem } from '@sveltejs/site-kit';\\r\\n\\timport PreloadingIndicator from '../components/PreloadingIndicator.svelte';\\r\\n\\r\\n\\texport let segment;\\r\\n\\r\\n\\tconst { page, preloading, session } = stores();\\r\\n\\r\\n\\tsetContext('app', {\\r\\n\\t\\tlogin: () => {\\r\\n\\t\\t\\tconst login_window = window.open(`${window.location.origin}/auth/login`, 'login', 'width=600,height=400');\\r\\n\\r\\n\\t\\t\\twindow.addEventListener('message', function handler(event) {\\r\\n\\t\\t\\t\\tlogin_window.close();\\r\\n\\t\\t\\t\\twindow.removeEventListener('message', handler);\\r\\n\\t\\t\\t\\t$session.user = event.data.user;\\r\\n\\t\\t\\t});\\r\\n\\t\\t},\\r\\n\\r\\n\\t\\tlogout: async () => {\\r\\n\\t\\t\\tconst r = await fetch(`/auth/logout`, {\\r\\n\\t\\t\\t\\tcredentials: 'include'\\r\\n\\t\\t\\t});\\r\\n\\r\\n\\t\\t\\tif (r.ok) $session.user = null;\\r\\n\\t\\t}\\r\\n\\t});\\r\\n</script>\\r\\n\\r\\n<Icons/>\\r\\n\\r\\n{#if $preloading}\\r\\n\\t<PreloadingIndicator/>\\r\\n{/if}\\r\\n\\r\\n{#if $page.path !== '/repl/embed'}\\r\\n\\t<Nav {segment} {page} logo=\\\"svelte-logo-horizontal.svg\\\">\\r\\n\\t\\t<NavItem segment=\\\"tutorial\\\">教程</NavItem>\\r\\n\\t\\t<NavItem segment=\\\"docs\\\">API</NavItem>\\r\\n\\t\\t<NavItem segment=\\\"examples\\\">实例</NavItem>\\r\\n\\t\\t<NavItem segment=\\\"repl\\\">REPL</NavItem>\\r\\n\\t\\t<NavItem segment=\\\"blog\\\">博客</NavItem>\\r\\n\\t\\t<NavItem segment=\\\"faq\\\">常见问题</NavItem>\\r\\n\\t\\t\\r\\n\\t\\t<NavItem external=\\\"https://github.com/Runningzs/svelte-ZH/issues\\\">报告翻译错误</NavItem>\\r\\n\\t\\t<NavItem external=\\\"https://sapper.svelte.dev\\\">Sapper</NavItem>\\r\\n\\r\\n\\t\\t<NavItem external=\\\"chat\\\" title=\\\"svelteJS交流群\\\">\\r\\n\\t\\t\\t<Icon name=\\\"message-square\\\"/>\\r\\n\\t\\t</NavItem>\\r\\n\\r\\n\\t\\t<NavItem external=\\\"https://github.com/Runningzs/svelte-ZH\\\" title=\\\"GitHub Repo\\\">\\r\\n\\t\\t\\t<Icon name=\\\"github\\\"/>\\r\\n\\t\\t</NavItem>\\r\\n\\t</Nav>\\r\\n{/if}\\r\\n\\r\\n<main>\\r\\n\\t<slot></slot>\\r\\n</main>\\r\\n\\r\\n<style>\\r\\n\\tmain {\\r\\n\\t\\tposition: relative;\\r\\n\\t\\tmargin: 0 auto;\\r\\n\\t\\t/* padding: var(--nav-h) var(--side-nav) 0 var(--side-nav); */\\r\\n\\t\\tpadding: var(--nav-h) 0 0 0;\\r\\n\\t\\toverflow-x: hidden;\\r\\n\\t}\\r\\n</style>\\r\\n\"],\"names\":[],\"mappings\":\"AAgEC,IAAI,cAAC,CAAC,AACL,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,CAAC,CAAC,IAAI,CAEd,OAAO,CAAE,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAC3B,UAAU,CAAE,MAAM,AACnB,CAAC\"}"
};

const Layout = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	let $session, $preloading, $page;

	

	let { segment } = $$props;

	const { page, preloading, session } = stores$1(); $page = index.get_store_value(page); $preloading = index.get_store_value(preloading); $session = index.get_store_value(session);

	index.setContext('app', {
		login: () => {
			const login_window = window.open(`${window.location.origin}/auth/login`, 'login', 'width=600,height=400');

			window.addEventListener('message', function handler(event) {
				login_window.close();
				window.removeEventListener('message', handler);
				$session.user = event.data.user;
			});
		},

		logout: async () => {
			const r = await fetch(`/auth/logout`, {
				credentials: 'include'
			});

			if (r.ok) $session.user = null;
		}
	});

	if ($$props.segment === void 0 && $$bindings.segment && segment !== void 0) $$bindings.segment(segment);

	$$result.css.add(css$1);

	$session = index.get_store_value(session);
	$preloading = index.get_store_value(preloading);
	$page = index.get_store_value(page);

	return `${index.validate_component(index$1.Icons, 'Icons').$$render($$result, {}, {}, {})}

	${ $preloading ? `${index.validate_component(PreloadingIndicator, 'PreloadingIndicator').$$render($$result, {}, {}, {})}` : `` }

	${ $page.path !== '/repl/embed' ? `${index.validate_component(index$1.Nav, 'Nav').$$render($$result, {
		segment: segment,
		page: page,
		logo: "svelte-logo-horizontal.svg"
	}, {}, {
		default: () => `
			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, { segment: "tutorial" }, {}, { default: () => `教程` })}
			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, { segment: "docs" }, {}, { default: () => `API` })}
			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, { segment: "examples" }, {}, { default: () => `实例` })}
			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, { segment: "repl" }, {}, { default: () => `REPL` })}
			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, { segment: "blog" }, {}, { default: () => `博客` })}
			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, { segment: "faq" }, {}, { default: () => `常见问题` })}

			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, {
		external: "https://github.com/Runningzs/svelte-ZH/issues"
	}, {}, { default: () => `报告翻译错误` })}
			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, { external: "https://sapper.svelte.dev" }, {}, { default: () => `Sapper` })}

			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, { external: "chat", title: "svelteJS交流群" }, {}, {
		default: () => `
				${index.validate_component(index$1.Icon, 'Icon').$$render($$result, { name: "message-square" }, {}, {})}
			`
	})}

			${index.validate_component(index$1.NavItem, 'NavItem').$$render($$result, {
		external: "https://github.com/Runningzs/svelte-ZH",
		title: "GitHub Repo"
	}, {}, {
		default: () => `
				${index.validate_component(index$1.Icon, 'Icon').$$render($$result, { name: "github" }, {}, {})}
			`
	})}
		`
	})}` : `` }

	<main class="svelte-hxszvy">
		${$$slots.default ? $$slots.default({}) : ``}
	</main>`;
});

/* src\routes\_error.svelte generated by Svelte v3.12.0 */

const css$2 = {
	code: ".container.svelte-lk6uuh{padding:var(--top-offset) var(--side-nav) 6rem var(--side-nav)}h1.svelte-lk6uuh,p.svelte-lk6uuh{margin:0 auto }h1.svelte-lk6uuh{font-size:2.8em;font-weight:300;margin:0 0 0.5em 0}p.svelte-lk6uuh{margin:1em auto }.error.svelte-lk6uuh{background-color:#da106e;color:white;padding:12px 16px;font:600 16px/1.7 var(--font);border-radius:2px}",
	map: "{\"version\":3,\"file\":\"_error.svelte\",\"sources\":[\"_error.svelte\"],\"sourcesContent\":[\"<script>\\r\\n\\tconst dev = undefined === 'development';\\r\\n\\r\\n\\texport let status;\\r\\n\\texport let error;\\r\\n\\r\\n\\t// we don't want to use <svelte:window bind:online> here,\\r\\n\\t// because we only care about the online state when\\r\\n\\t// the page first loads\\r\\n\\tconst online = typeof navigator !== 'undefined'\\r\\n\\t\\t? navigator.onLine\\r\\n\\t\\t: true;\\r\\n</script>\\r\\n\\r\\n<style>\\r\\n\\t.container {\\r\\n\\t\\tpadding: var(--top-offset) var(--side-nav) 6rem var(--side-nav);\\r\\n\\t}\\r\\n\\r\\n\\th1, p { margin: 0 auto }\\r\\n\\r\\n\\th1 {\\r\\n\\t\\tfont-size: 2.8em;\\r\\n\\t\\tfont-weight: 300;\\r\\n\\t\\tmargin: 0 0 0.5em 0;\\r\\n\\t}\\r\\n\\r\\n\\tp { margin: 1em auto }\\r\\n\\r\\n\\t.error {\\r\\n\\t\\tbackground-color: #da106e;\\r\\n\\t\\tcolor: white;\\r\\n\\t\\tpadding: 12px 16px;\\r\\n\\t\\tfont: 600 16px/1.7 var(--font);\\r\\n\\t\\tborder-radius: 2px;\\r\\n\\t}\\r\\n\\r\\n\\t/* @media (min-width: 480px) {\\r\\n\\t\\th1 { font-size: 4em }\\r\\n\\t} */\\r\\n</style>\\r\\n\\r\\n<svelte:head>\\r\\n\\t<title>{status}</title>\\r\\n</svelte:head>\\r\\n\\r\\n<div class=\\\"container\\\">\\r\\n\\t{#if online}\\r\\n\\t\\t<h1>Yikes!</h1>\\r\\n\\r\\n\\t\\t{#if error.message}\\r\\n\\t\\t\\t<p class=\\\"error\\\">{status}: {error.message}</p>\\r\\n\\t\\t{:else}\\r\\n\\t\\t\\t<p class=\\\"error\\\">Encountered a {status} error</p>\\r\\n\\t\\t{/if}\\r\\n\\r\\n\\t\\t{#if dev && error.stack}\\r\\n\\t\\t\\t<pre>{error.stack}</pre>\\r\\n\\t\\t{:else}\\r\\n\\t\\t\\t{#if status >= 500}\\r\\n\\t\\t\\t\\t<p>Please try reloading the page.</p>\\r\\n\\t\\t\\t{/if}\\r\\n\\r\\n\\t\\t\\t<p>If the error persists, please drop by <a href=\\\"chat\\\">Discord chatroom</a> and let us know, or raise an issue on <a href=\\\"https://github.com/sveltejs/svelte\\\">GitHub</a>. Thanks!</p>\\r\\n\\t\\t{/if}\\r\\n\\t{:else}\\r\\n\\t\\t<h1>It looks like you're offline</h1>\\r\\n\\r\\n\\t\\t<p>Reload the page once you've found the internet.</p>\\r\\n\\t{/if}\\r\\n</div>\"],\"names\":[],\"mappings\":\"AAeC,UAAU,cAAC,CAAC,AACX,OAAO,CAAE,IAAI,YAAY,CAAC,CAAC,IAAI,UAAU,CAAC,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,AAChE,CAAC,AAED,gBAAE,CAAE,CAAC,cAAC,CAAC,AAAC,MAAM,CAAE,CAAC,CAAC,IAAI,CAAC,CAAC,AAExB,EAAE,cAAC,CAAC,AACH,SAAS,CAAE,KAAK,CAChB,WAAW,CAAE,GAAG,CAChB,MAAM,CAAE,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,AACpB,CAAC,AAED,CAAC,cAAC,CAAC,AAAC,MAAM,CAAE,GAAG,CAAC,IAAI,CAAC,CAAC,AAEtB,MAAM,cAAC,CAAC,AACP,gBAAgB,CAAE,OAAO,CACzB,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,IAAI,CAAE,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,CAC9B,aAAa,CAAE,GAAG,AACnB,CAAC\"}"
};

const Error$1 = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {

	let { status, error } = $$props;

	// we don't want to use <svelte:window bind:online> here,
	// because we only care about the online state when
	// the page first loads
	const online = typeof navigator !== 'undefined'
		? navigator.onLine
		: true;

	if ($$props.status === void 0 && $$bindings.status && status !== void 0) $$bindings.status(status);
	if ($$props.error === void 0 && $$bindings.error && error !== void 0) $$bindings.error(error);

	$$result.css.add(css$2);

	return `${($$result.head += `<title>${index.escape(status)}</title>`, "")}

	<div class="container svelte-lk6uuh">
		${ online ? `<h1 class="svelte-lk6uuh">Yikes!</h1>

			${ error.message ? `<p class="error svelte-lk6uuh">${index.escape(status)}: ${index.escape(error.message)}</p>` : `<p class="error svelte-lk6uuh">Encountered a ${index.escape(status)} error</p>` }

			${  `${ status >= 500 ? `<p class="svelte-lk6uuh">Please try reloading the page.</p>` : `` }

				<p class="svelte-lk6uuh">If the error persists, please drop by <a href="chat">Discord chatroom</a> and let us know, or raise an issue on <a href="https://github.com/sveltejs/svelte">GitHub</a>. Thanks!</p>` }` : `<h1 class="svelte-lk6uuh">It looks like you're offline</h1>

			<p class="svelte-lk6uuh">Reload the page once you've found the internet.</p>` }
	</div>`;
});

/* src\node_modules\@sapper\internal\App.svelte generated by Svelte v3.12.0 */

const App = index.create_ssr_component(($$result, $$props, $$bindings, $$slots) => {
	

	let { stores, error, status, segments, level0, level1 = null, level2 = null } = $$props;

	index.setContext(CONTEXT_KEY, stores);

	if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0) $$bindings.stores(stores);
	if ($$props.error === void 0 && $$bindings.error && error !== void 0) $$bindings.error(error);
	if ($$props.status === void 0 && $$bindings.status && status !== void 0) $$bindings.status(status);
	if ($$props.segments === void 0 && $$bindings.segments && segments !== void 0) $$bindings.segments(segments);
	if ($$props.level0 === void 0 && $$bindings.level0 && level0 !== void 0) $$bindings.level0(level0);
	if ($$props.level1 === void 0 && $$bindings.level1 && level1 !== void 0) $$bindings.level1(level1);
	if ($$props.level2 === void 0 && $$bindings.level2 && level2 !== void 0) $$bindings.level2(level2);

	return `


	${index.validate_component(Layout, 'Layout').$$render($$result, Object.assign({ segment: segments[0] }, level0.props), {}, {
		default: () => `
		${ error ? `${index.validate_component(Error$1, 'Error').$$render($$result, { error: error, status: status }, {}, {})}` : `${index.validate_component(((level1.component) || index.missing_component), 'svelte:component').$$render($$result, Object.assign({ segment: segments[1] }, level1.props), {}, {
		default: () => `
				${ level2 ? `${index.validate_component(((level2.component) || index.missing_component), 'svelte:component').$$render($$result, Object.assign(level2.props), {}, {})}` : `` }
			`
	})}` }
	`
	})}`;
});

// This file is generated by Sapper — do not edit it!

const ignore = [/^\/examples.json$/, /^\/examples\/([^\/]+?).json$/, /^\/tutorial.json$/, /^\/tutorial\/random-number\/?$/, /^\/tutorial\/([^\/]+?).json$/, /^\/apps.json$/, /^\/auth\/callback\/?$/, /^\/auth\/logout\/?$/, /^\/auth\/login\/?$/, /^\/blog.json$/, /^\/blog\/rss.xml$/, /^\/blog\/([^\/]+?).json$/, /^\/chat\/?$/, /^\/docs.json$/, /^\/repl\/create.json$/, /^\/repl\/local\/(.+)$/, /^\/repl\/([^\/]+?).json$/, /^\/faq\/?$/];

const components = [
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-959f4e88.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-5ad0942a.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:examples/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./_layout-252a0470.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:tutorial/_layout.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-bfc98993.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:tutorial/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-e9d7a721.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:tutorial/[slug]/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-b5b32756.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:apps/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-7a7ab728.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:blog/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./[slug]-ea45cdef.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:blog/[slug].svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-dc3d640e.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:docs/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-4a923e48.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:repl/index.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./embed-f27cd81a.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:repl/embed.svelte__"
	},
	{
		js: () => new Promise(function (resolve) { resolve(require('./index-ab649393.js')); }),
		css: "__SAPPER_CSS_PLACEHOLDER:repl/[id]/index.svelte__"
	}
];

const routes = (d => [
	{
		// index.svelte
		pattern: /^\/$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// examples/index.svelte
		pattern: /^\/examples\/?$/,
		parts: [
			{ i: 1 }
		]
	},

	{
		// tutorial/index.svelte
		pattern: /^\/tutorial\/?$/,
		parts: [
			{ i: 2 },
			{ i: 3 }
		]
	},

	{
		// tutorial/[slug]/index.svelte
		pattern: /^\/tutorial\/([^\/]+?)\/?$/,
		parts: [
			{ i: 2 },
			{ i: 4, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// apps/index.svelte
		pattern: /^\/apps\/?$/,
		parts: [
			{ i: 5 }
		]
	},

	{
		// blog/index.svelte
		pattern: /^\/blog\/?$/,
		parts: [
			{ i: 6 }
		]
	},

	{
		// blog/[slug].svelte
		pattern: /^\/blog\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 7, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// docs/index.svelte
		pattern: /^\/docs\/?$/,
		parts: [
			{ i: 8 }
		]
	},

	{
		// repl/index.svelte
		pattern: /^\/repl\/?$/,
		parts: [
			{ i: 9 }
		]
	},

	{
		// repl/embed.svelte
		pattern: /^\/repl\/embed\/?$/,
		parts: [
			null,
			{ i: 10 }
		]
	},

	{
		// repl/[id]/index.svelte
		pattern: /^\/repl\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 11, params: match => ({ id: d(match[1]) }) }
		]
	}
])(decodeURIComponent);

function goto(href, opts = { replaceState: false }) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		_history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
		return navigate(target, null).then(() => {});
	}

	location.href = href;
	return new Promise(f => {}); // never resolves
}

const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

let ready = false;
let root_component;
let current_token;
let root_preloaded;
let current_branch = [];
let current_query = '{}';

const stores = {
	page: index$2.writable({}),
	preloading: index$2.writable(null),
	session: index$2.writable(initial_data && initial_data.session)
};

let $session;
let session_dirty;

stores.session.subscribe(async value => {
	$session = value;

	if (!ready) return;
	session_dirty = true;

	const target = select_target(new URL(location.href));

	const token = current_token = {};
	const { redirect, props, branch } = await hydrate_target(target);
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
});

let prefetching


 = null;

let target;

let uid = 1;

let cid;

const _history = typeof history !== 'undefined' ? history : {
	pushState: (state, title, href) => {},
	replaceState: (state, title, href) => {},
	scrollRestoration: ''
};

const scroll_history = {};

function extract_query(search) {
	const query = Object.create(null);
	if (search.length > 0) {
		search.slice(1).split('&').forEach(searchParam => {
			let [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\+/g, ' ')));
			if (typeof query[key] === 'string') query[key] = [query[key]];
			if (typeof query[key] === 'object') (query[key] ).push(value);
			else query[key] = value;
		});
	}
	return query;
}

function select_target(url) {
	if (url.origin !== location.origin) return null;
	if (!url.pathname.startsWith(initial_data.baseUrl)) return null;

	let path = url.pathname.slice(initial_data.baseUrl.length);

	if (path === '') {
		path = '/';
	}

	// avoid accidental clashes between server routes and page routes
	if (ignore.some(pattern => pattern.test(path))) return;

	for (let i = 0; i < routes.length; i += 1) {
		const route = routes[i];

		const match = route.pattern.exec(path);

		if (match) {
			const query = extract_query(url.search);
			const part = route.parts[route.parts.length - 1];
			const params = part.params ? part.params(match) : {};

			const page = { host: location.host, path, query, params };

			return { href: url.href, route, match, page };
		}
	}
}

function scroll_state() {
	return {
		x: pageXOffset,
		y: pageYOffset
	};
}

async function navigate(target, id, noscroll, hash) {
	if (id) {
		// popstate or initial navigation
		cid = id;
	} else {
		const current_scroll = scroll_state();

		// clicked on a link. preserve scroll state
		scroll_history[cid] = current_scroll;

		id = cid = ++uid;
		scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
	}

	cid = id;

	if (root_component) stores.preloading.set(true);

	const loaded = prefetching && prefetching.href === target.href ?
		prefetching.promise :
		hydrate_target(target);

	prefetching = null;

	const token = current_token = {};
	const { redirect, props, branch } = await loaded;
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
	if (document.activeElement) document.activeElement.blur();

	if (!noscroll) {
		let scroll = scroll_history[id];

		if (hash) {
			// scroll is an element id (from a hash), we need to compute y.
			const deep_linked = document.getElementById(hash.slice(1));

			if (deep_linked) {
				scroll = {
					x: 0,
					y: deep_linked.getBoundingClientRect().top
				};
			}
		}

		scroll_history[cid] = scroll;
		if (scroll) scrollTo(scroll.x, scroll.y);
	}
}

async function render(redirect, branch, props, page) {
	if (redirect) return goto(redirect.location, { replaceState: true });

	stores.page.set(page);
	stores.preloading.set(false);

	if (root_component) {
		root_component.$set(props);
	} else {
		props.stores = {
			page: { subscribe: stores.page.subscribe },
			preloading: { subscribe: stores.preloading.subscribe },
			session: stores.session
		};
		props.level0 = {
			props: await root_preloaded
		};

		// first load — remove SSR'd <head> contents
		const start = document.querySelector('#sapper-head-start');
		const end = document.querySelector('#sapper-head-end');

		if (start && end) {
			while (start.nextSibling !== end) detach(start.nextSibling);
			detach(start);
			detach(end);
		}

		root_component = new App({
			target,
			props,
			hydrate: true
		});
	}

	current_branch = branch;
	current_query = JSON.stringify(page.query);
	ready = true;
	session_dirty = false;
}

function part_changed(i, segment, match, stringified_query) {
	// TODO only check query string changes for preload functions
	// that do in fact depend on it (using static analysis or
	// runtime instrumentation)
	if (stringified_query !== current_query) return true;

	const previous = current_branch[i];

	if (!previous) return false;
	if (segment !== previous.segment) return true;
	if (previous.match) {
		if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {
			return true;
		}
	}
}

async function hydrate_target(target)



 {
	const { route, page } = target;
	const segments = page.path.split('/').filter(Boolean);

	let redirect = null;

	const props = { error: null, status: 200, segments: [segments[0]] };

	const preload_context = {
		fetch: (url, opts) => fetch(url, opts),
		redirect: (statusCode, location) => {
			if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
				throw new Error(`Conflicting redirects`);
			}
			redirect = { statusCode, location };
		},
		error: (status, error) => {
			props.error = typeof error === 'string' ? new Error(error) : error;
			props.status = status;
		}
	};

	if (!root_preloaded) {
		root_preloaded = initial_data.preloaded[0] || preload.call(preload_context, {
			host: page.host,
			path: page.path,
			query: page.query,
			params: {}
		}, $session);
	}

	let branch;
	let l = 1;

	try {
		const stringified_query = JSON.stringify(page.query);
		const match = route.pattern.exec(page.path);

		let segment_dirty = false;

		branch = await Promise.all(route.parts.map(async (part, i) => {
			const segment = segments[i];

			if (part_changed(i, segment, match, stringified_query)) segment_dirty = true;

			props.segments[l] = segments[i + 1]; // TODO make this less confusing
			if (!part) return { segment };

			const j = l++;

			if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {
				return current_branch[i];
			}

			segment_dirty = false;

			const { default: component, preload } = await load_component(components[part.i]);

			let preloaded;
			if (ready || !initial_data.preloaded[i + 1]) {
				preloaded = preload
					? await preload.call(preload_context, {
						host: page.host,
						path: page.path,
						query: page.query,
						params: part.params ? part.params(target.match) : {}
					}, $session)
					: {};
			} else {
				preloaded = initial_data.preloaded[i + 1];
			}

			return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });
		}));
	} catch (error) {
		props.error = error;
		props.status = 500;
		branch = [];
	}

	return { redirect, props, branch };
}

function load_css(chunk) {
	const href = `client/${chunk}`;
	if (document.querySelector(`link[href="${href}"]`)) return;

	return new Promise((fulfil, reject) => {
		const link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;

		link.onload = () => fulfil();
		link.onerror = reject;

		document.head.appendChild(link);
	});
}

function load_component(component)


 {
	// TODO this is temporary — once placeholders are
	// always rewritten, scratch the ternary
	const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
	promises.unshift(component.js());
	return Promise.all(promises).then(values => values[0]);
}

function detach(node) {
	node.parentNode.removeChild(node);
}

const stores$1 = () => index.getContext(CONTEXT_KEY);

exports.App = App;
exports.error = Error$1;
exports.goto = goto;
exports.root = Layout;
exports.stores$1 = stores$1;
