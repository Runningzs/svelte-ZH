import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, q as create_slot, e as element, c as claim_element, a as children, b as detach_dev, f as attr_dev, h as add_location, j as insert_dev, C as get_slot_changes, D as get_slot_context, x as transition_in, y as transition_out, w as mount_component, z as destroy_component, l as space, p as claim_space, g as set_style, k as append_dev, M as svg_element, N as xlink_attr, n as noop, O as afterUpdate, P as HtmlTag, Q as toggle_class, A as group_outros, B as check_outros, R as destroy_each, T as listen_dev, U as run_all, V as binding_callbacks, o as onMount, W as add_render_callback, E as text, F as claim_text, H as set_data_dev, v as validate_store, r as component_subscribe, t as setContext, u as set_store_value, G as globals, L as getContext, m as empty } from './index.4e52d202.js';
import { w as writable } from './index.ad9ca859.js';

/* node_modules\@sveltejs\site-kit\components\Section.svelte generated by Svelte v3.12.0 */

const file = "node_modules\\@sveltejs\\site-kit\\components\\Section.svelte";

function create_fragment(ctx) {
	var section, current;

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			section = element("section");

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true }, false);
			var section_nodes = children(section);

			if (default_slot) default_slot.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(section, "class", "svelte-80zz5d");
			add_location(section, file, 13, 0, 189);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);

			if (default_slot) {
				default_slot.m(section, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {};

	return { $$slots, $$scope };
}

class Section extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, []);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Section", options, id: create_fragment.name });
	}
}

/* node_modules\@sveltejs\site-kit\components\Blurb.svelte generated by Svelte v3.12.0 */

const file$1 = "node_modules\\@sveltejs\\site-kit\\components\\Blurb.svelte";

const get_how_slot_changes = () => ({});
const get_how_slot_context = () => ({});

const get_what_slot_changes = () => ({});
const get_what_slot_context = () => ({});

const get_three_slot_changes = () => ({});
const get_three_slot_context = () => ({});

const get_two_slot_changes = () => ({});
const get_two_slot_context = () => ({});

const get_one_slot_changes = () => ({});
const get_one_slot_context = () => ({});

// (135:0) <Section>
function create_default_slot(ctx) {
	var div5, div0, t0, div1, t1, div2, t2, div3, t3, div4, current;

	const one_slot_template = ctx.$$slots.one;
	const one_slot = create_slot(one_slot_template, ctx, get_one_slot_context);

	const two_slot_template = ctx.$$slots.two;
	const two_slot = create_slot(two_slot_template, ctx, get_two_slot_context);

	const three_slot_template = ctx.$$slots.three;
	const three_slot = create_slot(three_slot_template, ctx, get_three_slot_context);

	const what_slot_template = ctx.$$slots.what;
	const what_slot = create_slot(what_slot_template, ctx, get_what_slot_context);

	const how_slot_template = ctx.$$slots.how;
	const how_slot = create_slot(how_slot_template, ctx, get_how_slot_context);

	const block = {
		c: function create() {
			div5 = element("div");
			div0 = element("div");

			if (one_slot) one_slot.c();
			t0 = space();
			div1 = element("div");

			if (two_slot) two_slot.c();
			t1 = space();
			div2 = element("div");

			if (three_slot) three_slot.c();
			t2 = space();
			div3 = element("div");

			if (what_slot) what_slot.c();
			t3 = space();
			div4 = element("div");

			if (how_slot) how_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			div5 = claim_element(nodes, "DIV", { class: true }, false);
			var div5_nodes = children(div5);

			div0 = claim_element(div5_nodes, "DIV", { class: true, style: true }, false);
			var div0_nodes = children(div0);

			if (one_slot) one_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div5_nodes);

			div1 = claim_element(div5_nodes, "DIV", { class: true, style: true }, false);
			var div1_nodes = children(div1);

			if (two_slot) two_slot.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(div5_nodes);

			div2 = claim_element(div5_nodes, "DIV", { class: true, style: true }, false);
			var div2_nodes = children(div2);

			if (three_slot) three_slot.l(div2_nodes);
			div2_nodes.forEach(detach_dev);
			t2 = claim_space(div5_nodes);

			div3 = claim_element(div5_nodes, "DIV", { class: true, style: true }, false);
			var div3_nodes = children(div3);

			if (what_slot) what_slot.l(div3_nodes);
			div3_nodes.forEach(detach_dev);
			t3 = claim_space(div5_nodes);

			div4 = claim_element(div5_nodes, "DIV", { class: true, style: true }, false);
			var div4_nodes = children(div4);

			if (how_slot) how_slot.l(div4_nodes);
			div4_nodes.forEach(detach_dev);
			div5_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "box svelte-soq4oe");
			set_style(div0, "background", "var(--prime)");
			set_style(div0, "grid-area", "one");
			add_location(div0, file$1, 136, 2, 2226);

			attr_dev(div1, "class", "box svelte-soq4oe");
			set_style(div1, "background", "var(--flash)");
			set_style(div1, "grid-area", "two");
			add_location(div1, file$1, 140, 2, 2338);

			attr_dev(div2, "class", "box svelte-soq4oe");
			set_style(div2, "background", "var(--second)");
			set_style(div2, "grid-area", "three");
			add_location(div2, file$1, 144, 2, 2450);

			attr_dev(div3, "class", "what svelte-soq4oe");
			set_style(div3, "grid-area", "what");
			add_location(div3, file$1, 148, 2, 2567);

			attr_dev(div4, "class", "how svelte-soq4oe");
			set_style(div4, "grid-area", "how");
			add_location(div4, file$1, 152, 2, 2656);
			attr_dev(div5, "class", "blurb svelte-soq4oe");
			add_location(div5, file$1, 135, 1, 2203);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div5, anchor);
			append_dev(div5, div0);

			if (one_slot) {
				one_slot.m(div0, null);
			}

			append_dev(div5, t0);
			append_dev(div5, div1);

			if (two_slot) {
				two_slot.m(div1, null);
			}

			append_dev(div5, t1);
			append_dev(div5, div2);

			if (three_slot) {
				three_slot.m(div2, null);
			}

			append_dev(div5, t2);
			append_dev(div5, div3);

			if (what_slot) {
				what_slot.m(div3, null);
			}

			append_dev(div5, t3);
			append_dev(div5, div4);

			if (how_slot) {
				how_slot.m(div4, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (one_slot && one_slot.p && changed.$$scope) {
				one_slot.p(
					get_slot_changes(one_slot_template, ctx, changed, get_one_slot_changes),
					get_slot_context(one_slot_template, ctx, get_one_slot_context)
				);
			}

			if (two_slot && two_slot.p && changed.$$scope) {
				two_slot.p(
					get_slot_changes(two_slot_template, ctx, changed, get_two_slot_changes),
					get_slot_context(two_slot_template, ctx, get_two_slot_context)
				);
			}

			if (three_slot && three_slot.p && changed.$$scope) {
				three_slot.p(
					get_slot_changes(three_slot_template, ctx, changed, get_three_slot_changes),
					get_slot_context(three_slot_template, ctx, get_three_slot_context)
				);
			}

			if (what_slot && what_slot.p && changed.$$scope) {
				what_slot.p(
					get_slot_changes(what_slot_template, ctx, changed, get_what_slot_changes),
					get_slot_context(what_slot_template, ctx, get_what_slot_context)
				);
			}

			if (how_slot && how_slot.p && changed.$$scope) {
				how_slot.p(
					get_slot_changes(how_slot_template, ctx, changed, get_how_slot_changes),
					get_slot_context(how_slot_template, ctx, get_how_slot_context)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(one_slot, local);
			transition_in(two_slot, local);
			transition_in(three_slot, local);
			transition_in(what_slot, local);
			transition_in(how_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(one_slot, local);
			transition_out(two_slot, local);
			transition_out(three_slot, local);
			transition_out(what_slot, local);
			transition_out(how_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div5);
			}

			if (one_slot) one_slot.d(detaching);

			if (two_slot) two_slot.d(detaching);

			if (three_slot) three_slot.d(detaching);

			if (what_slot) what_slot.d(detaching);

			if (how_slot) how_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot.name, type: "slot", source: "(135:0) <Section>", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var current;

	var section = new Section({
		props: {
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			section.$$.fragment.c();
		},

		l: function claim(nodes) {
			section.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(section, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var section_changes = {};
			if (changed.$$scope) section_changes.$$scope = { changed, ctx };
			section.$set(section_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(section.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(section.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(section, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {};

	return { $$slots, $$scope };
}

class Blurb extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, []);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Blurb", options, id: create_fragment$1.name });
	}
}

/* node_modules\@sveltejs\site-kit\components\Icon.svelte generated by Svelte v3.12.0 */

const file$2 = "node_modules\\@sveltejs\\site-kit\\components\\Icon.svelte";

function create_fragment$2(ctx) {
	var svg, use, use_xlink_href_value;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			use = svg_element("use");
			this.h();
		},

		l: function claim(nodes) {
			svg = claim_element(nodes, "svg", { class: true, width: true, height: true }, true);
			var svg_nodes = children(svg);

			use = claim_element(svg_nodes, "use", { "xlink:href": true }, true);
			var use_nodes = children(use);

			use_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			xlink_attr(use, "xlink:href", use_xlink_href_value = "#" + ctx.name);
			add_location(use, file$2, 14, 1, 322);
			attr_dev(svg, "class", "icon svelte-1krj0rw");
			attr_dev(svg, "width", ctx.size);
			attr_dev(svg, "height", ctx.size);
			add_location(svg, file$2, 13, 0, 274);
		},

		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, use);
		},

		p: function update(changed, ctx) {
			if ((changed.name) && use_xlink_href_value !== (use_xlink_href_value = "#" + ctx.name)) {
				xlink_attr(use, "xlink:href", use_xlink_href_value);
			}

			if (changed.size) {
				attr_dev(svg, "width", ctx.size);
				attr_dev(svg, "height", ctx.size);
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(svg);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$2.name, type: "component", source: "", ctx });
	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { name, size = 20 } = $$props;

	const writable_props = ['name', 'size'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Icon> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('size' in $$props) $$invalidate('size', size = $$props.size);
	};

	$$self.$capture_state = () => {
		return { name, size };
	};

	$$self.$inject_state = $$props => {
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('size' in $$props) $$invalidate('size', size = $$props.size);
	};

	return { name, size };
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["name", "size"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Icon", options, id: create_fragment$2.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.name === undefined && !('name' in props)) {
			console.warn("<Icon> was created without expected prop 'name'");
		}
	}

	get name() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\site-kit\components\GuideContents.svelte generated by Svelte v3.12.0 */

const file$3 = "node_modules\\@sveltejs\\site-kit\\components\\GuideContents.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.subsection = list[i];
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.section = list[i];
	return child_ctx;
}

// (114:4) {#if section.slug === active_section}
function create_if_block_1(ctx) {
	var div, current;

	var icon = new Icon({
		props: { name: "arrow-right" },
		$$inline: true
	});

	const block = {
		c: function create() {
			div = element("div");
			icon.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			icon.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "icon-container svelte-nvksgk");
			add_location(div, file$3, 114, 5, 2242);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(icon, div, null);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(icon);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(114:4) {#if section.slug === active_section}", ctx });
	return block;
}

// (131:5) {#if subsection.slug === active_section}
function create_if_block(ctx) {
	var div, current;

	var icon = new Icon({
		props: { name: "arrow-right" },
		$$inline: true
	});

	const block = {
		c: function create() {
			div = element("div");
			icon.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			icon.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "icon-container svelte-nvksgk");
			add_location(div, file$3, 131, 6, 2724);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(icon, div, null);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			destroy_component(icon);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(131:5) {#if subsection.slug === active_section}", ctx });
	return block;
}

// (121:3) {#each section.subsections as subsection}
function create_each_block_1(ctx) {
	var a, html_tag, raw_value = ctx.subsection.title + "", t, a_href_value, a_data_level_value, current;

	var if_block = (ctx.subsection.slug === ctx.active_section) && create_if_block(ctx);

	const block = {
		c: function create() {
			a = element("a");
			t = space();
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			a = claim_element(nodes, "A", { class: true, href: true, "data-level": true }, false);
			var a_nodes = children(a);

			t = claim_space(a_nodes);
			if (if_block) if_block.l(a_nodes);
			a_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			html_tag = new HtmlTag(raw_value, t);
			attr_dev(a, "class", "subsection svelte-nvksgk");
			attr_dev(a, "href", a_href_value = "docs#" + ctx.subsection.slug);
			attr_dev(a, "data-level", a_data_level_value = ctx.subsection.level);
			toggle_class(a, "active", ctx.subsection.slug === ctx.active_section);
			add_location(a, file$3, 122, 4, 2470);
		},

		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			html_tag.m(a);
			append_dev(a, t);
			if (if_block) if_block.m(a, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.sections) && raw_value !== (raw_value = ctx.subsection.title + "")) {
				html_tag.p(raw_value);
			}

			if (ctx.subsection.slug === ctx.active_section) {
				if (!if_block) {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, null);
				} else transition_in(if_block, 1);
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}

			if ((!current || changed.sections) && a_href_value !== (a_href_value = "docs#" + ctx.subsection.slug)) {
				attr_dev(a, "href", a_href_value);
			}

			if ((!current || changed.sections) && a_data_level_value !== (a_data_level_value = ctx.subsection.level)) {
				attr_dev(a, "data-level", a_data_level_value);
			}

			if ((changed.sections || changed.active_section)) {
				toggle_class(a, "active", ctx.subsection.slug === ctx.active_section);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}

			if (if_block) if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block_1.name, type: "each", source: "(121:3) {#each section.subsections as subsection}", ctx });
	return block;
}

// (109:1) {#each sections as section}
function create_each_block(ctx) {
	var li, a, html_tag, raw_value = ctx.section.metadata.title + "", t0, a_href_value, t1, t2, current;

	var if_block = (ctx.section.slug === ctx.active_section) && create_if_block_1(ctx);

	let each_value_1 = ctx.section.subsections;

	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", { class: true, href: true }, false);
			var a_nodes = children(a);

			t0 = claim_space(a_nodes);
			if (if_block) if_block.l(a_nodes);
			a_nodes.forEach(detach_dev);
			t1 = claim_space(li_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(li_nodes);
			}

			t2 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			html_tag = new HtmlTag(raw_value, t0);
			attr_dev(a, "class", "section svelte-nvksgk");
			attr_dev(a, "href", a_href_value = "docs#" + ctx.section.slug);
			toggle_class(a, "active", ctx.section.slug === ctx.active_section);
			add_location(a, file$3, 110, 3, 2059);
			attr_dev(li, "class", "svelte-nvksgk");
			add_location(li, file$3, 109, 2, 2050);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			html_tag.m(a);
			append_dev(a, t0);
			if (if_block) if_block.m(a, null);
			append_dev(li, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(li, null);
			}

			append_dev(li, t2);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.sections) && raw_value !== (raw_value = ctx.section.metadata.title + "")) {
				html_tag.p(raw_value);
			}

			if (ctx.section.slug === ctx.active_section) {
				if (!if_block) {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(a, null);
				} else transition_in(if_block, 1);
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}

			if ((!current || changed.sections) && a_href_value !== (a_href_value = "docs#" + ctx.section.slug)) {
				attr_dev(a, "href", a_href_value);
			}

			if ((changed.sections || changed.active_section)) {
				toggle_class(a, "active", ctx.section.slug === ctx.active_section);
			}

			if (changed.sections || changed.active_section) {
				each_value_1 = ctx.section.subsections;

				let i;
				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(li, t2);
					}
				}

				group_outros();
				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);

			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			if (if_block) if_block.d();

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(109:1) {#each sections as section}", ctx });
	return block;
}

function create_fragment$3(ctx) {
	var ul_1, current, dispose;

	let each_value = ctx.sections;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul_1 = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			ul_1 = claim_element(nodes, "UL", { class: true }, false);
			var ul_1_nodes = children(ul_1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_1_nodes);
			}

			ul_1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(ul_1, "class", "reference-toc svelte-nvksgk");
			add_location(ul_1, file$3, 102, 0, 1856);

			dispose = [
				listen_dev(ul_1, "mouseenter", ctx.mouseenter_handler),
				listen_dev(ul_1, "mouseleave", ctx.mouseleave_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, ul_1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul_1, null);
			}

			ctx.ul_1_binding(ul_1);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.sections || changed.active_section) {
				each_value = ctx.sections;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul_1, null);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(ul_1);
			}

			destroy_each(each_blocks, detaching);

			ctx.ul_1_binding(null);
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$3.name, type: "component", source: "", ctx });
	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	

	let { sections = [], active_section = null, show_contents, prevent_sidebar_scroll = false } = $$props;

	let ul;

	afterUpdate(() => {
		// bit of a hack — prevent sidebar scrolling if
		// TOC is open on mobile, or scroll came from within sidebar
		if (prevent_sidebar_scroll || show_contents && window.innerWidth < 832) return;

		const active = ul.querySelector('.active');

		if (active) {
			const { top, bottom } = active.getBoundingClientRect();

			const min = 200;
			const max = window.innerHeight - 200;

			if (top > max) {
				ul.parentNode.scrollBy({
					top: top - max,
					left: 0,
					behavior: 'smooth'
				});
			} else if (bottom < min) {
				ul.parentNode.scrollBy({
					top: bottom - min,
					left: 0,
					behavior: 'smooth'
				});
			}
		}
	});

	const writable_props = ['sections', 'active_section', 'show_contents', 'prevent_sidebar_scroll'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<GuideContents> was created with unknown prop '${key}'`);
	});

	function ul_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('ul', ul = $$value);
		});
	}

	const mouseenter_handler = () => $$invalidate('prevent_sidebar_scroll', prevent_sidebar_scroll = true);

	const mouseleave_handler = () => $$invalidate('prevent_sidebar_scroll', prevent_sidebar_scroll = false);

	$$self.$set = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('active_section' in $$props) $$invalidate('active_section', active_section = $$props.active_section);
		if ('show_contents' in $$props) $$invalidate('show_contents', show_contents = $$props.show_contents);
		if ('prevent_sidebar_scroll' in $$props) $$invalidate('prevent_sidebar_scroll', prevent_sidebar_scroll = $$props.prevent_sidebar_scroll);
	};

	$$self.$capture_state = () => {
		return { sections, active_section, show_contents, prevent_sidebar_scroll, ul };
	};

	$$self.$inject_state = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('active_section' in $$props) $$invalidate('active_section', active_section = $$props.active_section);
		if ('show_contents' in $$props) $$invalidate('show_contents', show_contents = $$props.show_contents);
		if ('prevent_sidebar_scroll' in $$props) $$invalidate('prevent_sidebar_scroll', prevent_sidebar_scroll = $$props.prevent_sidebar_scroll);
		if ('ul' in $$props) $$invalidate('ul', ul = $$props.ul);
	};

	return {
		sections,
		active_section,
		show_contents,
		prevent_sidebar_scroll,
		ul,
		ul_1_binding,
		mouseenter_handler,
		mouseleave_handler
	};
}

class GuideContents extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["sections", "active_section", "show_contents", "prevent_sidebar_scroll"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "GuideContents", options, id: create_fragment$3.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.show_contents === undefined && !('show_contents' in props)) {
			console.warn("<GuideContents> was created without expected prop 'show_contents'");
		}
	}

	get sections() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get active_section() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set active_section(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get show_contents() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set show_contents(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get prevent_sidebar_scroll() {
		throw new Error("<GuideContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set prevent_sidebar_scroll(value) {
		throw new Error("<GuideContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

const getFragment = () => window.location.hash.slice(1);

/* node_modules\@sveltejs\site-kit\components\Docs.svelte generated by Svelte v3.12.0 */

const file$4 = "node_modules\\@sveltejs\\site-kit\\components\\Docs.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.section = list[i];
	return child_ctx;
}

// (377:1) {#each sections as section}
function create_each_block$1(ctx) {
	var section, h2, span, span_id_value, t0, a0, a0_href_value, t1, html_tag, raw0_value = ctx.section.metadata.title + "", t2, small, a1, a1_href_value, t3, html_tag_1, raw1_value = ctx.section.html + "", t4, section_data_id_value, current;

	var icon = new Icon({ props: { name: "edit" }, $$inline: true });

	const block = {
		c: function create() {
			section = element("section");
			h2 = element("h2");
			span = element("span");
			t0 = space();
			a0 = element("a");
			t1 = space();
			t2 = space();
			small = element("small");
			a1 = element("a");
			icon.$$.fragment.c();
			t3 = space();
			t4 = space();
			this.h();
		},

		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { "data-id": true, class: true }, false);
			var section_nodes = children(section);

			h2 = claim_element(section_nodes, "H2", { class: true }, false);
			var h2_nodes = children(h2);

			span = claim_element(h2_nodes, "SPAN", { class: true, id: true }, false);
			var span_nodes = children(span);

			span_nodes.forEach(detach_dev);
			t0 = claim_space(h2_nodes);

			a0 = claim_element(h2_nodes, "A", { href: true, class: true, "aria-hidden": true }, false);
			var a0_nodes = children(a0);

			a0_nodes.forEach(detach_dev);
			t1 = claim_space(h2_nodes);
			t2 = claim_space(h2_nodes);

			small = claim_element(h2_nodes, "SMALL", { class: true }, false);
			var small_nodes = children(small);

			a1 = claim_element(small_nodes, "A", { href: true, title: true, class: true }, false);
			var a1_nodes = children(a1);

			icon.$$.fragment.l(a1_nodes);
			a1_nodes.forEach(detach_dev);
			small_nodes.forEach(detach_dev);
			h2_nodes.forEach(detach_dev);
			t3 = claim_space(section_nodes);
			t4 = claim_space(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "offset-anchor");
			attr_dev(span, "id", span_id_value = ctx.section.slug);
			add_location(span, file$4, 379, 4, 7983);
			attr_dev(a0, "href", a0_href_value = "docs#" + ctx.section.slug);
			attr_dev(a0, "class", "anchor");
			attr_dev(a0, "aria-hidden", "");
			add_location(a0, file$4, 382, 4, 8093);
			html_tag = new HtmlTag(raw0_value, t2);
			attr_dev(a1, "href", a1_href_value = "https://github.com/" + ctx.owner + "/" + ctx.project + "/edit/master" + ctx.path + "/" + ctx.dir + "/" + ctx.section.file);
			attr_dev(a1, "title", ctx.edit_title);
			attr_dev(a1, "class", "svelte-17tx6q6");
			add_location(a1, file$4, 386, 5, 8212);
			attr_dev(small, "class", "svelte-17tx6q6");
			add_location(small, file$4, 385, 4, 8198);
			attr_dev(h2, "class", "svelte-17tx6q6");
			add_location(h2, file$4, 378, 3, 7973);
			html_tag_1 = new HtmlTag(raw1_value, t4);
			attr_dev(section, "data-id", section_data_id_value = ctx.section.slug);
			attr_dev(section, "class", "svelte-17tx6q6");
			add_location(section, file$4, 377, 2, 7936);
		},

		m: function mount(target, anchor) {
			insert_dev(target, section, anchor);
			append_dev(section, h2);
			append_dev(h2, span);
			append_dev(h2, t0);
			append_dev(h2, a0);
			append_dev(h2, t1);
			html_tag.m(h2);
			append_dev(h2, t2);
			append_dev(h2, small);
			append_dev(small, a1);
			mount_component(icon, a1, null);
			append_dev(section, t3);
			html_tag_1.m(section);
			append_dev(section, t4);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.sections) && span_id_value !== (span_id_value = ctx.section.slug)) {
				attr_dev(span, "id", span_id_value);
			}

			if ((!current || changed.sections) && a0_href_value !== (a0_href_value = "docs#" + ctx.section.slug)) {
				attr_dev(a0, "href", a0_href_value);
			}

			if ((!current || changed.sections) && raw0_value !== (raw0_value = ctx.section.metadata.title + "")) {
				html_tag.p(raw0_value);
			}

			if ((!current || changed.owner || changed.project || changed.path || changed.dir || changed.sections) && a1_href_value !== (a1_href_value = "https://github.com/" + ctx.owner + "/" + ctx.project + "/edit/master" + ctx.path + "/" + ctx.dir + "/" + ctx.section.file)) {
				attr_dev(a1, "href", a1_href_value);
			}

			if (!current || changed.edit_title) {
				attr_dev(a1, "title", ctx.edit_title);
			}

			if ((!current || changed.sections) && raw1_value !== (raw1_value = ctx.section.html + "")) {
				html_tag_1.p(raw1_value);
			}

			if ((!current || changed.sections) && section_data_id_value !== (section_data_id_value = ctx.section.slug)) {
				attr_dev(section, "data-id", section_data_id_value);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(section);
			}

			destroy_component(icon);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block$1.name, type: "each", source: "(377:1) {#each sections as section}", ctx });
	return block;
}

function create_fragment$4(ctx) {
	var div0, t0, aside_1, div1, t1, button, current, dispose;

	let each_value = ctx.sections;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	var guidecontents = new GuideContents({
		props: {
		sections: ctx.sections,
		active_section: ctx.active_section,
		show_contents: ctx.show_contents
	},
		$$inline: true
	});

	var icon = new Icon({
		props: { name: ctx.show_contents? 'close' : 'menu' },
		$$inline: true
	});

	const block = {
		c: function create() {
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			aside_1 = element("aside");
			div1 = element("div");
			guidecontents.$$.fragment.c();
			t1 = space();
			button = element("button");
			icon.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			aside_1 = claim_element(nodes, "ASIDE", { class: true }, false);
			var aside_1_nodes = children(aside_1);

			div1 = claim_element(aside_1_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			guidecontents.$$.fragment.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t1 = claim_space(aside_1_nodes);

			button = claim_element(aside_1_nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			icon.$$.fragment.l(button_nodes);
			button_nodes.forEach(detach_dev);
			aside_1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "content listify svelte-17tx6q6");
			add_location(div0, file$4, 375, 0, 7851);
			attr_dev(div1, "class", "sidebar svelte-17tx6q6");
			add_location(div1, file$4, 398, 1, 8526);
			attr_dev(button, "class", "svelte-17tx6q6");
			add_location(button, file$4, 402, 1, 8693);
			attr_dev(aside_1, "class", "sidebar-container svelte-17tx6q6");
			toggle_class(aside_1, "open", ctx.show_contents);
			add_location(aside_1, file$4, 397, 0, 8445);

			dispose = [
				listen_dev(div1, "click", ctx.click_handler),
				listen_dev(button, "click", ctx.click_handler_1)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div0, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div0, null);
			}

			ctx.div0_binding(div0);
			insert_dev(target, t0, anchor);
			insert_dev(target, aside_1, anchor);
			append_dev(aside_1, div1);
			mount_component(guidecontents, div1, null);
			append_dev(aside_1, t1);
			append_dev(aside_1, button);
			mount_component(icon, button, null);
			ctx.aside_1_binding(aside_1);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.sections || changed.owner || changed.project || changed.path || changed.dir || changed.edit_title) {
				each_value = ctx.sections;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div0, null);
					}
				}

				group_outros();
				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}
				check_outros();
			}

			var guidecontents_changes = {};
			if (changed.sections) guidecontents_changes.sections = ctx.sections;
			if (changed.active_section) guidecontents_changes.active_section = ctx.active_section;
			if (changed.show_contents) guidecontents_changes.show_contents = ctx.show_contents;
			guidecontents.$set(guidecontents_changes);

			var icon_changes = {};
			if (changed.show_contents) icon_changes.name = ctx.show_contents? 'close' : 'menu';
			icon.$set(icon_changes);

			if (changed.show_contents) {
				toggle_class(aside_1, "open", ctx.show_contents);
			}
		},

		i: function intro(local) {
			if (current) return;
			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(guidecontents.$$.fragment, local);

			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(guidecontents.$$.fragment, local);
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div0);
			}

			destroy_each(each_blocks, detaching);

			ctx.div0_binding(null);

			if (detaching) {
				detach_dev(t0);
				detach_dev(aside_1);
			}

			destroy_component(guidecontents);

			destroy_component(icon);

			ctx.aside_1_binding(null);
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$4.name, type: "component", source: "", ctx });
	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	

	let { owner = 'sveltejs', project = 'svelte', path = '/site/content', dir = 'docs', edit_title = 'edit this section', sections } = $$props;
	let active_section;

	let container;
	let aside;
	let show_contents = false;

	onMount(() => {
		// don't update `active_section` for headings above level 4, see _sections.js
		const anchors = container.querySelectorAll('[id]:not([data-scrollignore])');

		let positions;

		const onresize = () => {
			const { top } = container.getBoundingClientRect();
			positions = [].map.call(anchors, anchor => {
				return anchor.getBoundingClientRect().top - top;
			});
		};

		let last_id = getFragment();

		const onscroll = () => {
			const top = -window.scrollY;

			let i = anchors.length;
			while (i--) {
				if (positions[i] + top < 40) {
					const anchor = anchors[i];
					const { id } = anchor;

					if (id !== last_id) {
						$$invalidate('active_section', active_section = id);
						last_id = id;
					}

					return;
				}
			}
		};

		window.addEventListener('scroll', onscroll, true);
		window.addEventListener('resize', onresize, true);

		// wait for fonts to load...
		const timeouts = [
			setTimeout(onresize, 1000),
			setTimeout(onscroll, 5000)
		];

		onresize();
		onscroll();

		return () => {
			window.removeEventListener('scroll', onscroll, true);
			window.removeEventListener('resize', onresize, true);

			timeouts.forEach(timeout => clearTimeout(timeout));
		};
	});

	const writable_props = ['owner', 'project', 'path', 'dir', 'edit_title', 'sections'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Docs> was created with unknown prop '${key}'`);
	});

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('container', container = $$value);
		});
	}

	const click_handler = () => $$invalidate('show_contents', show_contents = false);

	const click_handler_1 = () => $$invalidate('show_contents', show_contents = !show_contents);

	function aside_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('aside', aside = $$value);
		});
	}

	$$self.$set = $$props => {
		if ('owner' in $$props) $$invalidate('owner', owner = $$props.owner);
		if ('project' in $$props) $$invalidate('project', project = $$props.project);
		if ('path' in $$props) $$invalidate('path', path = $$props.path);
		if ('dir' in $$props) $$invalidate('dir', dir = $$props.dir);
		if ('edit_title' in $$props) $$invalidate('edit_title', edit_title = $$props.edit_title);
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
	};

	$$self.$capture_state = () => {
		return { owner, project, path, dir, edit_title, sections, active_section, container, aside, show_contents };
	};

	$$self.$inject_state = $$props => {
		if ('owner' in $$props) $$invalidate('owner', owner = $$props.owner);
		if ('project' in $$props) $$invalidate('project', project = $$props.project);
		if ('path' in $$props) $$invalidate('path', path = $$props.path);
		if ('dir' in $$props) $$invalidate('dir', dir = $$props.dir);
		if ('edit_title' in $$props) $$invalidate('edit_title', edit_title = $$props.edit_title);
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('active_section' in $$props) $$invalidate('active_section', active_section = $$props.active_section);
		if ('container' in $$props) $$invalidate('container', container = $$props.container);
		if ('aside' in $$props) $$invalidate('aside', aside = $$props.aside);
		if ('show_contents' in $$props) $$invalidate('show_contents', show_contents = $$props.show_contents);
	};

	return {
		owner,
		project,
		path,
		dir,
		edit_title,
		sections,
		active_section,
		container,
		aside,
		show_contents,
		div0_binding,
		click_handler,
		click_handler_1,
		aside_1_binding
	};
}

class Docs extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, ["owner", "project", "path", "dir", "edit_title", "sections"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Docs", options, id: create_fragment$4.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.sections === undefined && !('sections' in props)) {
			console.warn("<Docs> was created without expected prop 'sections'");
		}
	}

	get owner() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set owner(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get project() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set project(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get path() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set path(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get dir() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set dir(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get edit_title() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set edit_title(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sections() {
		throw new Error("<Docs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<Docs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\site-kit\components\ParallaxLogo.svelte generated by Svelte v3.12.0 */

const file$5 = "node_modules\\@sveltejs\\site-kit\\components\\ParallaxLogo.svelte";

function create_fragment$5(ctx) {
	var scrolling = false, clear_scrolling = () => { scrolling = false; }, scrolling_timeout, img, dispose;

	add_render_callback(ctx.onwindowscroll);

	const block = {
		c: function create() {
			img = element("img");
			this.h();
		},

		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", { alt: true, src: true, class: true, style: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "alt", ctx.alt);
			attr_dev(img, "src", ctx.src);
			attr_dev(img, "class", "parallax svelte-bo49fc");
			set_style(img, "transform", "translate(0, " + ctx.sy * .2 + "px)");
			add_location(img, file$5, 32, 0, 432);
			dispose = listen_dev(window, "scroll", () => {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
				ctx.onwindowscroll();
			});
		},

		m: function mount(target, anchor) {
			insert_dev(target, img, anchor);
		},

		p: function update(changed, ctx) {
			if (changed.sy && !scrolling) {
				scrolling = true;
				clearTimeout(scrolling_timeout);
				scrollTo(window.pageXOffset, ctx.sy);
				scrolling_timeout = setTimeout(clear_scrolling, 100);
			}

			if (changed.alt) {
				attr_dev(img, "alt", ctx.alt);
			}

			if (changed.src) {
				attr_dev(img, "src", ctx.src);
			}

			if (changed.sy) {
				set_style(img, "transform", "translate(0, " + ctx.sy * .2 + "px)");
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(img);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$5.name, type: "component", source: "", ctx });
	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { src, alt } = $$props;

	let sy = 0;

	const writable_props = ['src', 'alt'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ParallaxLogo> was created with unknown prop '${key}'`);
	});

	function onwindowscroll() {
		sy = window.pageYOffset; $$invalidate('sy', sy);
	}

	$$self.$set = $$props => {
		if ('src' in $$props) $$invalidate('src', src = $$props.src);
		if ('alt' in $$props) $$invalidate('alt', alt = $$props.alt);
	};

	$$self.$capture_state = () => {
		return { src, alt, sy };
	};

	$$self.$inject_state = $$props => {
		if ('src' in $$props) $$invalidate('src', src = $$props.src);
		if ('alt' in $$props) $$invalidate('alt', alt = $$props.alt);
		if ('sy' in $$props) $$invalidate('sy', sy = $$props.sy);
	};

	return { src, alt, sy, onwindowscroll };
}

class ParallaxLogo extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, ["src", "alt"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "ParallaxLogo", options, id: create_fragment$5.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.src === undefined && !('src' in props)) {
			console.warn("<ParallaxLogo> was created without expected prop 'src'");
		}
		if (ctx.alt === undefined && !('alt' in props)) {
			console.warn("<ParallaxLogo> was created without expected prop 'alt'");
		}
	}

	get src() {
		throw new Error("<ParallaxLogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set src(value) {
		throw new Error("<ParallaxLogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get alt() {
		throw new Error("<ParallaxLogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set alt(value) {
		throw new Error("<ParallaxLogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\site-kit\components\Hero.svelte generated by Svelte v3.12.0 */

const file$6 = "node_modules\\@sveltejs\\site-kit\\components\\Hero.svelte";

function create_fragment$6(ctx) {
	var t0, section, img, img_alt_value, t1, h3, t2, current;

	var parallaxlogo = new ParallaxLogo({
		props: {
		alt: "" + ctx.title + " logo",
		src: ctx.outline
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			parallaxlogo.$$.fragment.c();
			t0 = space();
			section = element("section");
			img = element("img");
			t1 = space();
			h3 = element("h3");
			t2 = text(ctx.tagline);
			this.h();
		},

		l: function claim(nodes) {
			parallaxlogo.$$.fragment.l(nodes);
			t0 = claim_space(nodes);

			section = claim_element(nodes, "SECTION", { class: true }, false);
			var section_nodes = children(section);

			img = claim_element(section_nodes, "IMG", { alt: true, class: true, src: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);

			h3 = claim_element(section_nodes, "H3", { class: true }, false);
			var h3_nodes = children(h3);

			t2 = claim_text(h3_nodes, ctx.tagline);
			h3_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(img, "alt", img_alt_value = "" + ctx.title + " logotype");
			attr_dev(img, "class", "logotype svelte-1ye6t2k");
			attr_dev(img, "src", ctx.logotype);
			add_location(img, file$6, 60, 1, 835);
			attr_dev(h3, "class", "svelte-1ye6t2k");
			add_location(h3, file$6, 61, 1, 898);
			attr_dev(section, "class", "hero svelte-1ye6t2k");
			add_location(section, file$6, 59, 0, 810);
		},

		m: function mount(target, anchor) {
			mount_component(parallaxlogo, target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, section, anchor);
			append_dev(section, img);
			append_dev(section, t1);
			append_dev(section, h3);
			append_dev(h3, t2);
			current = true;
		},

		p: function update(changed, ctx) {
			var parallaxlogo_changes = {};
			if (changed.title) parallaxlogo_changes.alt = "" + ctx.title + " logo";
			if (changed.outline) parallaxlogo_changes.src = ctx.outline;
			parallaxlogo.$set(parallaxlogo_changes);

			if ((!current || changed.title) && img_alt_value !== (img_alt_value = "" + ctx.title + " logotype")) {
				attr_dev(img, "alt", img_alt_value);
			}

			if (!current || changed.logotype) {
				attr_dev(img, "src", ctx.logotype);
			}

			if (!current || changed.tagline) {
				set_data_dev(t2, ctx.tagline);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(parallaxlogo.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(parallaxlogo.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(parallaxlogo, detaching);

			if (detaching) {
				detach_dev(t0);
				detach_dev(section);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$6.name, type: "component", source: "", ctx });
	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let { title, tagline, logotype, outline } = $$props;

	const writable_props = ['title', 'tagline', 'logotype', 'outline'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Hero> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('title' in $$props) $$invalidate('title', title = $$props.title);
		if ('tagline' in $$props) $$invalidate('tagline', tagline = $$props.tagline);
		if ('logotype' in $$props) $$invalidate('logotype', logotype = $$props.logotype);
		if ('outline' in $$props) $$invalidate('outline', outline = $$props.outline);
	};

	$$self.$capture_state = () => {
		return { title, tagline, logotype, outline };
	};

	$$self.$inject_state = $$props => {
		if ('title' in $$props) $$invalidate('title', title = $$props.title);
		if ('tagline' in $$props) $$invalidate('tagline', tagline = $$props.tagline);
		if ('logotype' in $$props) $$invalidate('logotype', logotype = $$props.logotype);
		if ('outline' in $$props) $$invalidate('outline', outline = $$props.outline);
	};

	return { title, tagline, logotype, outline };
}

class Hero extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, ["title", "tagline", "logotype", "outline"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Hero", options, id: create_fragment$6.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.title === undefined && !('title' in props)) {
			console.warn("<Hero> was created without expected prop 'title'");
		}
		if (ctx.tagline === undefined && !('tagline' in props)) {
			console.warn("<Hero> was created without expected prop 'tagline'");
		}
		if (ctx.logotype === undefined && !('logotype' in props)) {
			console.warn("<Hero> was created without expected prop 'logotype'");
		}
		if (ctx.outline === undefined && !('outline' in props)) {
			console.warn("<Hero> was created without expected prop 'outline'");
		}
	}

	get title() {
		throw new Error("<Hero>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<Hero>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get tagline() {
		throw new Error("<Hero>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set tagline(value) {
		throw new Error("<Hero>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get logotype() {
		throw new Error("<Hero>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set logotype(value) {
		throw new Error("<Hero>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get outline() {
		throw new Error("<Hero>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set outline(value) {
		throw new Error("<Hero>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\site-kit\components\Icons.svelte generated by Svelte v3.12.0 */

const file$7 = "node_modules\\@sveltejs\\site-kit\\components\\Icons.svelte";

function create_fragment$7(ctx) {
	var div, svg, symbol0, line0, polyline0, symbol1, line1, polyline1, symbol2, line2, polyline2, symbol3, line3, polyline3, symbol4, polyline4, symbol5, line4, line5, symbol6, path0, polyline5, line6, symbol7, path1, polygon, symbol8, path2, symbol9, line7, circle0, circle1, path3, symbol10, path4, polyline6, line8, symbol11, path5, symbol12, polyline7, polyline8, line9, line10, symbol13, line11, line12, line13, symbol14, path6, symbol15, line14, symbol16, line15, line16, symbol17, path7, polyline9, polyline10, symbol18, path8, path9, path10, symbol19, path11;

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			symbol0 = svg_element("symbol");
			line0 = svg_element("line");
			polyline0 = svg_element("polyline");
			symbol1 = svg_element("symbol");
			line1 = svg_element("line");
			polyline1 = svg_element("polyline");
			symbol2 = svg_element("symbol");
			line2 = svg_element("line");
			polyline2 = svg_element("polyline");
			symbol3 = svg_element("symbol");
			line3 = svg_element("line");
			polyline3 = svg_element("polyline");
			symbol4 = svg_element("symbol");
			polyline4 = svg_element("polyline");
			symbol5 = svg_element("symbol");
			line4 = svg_element("line");
			line5 = svg_element("line");
			symbol6 = svg_element("symbol");
			path0 = svg_element("path");
			polyline5 = svg_element("polyline");
			line6 = svg_element("line");
			symbol7 = svg_element("symbol");
			path1 = svg_element("path");
			polygon = svg_element("polygon");
			symbol8 = svg_element("symbol");
			path2 = svg_element("path");
			symbol9 = svg_element("symbol");
			line7 = svg_element("line");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path3 = svg_element("path");
			symbol10 = svg_element("symbol");
			path4 = svg_element("path");
			polyline6 = svg_element("polyline");
			line8 = svg_element("line");
			symbol11 = svg_element("symbol");
			path5 = svg_element("path");
			symbol12 = svg_element("symbol");
			polyline7 = svg_element("polyline");
			polyline8 = svg_element("polyline");
			line9 = svg_element("line");
			line10 = svg_element("line");
			symbol13 = svg_element("symbol");
			line11 = svg_element("line");
			line12 = svg_element("line");
			line13 = svg_element("line");
			symbol14 = svg_element("symbol");
			path6 = svg_element("path");
			symbol15 = svg_element("symbol");
			line14 = svg_element("line");
			symbol16 = svg_element("symbol");
			line15 = svg_element("line");
			line16 = svg_element("line");
			symbol17 = svg_element("symbol");
			path7 = svg_element("path");
			polyline9 = svg_element("polyline");
			polyline10 = svg_element("polyline");
			symbol18 = svg_element("symbol");
			path8 = svg_element("path");
			path9 = svg_element("path");
			path10 = svg_element("path");
			symbol19 = svg_element("symbol");
			path11 = svg_element("path");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true }, false);
			var div_nodes = children(div);

			svg = claim_element(div_nodes, "svg", {}, true);
			var svg_nodes = children(svg);

			symbol0 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol0_nodes = children(symbol0);

			line0 = claim_element(symbol0_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line0_nodes = children(line0);

			line0_nodes.forEach(detach_dev);

			polyline0 = claim_element(symbol0_nodes, "polyline", { points: true }, true);
			var polyline0_nodes = children(polyline0);

			polyline0_nodes.forEach(detach_dev);
			symbol0_nodes.forEach(detach_dev);

			symbol1 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol1_nodes = children(symbol1);

			line1 = claim_element(symbol1_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line1_nodes = children(line1);

			line1_nodes.forEach(detach_dev);

			polyline1 = claim_element(symbol1_nodes, "polyline", { points: true }, true);
			var polyline1_nodes = children(polyline1);

			polyline1_nodes.forEach(detach_dev);
			symbol1_nodes.forEach(detach_dev);

			symbol2 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol2_nodes = children(symbol2);

			line2 = claim_element(symbol2_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line2_nodes = children(line2);

			line2_nodes.forEach(detach_dev);

			polyline2 = claim_element(symbol2_nodes, "polyline", { points: true }, true);
			var polyline2_nodes = children(polyline2);

			polyline2_nodes.forEach(detach_dev);
			symbol2_nodes.forEach(detach_dev);

			symbol3 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol3_nodes = children(symbol3);

			line3 = claim_element(symbol3_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line3_nodes = children(line3);

			line3_nodes.forEach(detach_dev);

			polyline3 = claim_element(symbol3_nodes, "polyline", { points: true }, true);
			var polyline3_nodes = children(polyline3);

			polyline3_nodes.forEach(detach_dev);
			symbol3_nodes.forEach(detach_dev);

			symbol4 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol4_nodes = children(symbol4);

			polyline4 = claim_element(symbol4_nodes, "polyline", { points: true }, true);
			var polyline4_nodes = children(polyline4);

			polyline4_nodes.forEach(detach_dev);
			symbol4_nodes.forEach(detach_dev);

			symbol5 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol5_nodes = children(symbol5);

			line4 = claim_element(symbol5_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line4_nodes = children(line4);

			line4_nodes.forEach(detach_dev);

			line5 = claim_element(symbol5_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line5_nodes = children(line5);

			line5_nodes.forEach(detach_dev);
			symbol5_nodes.forEach(detach_dev);

			symbol6 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol6_nodes = children(symbol6);

			path0 = claim_element(symbol6_nodes, "path", { d: true }, true);
			var path0_nodes = children(path0);

			path0_nodes.forEach(detach_dev);

			polyline5 = claim_element(symbol6_nodes, "polyline", { points: true }, true);
			var polyline5_nodes = children(polyline5);

			polyline5_nodes.forEach(detach_dev);

			line6 = claim_element(symbol6_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line6_nodes = children(line6);

			line6_nodes.forEach(detach_dev);
			symbol6_nodes.forEach(detach_dev);

			symbol7 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol7_nodes = children(symbol7);

			path1 = claim_element(symbol7_nodes, "path", { d: true }, true);
			var path1_nodes = children(path1);

			path1_nodes.forEach(detach_dev);

			polygon = claim_element(symbol7_nodes, "polygon", { points: true }, true);
			var polygon_nodes = children(polygon);

			polygon_nodes.forEach(detach_dev);
			symbol7_nodes.forEach(detach_dev);

			symbol8 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol8_nodes = children(symbol8);

			path2 = claim_element(symbol8_nodes, "path", { d: true }, true);
			var path2_nodes = children(path2);

			path2_nodes.forEach(detach_dev);
			symbol8_nodes.forEach(detach_dev);

			symbol9 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol9_nodes = children(symbol9);

			line7 = claim_element(symbol9_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line7_nodes = children(line7);

			line7_nodes.forEach(detach_dev);

			circle0 = claim_element(symbol9_nodes, "circle", { cx: true, cy: true, r: true }, true);
			var circle0_nodes = children(circle0);

			circle0_nodes.forEach(detach_dev);

			circle1 = claim_element(symbol9_nodes, "circle", { cx: true, cy: true, r: true }, true);
			var circle1_nodes = children(circle1);

			circle1_nodes.forEach(detach_dev);

			path3 = claim_element(symbol9_nodes, "path", { d: true }, true);
			var path3_nodes = children(path3);

			path3_nodes.forEach(detach_dev);
			symbol9_nodes.forEach(detach_dev);

			symbol10 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol10_nodes = children(symbol10);

			path4 = claim_element(symbol10_nodes, "path", { d: true }, true);
			var path4_nodes = children(path4);

			path4_nodes.forEach(detach_dev);

			polyline6 = claim_element(symbol10_nodes, "polyline", { points: true }, true);
			var polyline6_nodes = children(polyline6);

			polyline6_nodes.forEach(detach_dev);

			line8 = claim_element(symbol10_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line8_nodes = children(line8);

			line8_nodes.forEach(detach_dev);
			symbol10_nodes.forEach(detach_dev);

			symbol11 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol11_nodes = children(symbol11);

			path5 = claim_element(symbol11_nodes, "path", { d: true }, true);
			var path5_nodes = children(path5);

			path5_nodes.forEach(detach_dev);
			symbol11_nodes.forEach(detach_dev);

			symbol12 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol12_nodes = children(symbol12);

			polyline7 = claim_element(symbol12_nodes, "polyline", { points: true }, true);
			var polyline7_nodes = children(polyline7);

			polyline7_nodes.forEach(detach_dev);

			polyline8 = claim_element(symbol12_nodes, "polyline", { points: true }, true);
			var polyline8_nodes = children(polyline8);

			polyline8_nodes.forEach(detach_dev);

			line9 = claim_element(symbol12_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line9_nodes = children(line9);

			line9_nodes.forEach(detach_dev);

			line10 = claim_element(symbol12_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line10_nodes = children(line10);

			line10_nodes.forEach(detach_dev);
			symbol12_nodes.forEach(detach_dev);

			symbol13 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol13_nodes = children(symbol13);

			line11 = claim_element(symbol13_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line11_nodes = children(line11);

			line11_nodes.forEach(detach_dev);

			line12 = claim_element(symbol13_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line12_nodes = children(line12);

			line12_nodes.forEach(detach_dev);

			line13 = claim_element(symbol13_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line13_nodes = children(line13);

			line13_nodes.forEach(detach_dev);
			symbol13_nodes.forEach(detach_dev);

			symbol14 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol14_nodes = children(symbol14);

			path6 = claim_element(symbol14_nodes, "path", { d: true }, true);
			var path6_nodes = children(path6);

			path6_nodes.forEach(detach_dev);
			symbol14_nodes.forEach(detach_dev);

			symbol15 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol15_nodes = children(symbol15);

			line14 = claim_element(symbol15_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line14_nodes = children(line14);

			line14_nodes.forEach(detach_dev);
			symbol15_nodes.forEach(detach_dev);

			symbol16 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol16_nodes = children(symbol16);

			line15 = claim_element(symbol16_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line15_nodes = children(line15);

			line15_nodes.forEach(detach_dev);

			line16 = claim_element(symbol16_nodes, "line", { x1: true, y1: true, x2: true, y2: true }, true);
			var line16_nodes = children(line16);

			line16_nodes.forEach(detach_dev);
			symbol16_nodes.forEach(detach_dev);

			symbol17 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol17_nodes = children(symbol17);

			path7 = claim_element(symbol17_nodes, "path", { d: true }, true);
			var path7_nodes = children(path7);

			path7_nodes.forEach(detach_dev);

			polyline9 = claim_element(symbol17_nodes, "polyline", { points: true }, true);
			var polyline9_nodes = children(polyline9);

			polyline9_nodes.forEach(detach_dev);

			polyline10 = claim_element(symbol17_nodes, "polyline", { points: true }, true);
			var polyline10_nodes = children(polyline10);

			polyline10_nodes.forEach(detach_dev);
			symbol17_nodes.forEach(detach_dev);

			symbol18 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol18_nodes = children(symbol18);

			path8 = claim_element(symbol18_nodes, "path", { d: true }, true);
			var path8_nodes = children(path8);

			path8_nodes.forEach(detach_dev);

			path9 = claim_element(symbol18_nodes, "path", { d: true }, true);
			var path9_nodes = children(path9);

			path9_nodes.forEach(detach_dev);

			path10 = claim_element(symbol18_nodes, "path", { d: true }, true);
			var path10_nodes = children(path10);

			path10_nodes.forEach(detach_dev);
			symbol18_nodes.forEach(detach_dev);

			symbol19 = claim_element(svg_nodes, "symbol", { id: true, class: true, viewBox: true }, true);
			var symbol19_nodes = children(symbol19);

			path11 = claim_element(symbol19_nodes, "path", { d: true }, true);
			var path11_nodes = children(path11);

			path11_nodes.forEach(detach_dev);
			symbol19_nodes.forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(line0, "x1", "19");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "5");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$7, 3, 3, 146);
			attr_dev(polyline0, "points", "12 19 5 12 12 5");
			add_location(polyline0, file$7, 4, 3, 190);
			attr_dev(symbol0, "id", "arrow-left");
			attr_dev(symbol0, "class", "icon");
			attr_dev(symbol0, "viewBox", "0 0 24 24");
			add_location(symbol0, file$7, 2, 2, 84);
			attr_dev(line1, "x1", "5");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "19");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$7, 8, 3, 309);
			attr_dev(polyline1, "points", "12 5 19 12 12 19");
			add_location(polyline1, file$7, 9, 3, 353);
			attr_dev(symbol1, "id", "arrow-right");
			attr_dev(symbol1, "class", "icon");
			attr_dev(symbol1, "viewBox", "0 0 24 24");
			add_location(symbol1, file$7, 7, 2, 246);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "19");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "5");
			add_location(line2, file$7, 13, 3, 470);
			attr_dev(polyline2, "points", "5 12 12 5 19 12");
			add_location(polyline2, file$7, 14, 3, 514);
			attr_dev(symbol2, "id", "arrow-up");
			attr_dev(symbol2, "class", "icon");
			attr_dev(symbol2, "viewBox", "0 0 24 24");
			add_location(symbol2, file$7, 12, 2, 410);
			attr_dev(line3, "x1", "12");
			attr_dev(line3, "y1", "5");
			attr_dev(line3, "x2", "12");
			attr_dev(line3, "y2", "19");
			add_location(line3, file$7, 18, 3, 632);
			attr_dev(polyline3, "points", "19 12 12 19 5 12");
			add_location(polyline3, file$7, 19, 3, 676);
			attr_dev(symbol3, "id", "arrow-down");
			attr_dev(symbol3, "class", "icon");
			attr_dev(symbol3, "viewBox", "0 0 24 24");
			add_location(symbol3, file$7, 17, 2, 570);
			attr_dev(polyline4, "points", "20 6 9 17 4 12");
			add_location(polyline4, file$7, 23, 3, 790);
			attr_dev(symbol4, "id", "check");
			attr_dev(symbol4, "class", "icon");
			attr_dev(symbol4, "viewBox", "0 0 24 24");
			add_location(symbol4, file$7, 22, 2, 733);
			attr_dev(line4, "x1", "18");
			attr_dev(line4, "y1", "6");
			attr_dev(line4, "x2", "6");
			attr_dev(line4, "y2", "18");
			add_location(line4, file$7, 27, 3, 902);
			attr_dev(line5, "x1", "6");
			attr_dev(line5, "y1", "6");
			attr_dev(line5, "x2", "18");
			attr_dev(line5, "y2", "18");
			add_location(line5, file$7, 28, 3, 945);
			attr_dev(symbol5, "id", "close");
			attr_dev(symbol5, "class", "icon");
			attr_dev(symbol5, "viewBox", "0 0 24 24");
			add_location(symbol5, file$7, 26, 2, 845);
			attr_dev(path0, "d", "M21 15V19A2 2 0 0 1 19 21H5A2 2 0 0 1 3 19V15");
			add_location(path0, file$7, 32, 3, 1062);
			attr_dev(polyline5, "points", "7 10 12 15 17 10");
			add_location(polyline5, file$7, 33, 3, 1125);
			attr_dev(line6, "x1", "12");
			attr_dev(line6, "y1", "15");
			attr_dev(line6, "x2", "12");
			attr_dev(line6, "y2", "3");
			add_location(line6, file$7, 34, 3, 1168);
			attr_dev(symbol6, "id", "download");
			attr_dev(symbol6, "class", "icon");
			attr_dev(symbol6, "viewBox", "0 0 24 24");
			add_location(symbol6, file$7, 31, 2, 1002);
			attr_dev(path1, "d", "M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34");
			add_location(path1, file$7, 38, 3, 1282);
			attr_dev(polygon, "points", "18 2 22 6 12 16 8 16 8 12 18 2");
			add_location(polygon, file$7, 39, 3, 1363);
			attr_dev(symbol7, "id", "edit");
			attr_dev(symbol7, "class", "icon");
			attr_dev(symbol7, "viewBox", "0 0 24 24");
			add_location(symbol7, file$7, 37, 2, 1226);
			attr_dev(path2, "d", "M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22");
			add_location(path2, file$7, 43, 3, 1491);
			attr_dev(symbol8, "id", "github");
			attr_dev(symbol8, "class", "icon");
			attr_dev(symbol8, "viewBox", "0 0 24 24");
			add_location(symbol8, file$7, 42, 2, 1433);
			attr_dev(line7, "x1", "6");
			attr_dev(line7, "y1", "3");
			attr_dev(line7, "x2", "6");
			attr_dev(line7, "y2", "15");
			add_location(line7, file$7, 47, 3, 1876);
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "6");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$7, 48, 3, 1918);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "18");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$7, 49, 3, 1954);
			attr_dev(path3, "d", "M18 9a9 9 0 0 1-9 9");
			add_location(path3, file$7, 50, 3, 1990);
			attr_dev(symbol9, "id", "git-branch");
			attr_dev(symbol9, "class", "icon");
			attr_dev(symbol9, "viewBox", "0 0 24 24");
			add_location(symbol9, file$7, 46, 2, 1814);
			attr_dev(path4, "d", "M15 3H19A2 2 0 0 1 21 5V19A2 2 0 0 1 19 21H15");
			add_location(path4, file$7, 54, 3, 2099);
			attr_dev(polyline6, "points", "10 17 15 12 10 7");
			add_location(polyline6, file$7, 55, 3, 2162);
			attr_dev(line8, "x1", "15");
			attr_dev(line8, "y1", "12");
			attr_dev(line8, "x2", "3");
			attr_dev(line8, "y2", "12");
			add_location(line8, file$7, 56, 3, 2205);
			attr_dev(symbol10, "id", "log-in");
			attr_dev(symbol10, "class", "icon");
			attr_dev(symbol10, "viewBox", "0 0 24 24");
			add_location(symbol10, file$7, 53, 2, 2041);
			attr_dev(path5, "d", "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3");
			add_location(path5, file$7, 60, 3, 2323);
			attr_dev(symbol11, "id", "maximize");
			attr_dev(symbol11, "class", "icon");
			attr_dev(symbol11, "viewBox", "0 0 24 24");
			add_location(symbol11, file$7, 59, 2, 2263);
			attr_dev(polyline7, "points", "15 3 21 3 21 9");
			add_location(polyline7, file$7, 64, 3, 2510);
			attr_dev(polyline8, "points", "9 21 3 21 3 15");
			add_location(polyline8, file$7, 65, 3, 2551);
			attr_dev(line9, "x1", "21");
			attr_dev(line9, "y1", "3");
			attr_dev(line9, "x2", "14");
			attr_dev(line9, "y2", "10");
			add_location(line9, file$7, 66, 3, 2592);
			attr_dev(line10, "x1", "3");
			attr_dev(line10, "y1", "21");
			attr_dev(line10, "x2", "10");
			attr_dev(line10, "y2", "14");
			add_location(line10, file$7, 67, 3, 2636);
			attr_dev(symbol12, "id", "maximize-2");
			attr_dev(symbol12, "class", "icon");
			attr_dev(symbol12, "viewBox", "0 0 24 24");
			add_location(symbol12, file$7, 63, 2, 2448);
			attr_dev(line11, "x1", "3");
			attr_dev(line11, "y1", "12");
			attr_dev(line11, "x2", "21");
			attr_dev(line11, "y2", "12");
			add_location(line11, file$7, 71, 3, 2750);
			attr_dev(line12, "x1", "3");
			attr_dev(line12, "y1", "6");
			attr_dev(line12, "x2", "21");
			attr_dev(line12, "y2", "6");
			add_location(line12, file$7, 72, 3, 2794);
			attr_dev(line13, "x1", "3");
			attr_dev(line13, "y1", "18");
			attr_dev(line13, "x2", "21");
			attr_dev(line13, "y2", "18");
			add_location(line13, file$7, 73, 3, 2836);
			attr_dev(symbol13, "id", "menu");
			attr_dev(symbol13, "class", "icon");
			attr_dev(symbol13, "viewBox", "0 0 24 24");
			add_location(symbol13, file$7, 70, 2, 2694);
			attr_dev(path6, "d", "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z");
			add_location(path6, file$7, 77, 3, 2960);
			attr_dev(symbol14, "id", "message-square");
			attr_dev(symbol14, "class", "icon");
			attr_dev(symbol14, "viewBox", "0 0 24 24");
			add_location(symbol14, file$7, 76, 2, 2894);
			attr_dev(line14, "x1", "5");
			attr_dev(line14, "y1", "12");
			attr_dev(line14, "x2", "19");
			attr_dev(line14, "y2", "12");
			add_location(line14, file$7, 81, 3, 3110);
			attr_dev(symbol15, "id", "minus");
			attr_dev(symbol15, "class", "icon");
			attr_dev(symbol15, "viewBox", "0 0 24 24");
			add_location(symbol15, file$7, 80, 2, 3053);
			attr_dev(line15, "x1", "12");
			attr_dev(line15, "y1", "5");
			attr_dev(line15, "x2", "12");
			attr_dev(line15, "y2", "19");
			add_location(line15, file$7, 85, 3, 3224);
			attr_dev(line16, "x1", "5");
			attr_dev(line16, "y1", "12");
			attr_dev(line16, "x2", "19");
			attr_dev(line16, "y2", "12");
			add_location(line16, file$7, 86, 3, 3268);
			attr_dev(symbol16, "id", "plus");
			attr_dev(symbol16, "class", "icon");
			attr_dev(symbol16, "viewBox", "0 0 24 24");
			add_location(symbol16, file$7, 84, 2, 3168);
			attr_dev(path7, "d", "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z");
			add_location(path7, file$7, 90, 3, 3382);
			attr_dev(polyline9, "points", "17 21 17 13 7 13 7 21");
			add_location(polyline9, file$7, 91, 3, 3463);
			attr_dev(polyline10, "points", "7 3 7 8 15 8");
			add_location(polyline10, file$7, 92, 3, 3511);
			attr_dev(symbol17, "id", "save");
			attr_dev(symbol17, "class", "icon");
			attr_dev(symbol17, "viewBox", "0 0 24 24");
			add_location(symbol17, file$7, 89, 2, 3326);
			attr_dev(path8, "d", "M9,7L6,7A2 2 0 0 0 6,17L9,17");
			add_location(path8, file$7, 96, 3, 3620);
			attr_dev(path9, "d", "M15,7L18,7A2 2 0 0 1 18,17L15,17");
			add_location(path9, file$7, 97, 3, 3665);
			attr_dev(path10, "d", "M7,12L17,12");
			add_location(path10, file$7, 98, 3, 3714);
			attr_dev(symbol18, "id", "link");
			attr_dev(symbol18, "class", "icon");
			attr_dev(symbol18, "viewBox", "0 0 24 24");
			add_location(symbol18, file$7, 95, 2, 3564);
			attr_dev(path11, "d", "M2,7 L12,17 L20,7");
			add_location(path11, file$7, 102, 3, 3815);
			attr_dev(symbol19, "id", "chevron");
			attr_dev(symbol19, "class", "icon");
			attr_dev(symbol19, "viewBox", "0 0 24 24");
			add_location(symbol19, file$7, 101, 2, 3756);
			add_location(svg, file$7, 1, 1, 75);
			set_style(div, "display", "none");
			add_location(div, file$7, 0, 0, 0);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);
			append_dev(svg, symbol0);
			append_dev(symbol0, line0);
			append_dev(symbol0, polyline0);
			append_dev(svg, symbol1);
			append_dev(symbol1, line1);
			append_dev(symbol1, polyline1);
			append_dev(svg, symbol2);
			append_dev(symbol2, line2);
			append_dev(symbol2, polyline2);
			append_dev(svg, symbol3);
			append_dev(symbol3, line3);
			append_dev(symbol3, polyline3);
			append_dev(svg, symbol4);
			append_dev(symbol4, polyline4);
			append_dev(svg, symbol5);
			append_dev(symbol5, line4);
			append_dev(symbol5, line5);
			append_dev(svg, symbol6);
			append_dev(symbol6, path0);
			append_dev(symbol6, polyline5);
			append_dev(symbol6, line6);
			append_dev(svg, symbol7);
			append_dev(symbol7, path1);
			append_dev(symbol7, polygon);
			append_dev(svg, symbol8);
			append_dev(symbol8, path2);
			append_dev(svg, symbol9);
			append_dev(symbol9, line7);
			append_dev(symbol9, circle0);
			append_dev(symbol9, circle1);
			append_dev(symbol9, path3);
			append_dev(svg, symbol10);
			append_dev(symbol10, path4);
			append_dev(symbol10, polyline6);
			append_dev(symbol10, line8);
			append_dev(svg, symbol11);
			append_dev(symbol11, path5);
			append_dev(svg, symbol12);
			append_dev(symbol12, polyline7);
			append_dev(symbol12, polyline8);
			append_dev(symbol12, line9);
			append_dev(symbol12, line10);
			append_dev(svg, symbol13);
			append_dev(symbol13, line11);
			append_dev(symbol13, line12);
			append_dev(symbol13, line13);
			append_dev(svg, symbol14);
			append_dev(symbol14, path6);
			append_dev(svg, symbol15);
			append_dev(symbol15, line14);
			append_dev(svg, symbol16);
			append_dev(symbol16, line15);
			append_dev(symbol16, line16);
			append_dev(svg, symbol17);
			append_dev(symbol17, path7);
			append_dev(symbol17, polyline9);
			append_dev(symbol17, polyline10);
			append_dev(svg, symbol18);
			append_dev(symbol18, path8);
			append_dev(symbol18, path9);
			append_dev(symbol18, path10);
			append_dev(svg, symbol19);
			append_dev(symbol19, path11);
		},

		p: noop,
		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$7.name, type: "component", source: "", ctx });
	return block;
}

class Icons extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, null, create_fragment$7, safe_not_equal, []);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Icons", options, id: create_fragment$7.name });
	}
}

/* node_modules\@sveltejs\site-kit\components\Nav.svelte generated by Svelte v3.12.0 */
const { window: window_1 } = globals;

const file$8 = "node_modules\\@sveltejs\\site-kit\\components\\Nav.svelte";

// (249:2) {#if open}
function create_if_block$1(ctx) {
	var div, dispose;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "modal-background hide-if-desktop svelte-1j1hh3q");
			add_location(div, file$8, 249, 3, 4583);
			dispose = listen_dev(div, "click", ctx.click_handler);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$1.name, type: "if", source: "(249:2) {#if open}", ctx });
	return block;
}

function create_fragment$8(ctx) {
	var header, nav, a0, t0, t1, t2, ul, li, a1, t3, t4, current_1, dispose;

	var if_block = (ctx.open) && create_if_block$1(ctx);

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			header = element("header");
			nav = element("nav");
			a0 = element("a");
			t0 = text(ctx.home);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			ul = element("ul");
			li = element("li");
			a1 = element("a");
			t3 = text(ctx.home);
			t4 = space();

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true }, false);
			var header_nodes = children(header);

			nav = claim_element(header_nodes, "NAV", { class: true }, false);
			var nav_nodes = children(nav);

			a0 = claim_element(nav_nodes, "A", { rel: true, href: true, class: true, title: true, style: true }, false);
			var a0_nodes = children(a0);

			t0 = claim_text(a0_nodes, ctx.home);
			a0_nodes.forEach(detach_dev);
			t1 = claim_space(nav_nodes);
			if (if_block) if_block.l(nav_nodes);
			t2 = claim_space(nav_nodes);

			ul = claim_element(nav_nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			li = claim_element(ul_nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			a1 = claim_element(li_nodes, "A", { rel: true, href: true, class: true }, false);
			var a1_nodes = children(a1);

			t3 = claim_text(a1_nodes, ctx.home);
			a1_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			t4 = claim_space(ul_nodes);

			if (default_slot) default_slot.l(ul_nodes);
			ul_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a0, "rel", "prefetch");
			attr_dev(a0, "href", ".");
			attr_dev(a0, "class", "home svelte-1j1hh3q");
			attr_dev(a0, "title", ctx.home_title);
			set_style(a0, "background-image", "url(" + ctx.logo + ")");
			add_location(a0, file$8, 240, 2, 4429);
			attr_dev(a1, "rel", "prefetch");
			attr_dev(a1, "href", ".");
			attr_dev(a1, "class", "svelte-1j1hh3q");
			add_location(a1, file$8, 259, 57, 4914);
			attr_dev(li, "class", "hide-if-desktop svelte-1j1hh3q");
			toggle_class(li, "active", !ctx.segment);
			add_location(li, file$8, 259, 3, 4860);

			attr_dev(ul, "class", "primary svelte-1j1hh3q");
			toggle_class(ul, "open", ctx.open);
			add_location(ul, file$8, 252, 2, 4682);
			attr_dev(nav, "class", "svelte-1j1hh3q");
			add_location(nav, file$8, 239, 1, 4420);
			attr_dev(header, "class", "svelte-1j1hh3q");
			toggle_class(header, "visible", ctx.visible || ctx.open);
			add_location(header, file$8, 238, 0, 4375);

			dispose = [
				listen_dev(window_1, "hashchange", ctx.handle_hashchange),
				listen_dev(window_1, "scroll", ctx.handle_scroll),
				listen_dev(ul, "touchstart", ctx.intercept_touchstart, true),
				listen_dev(ul, "mouseenter", ctx.mouseenter_handler),
				listen_dev(ul, "mouseleave", ctx.mouseleave_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, header, anchor);
			append_dev(header, nav);
			append_dev(nav, a0);
			append_dev(a0, t0);
			append_dev(nav, t1);
			if (if_block) if_block.m(nav, null);
			append_dev(nav, t2);
			append_dev(nav, ul);
			append_dev(ul, li);
			append_dev(li, a1);
			append_dev(a1, t3);
			append_dev(ul, t4);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			current_1 = true;
		},

		p: function update(changed, ctx) {
			if (!current_1 || changed.home) {
				set_data_dev(t0, ctx.home);
			}

			if (!current_1 || changed.home_title) {
				attr_dev(a0, "title", ctx.home_title);
			}

			if (!current_1 || changed.logo) {
				set_style(a0, "background-image", "url(" + ctx.logo + ")");
			}

			if (ctx.open) {
				if (!if_block) {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(nav, t2);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current_1 || changed.home) {
				set_data_dev(t3, ctx.home);
			}

			if (changed.segment) {
				toggle_class(li, "active", !ctx.segment);
			}

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}

			if (changed.open) {
				toggle_class(ul, "open", ctx.open);
			}

			if ((changed.visible || changed.open)) {
				toggle_class(header, "visible", ctx.visible || ctx.open);
			}
		},

		i: function intro(local) {
			if (current_1) return;
			transition_in(default_slot, local);
			current_1 = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current_1 = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(header);
			}

			if (if_block) if_block.d();

			if (default_slot) default_slot.d(detaching);
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$8.name, type: "component", source: "", ctx });
	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let $current;

	

	let { segment, page, logo, home = 'Home', home_title = 'Homepage' } = $$props;

	const current = writable(null); validate_store(current, 'current'); component_subscribe($$self, current, $$value => { $current = $$value; $$invalidate('$current', $current); });
	setContext('nav', current);

	let open = false;
	let visible = true;

	// hide nav whenever we navigate
	page.subscribe(() => {
		$$invalidate('open', open = false);
	});

	function intercept_touchstart(event) {
		if (!open) {
			event.preventDefault();
			event.stopPropagation();
			$$invalidate('open', open = true);
		}
	}

	// Prevents navbar to show/hide when clicking in docs sidebar
	let hash_changed = false;
	function handle_hashchange() {
		hash_changed = true;
	}

	let last_scroll = 0;
	function handle_scroll() {
		const scroll = window.pageYOffset;
		if (!hash_changed) {
			$$invalidate('visible', visible = (scroll < 50 || scroll < last_scroll));
		}

		last_scroll = scroll;
		hash_changed = false;
	}

	const writable_props = ['segment', 'page', 'logo', 'home', 'home_title'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Nav> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	const click_handler = () => $$invalidate('open', open = false);

	const mouseenter_handler = () => $$invalidate('open', open = true);

	const mouseleave_handler = () => $$invalidate('open', open = false);

	$$self.$set = $$props => {
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
		if ('page' in $$props) $$invalidate('page', page = $$props.page);
		if ('logo' in $$props) $$invalidate('logo', logo = $$props.logo);
		if ('home' in $$props) $$invalidate('home', home = $$props.home);
		if ('home_title' in $$props) $$invalidate('home_title', home_title = $$props.home_title);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { segment, page, logo, home, home_title, open, visible, hash_changed, last_scroll, $current };
	};

	$$self.$inject_state = $$props => {
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
		if ('page' in $$props) $$invalidate('page', page = $$props.page);
		if ('logo' in $$props) $$invalidate('logo', logo = $$props.logo);
		if ('home' in $$props) $$invalidate('home', home = $$props.home);
		if ('home_title' in $$props) $$invalidate('home_title', home_title = $$props.home_title);
		if ('open' in $$props) $$invalidate('open', open = $$props.open);
		if ('visible' in $$props) $$invalidate('visible', visible = $$props.visible);
		if ('hash_changed' in $$props) hash_changed = $$props.hash_changed;
		if ('last_scroll' in $$props) last_scroll = $$props.last_scroll;
		if ('$current' in $$props) current.set($current);
	};

	$$self.$$.update = ($$dirty = { segment: 1 }) => {
		if ($$dirty.segment) { set_store_value(current, $current = segment); }
	};

	return {
		segment,
		page,
		logo,
		home,
		home_title,
		current,
		open,
		visible,
		intercept_touchstart,
		handle_hashchange,
		handle_scroll,
		click_handler,
		mouseenter_handler,
		mouseleave_handler,
		$$slots,
		$$scope
	};
}

class Nav extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$8, safe_not_equal, ["segment", "page", "logo", "home", "home_title"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Nav", options, id: create_fragment$8.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.segment === undefined && !('segment' in props)) {
			console.warn("<Nav> was created without expected prop 'segment'");
		}
		if (ctx.page === undefined && !('page' in props)) {
			console.warn("<Nav> was created without expected prop 'page'");
		}
		if (ctx.logo === undefined && !('logo' in props)) {
			console.warn("<Nav> was created without expected prop 'logo'");
		}
	}

	get segment() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get page() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set page(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get logo() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set logo(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get home() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set home(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get home_title() {
		throw new Error("<Nav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set home_title(value) {
		throw new Error("<Nav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules\@sveltejs\site-kit\components\NavItem.svelte generated by Svelte v3.12.0 */

const file$9 = "node_modules\\@sveltejs\\site-kit\\components\\NavItem.svelte";

// (12:0) {:else}
function create_else_block(ctx) {
	var li, a, current_1;

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {}, false);
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", { rel: true, href: true }, false);
			var a_nodes = children(a);

			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "rel", "prefetch");
			attr_dev(a, "href", ctx.segment);
			add_location(a, file$9, 12, 43, 278);
			toggle_class(li, "active", ctx.$current === ctx.segment);
			add_location(li, file$9, 12, 1, 236);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current_1 = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}

			if (!current_1 || changed.segment) {
				attr_dev(a, "href", ctx.segment);
			}

			if ((changed.$current || changed.segment)) {
				toggle_class(li, "active", ctx.$current === ctx.segment);
			}
		},

		i: function intro(local) {
			if (current_1) return;
			transition_in(default_slot, local);
			current_1 = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current_1 = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(12:0) {:else}", ctx });
	return block;
}

// (10:0) {#if external}
function create_if_block$2(ctx) {
	var li, a, current_1;

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", {}, false);
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", { href: true }, false);
			var a_nodes = children(a);

			if (default_slot) default_slot.l(a_nodes);
			a_nodes.forEach(detach_dev);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "href", ctx.external);
			add_location(a, file$9, 10, 5, 183);
			add_location(li, file$9, 10, 1, 179);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current_1 = true;
		},

		p: function update(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}

			if (!current_1 || changed.external) {
				attr_dev(a, "href", ctx.external);
			}
		},

		i: function intro(local) {
			if (current_1) return;
			transition_in(default_slot, local);
			current_1 = true;
		},

		o: function outro(local) {
			transition_out(default_slot, local);
			current_1 = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$2.name, type: "if", source: "(10:0) {#if external}", ctx });
	return block;
}

function create_fragment$9(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current_1;

	var if_block_creators = [
		create_if_block$2,
		create_else_block
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.external) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current_1 = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i: function intro(local) {
			if (current_1) return;
			transition_in(if_block);
			current_1 = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current_1 = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$9.name, type: "component", source: "", ctx });
	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let $current;

	let { segment = null, external = null } = $$props;

	const current = getContext('nav'); validate_store(current, 'current'); component_subscribe($$self, current, $$value => { $current = $$value; $$invalidate('$current', $current); });

	const writable_props = ['segment', 'external'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<NavItem> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
		if ('external' in $$props) $$invalidate('external', external = $$props.external);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { segment, external, $current };
	};

	$$self.$inject_state = $$props => {
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
		if ('external' in $$props) $$invalidate('external', external = $$props.external);
		if ('$current' in $$props) current.set($current);
	};

	return {
		segment,
		external,
		current,
		$current,
		$$slots,
		$$scope
	};
}

class NavItem extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$9, safe_not_equal, ["segment", "external"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "NavItem", options, id: create_fragment$9.name });
	}

	get segment() {
		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get external() {
		throw new Error("<NavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set external(value) {
		throw new Error("<NavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Blurb as B, Docs as D, Hero as H, Icons as I, Nav as N, Section as S, NavItem as a, Icon as b, getFragment as g };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYWJmOWM2YmQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvY29tcG9uZW50cy9JY29uLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvY29tcG9uZW50cy9HdWlkZUNvbnRlbnRzLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvdXRpbHMvbmF2aWdhdGlvbi5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvY29tcG9uZW50cy9Eb2NzLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3ZlbHRlanMvc2l0ZS1raXQvY29tcG9uZW50cy9QYXJhbGxheExvZ28uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zaXRlLWtpdC9jb21wb25lbnRzL0hlcm8uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdmVsdGVqcy9zaXRlLWtpdC9jb21wb25lbnRzL05hdi5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvQHN2ZWx0ZWpzL3NpdGUta2l0L2NvbXBvbmVudHMvTmF2SXRlbS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPCEtLVxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdHN2ZyBpY29uXHJcblx0LSBodHRwczovL2dpdGh1Yi5jb20vamFjb2JtaXNjaGthL3N2ZWx0ZS1mZWF0aGVyLWljb25cclxuXHQtIGh0dHBzOi8vZmVhdGhlcmljb25zLmNvbS9cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLS0+XHJcblxyXG48c2NyaXB0PlxyXG5cdGV4cG9ydCBsZXQgbmFtZTtcclxuXHRleHBvcnQgbGV0IHNpemUgPSAyMDtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3ZnIGNsYXNzPVwiaWNvblwiIHdpZHRoPXtzaXplfSBoZWlnaHQ9e3NpemV9PlxyXG5cdDx1c2UgeGxpbms6aHJlZj0nI3tuYW1lfScgLz5cclxuPC9zdmc+XHJcblxyXG48c3R5bGU+XHJcblx0Lmljb24ge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcclxuXHRcdHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XHJcblx0XHQtby1vYmplY3QtZml0OiBjb250YWluO1xyXG5cdFx0b2JqZWN0LWZpdDogY29udGFpbjtcclxuXHRcdC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcclxuXHRcdHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XHJcblx0XHRzdHJva2U6IGN1cnJlbnRDb2xvcjtcclxuXHRcdHN0cm9rZS13aWR0aDogMjtcclxuXHRcdHN0cm9rZS1saW5lY2FwOiByb3VuZDtcclxuXHRcdHN0cm9rZS1saW5lam9pbjogcm91bmQ7XHJcblx0XHRmaWxsOiBub25lO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIiwiPHNjcmlwdD5cclxuXHRpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XHJcblx0aW1wb3J0IEljb24gZnJvbSAnLi9JY29uLnN2ZWx0ZSc7XHJcblxyXG5cdGV4cG9ydCBsZXQgc2VjdGlvbnMgPSBbXTtcclxuXHRleHBvcnQgbGV0IGFjdGl2ZV9zZWN0aW9uID0gbnVsbDtcclxuXHRleHBvcnQgbGV0IHNob3dfY29udGVudHM7XHJcblx0ZXhwb3J0IGxldCBwcmV2ZW50X3NpZGViYXJfc2Nyb2xsID0gZmFsc2U7XHJcblxyXG5cdGxldCB1bDtcclxuXHJcblx0YWZ0ZXJVcGRhdGUoKCkgPT4ge1xyXG5cdFx0Ly8gYml0IG9mIGEgaGFjayDigJTCoHByZXZlbnQgc2lkZWJhciBzY3JvbGxpbmcgaWZcclxuXHRcdC8vIFRPQyBpcyBvcGVuIG9uIG1vYmlsZSwgb3Igc2Nyb2xsIGNhbWUgZnJvbSB3aXRoaW4gc2lkZWJhclxyXG5cdFx0aWYgKHByZXZlbnRfc2lkZWJhcl9zY3JvbGwgfHwgc2hvd19jb250ZW50cyAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8IDgzMikgcmV0dXJuO1xyXG5cclxuXHRcdGNvbnN0IGFjdGl2ZSA9IHVsLnF1ZXJ5U2VsZWN0b3IoJy5hY3RpdmUnKTtcclxuXHJcblx0XHRpZiAoYWN0aXZlKSB7XHJcblx0XHRcdGNvbnN0IHsgdG9wLCBib3R0b20gfSA9IGFjdGl2ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHRcdGNvbnN0IG1pbiA9IDIwMDtcclxuXHRcdFx0Y29uc3QgbWF4ID0gd2luZG93LmlubmVySGVpZ2h0IC0gMjAwO1xyXG5cclxuXHRcdFx0aWYgKHRvcCA+IG1heCkge1xyXG5cdFx0XHRcdHVsLnBhcmVudE5vZGUuc2Nyb2xsQnkoe1xyXG5cdFx0XHRcdFx0dG9wOiB0b3AgLSBtYXgsXHJcblx0XHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdFx0YmVoYXZpb3I6ICdzbW9vdGgnXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoYm90dG9tIDwgbWluKSB7XHJcblx0XHRcdFx0dWwucGFyZW50Tm9kZS5zY3JvbGxCeSh7XHJcblx0XHRcdFx0XHR0b3A6IGJvdHRvbSAtIG1pbixcclxuXHRcdFx0XHRcdGxlZnQ6IDAsXHJcblx0XHRcdFx0XHRiZWhhdmlvcjogJ3Ntb290aCdcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQucmVmZXJlbmNlLXRvYyBsaSB7XHJcblx0XHRkaXNwbGF5OiBibG9jaztcclxuXHRcdGxpbmUtaGVpZ2h0OiAxLjI7XHJcblx0XHRtYXJnaW46IDAgMCA0cmVtIDA7XHJcblx0fVxyXG5cclxuXHRhIHtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHRcdHRyYW5zaXRpb246IGNvbG9yIDAuMnM7XHJcblx0XHRib3JkZXItYm90dG9tOiBub25lO1xyXG5cdFx0cGFkZGluZzogMDtcclxuXHRcdGNvbG9yOiB2YXIoLS1zZWNvbmQpO1xyXG5cdH1cclxuXHJcblx0LnNlY3Rpb24ge1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0XHRwYWRkaW5nOiAwIDAgLjhyZW0gMDtcclxuXHRcdGZvbnQtc2l6ZTogdmFyKC0taDYpO1xyXG5cdFx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcclxuXHRcdGxldHRlci1zcGFjaW5nOiAwLjFlbTtcclxuXHRcdGZvbnQtd2VpZ2h0OiA2MDA7XHJcblx0fVxyXG5cclxuXHQuc3Vic2VjdGlvbiB7XHJcblx0XHRkaXNwbGF5OiBibG9jaztcclxuXHRcdGZvbnQtc2l6ZTogMS42cmVtO1xyXG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQpO1xyXG5cdFx0cGFkZGluZzogMCAwIDAuNmVtIDA7XHJcblx0fVxyXG5cclxuXHQuc2VjdGlvbjpob3ZlcixcclxuXHQuc3Vic2VjdGlvbjpob3ZlcixcclxuXHQuYWN0aXZlIHtcclxuXHRcdGNvbG9yOiB2YXIoLS1mbGFzaCk7XHJcblx0fVxyXG5cclxuXHQuc3Vic2VjdGlvbltkYXRhLWxldmVsPVwiNFwiXSB7XHJcblx0XHRwYWRkaW5nLWxlZnQ6IDEuMnJlbTtcclxuXHR9XHJcblxyXG5cdC5pY29uLWNvbnRhaW5lciB7XHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHR0b3A6IC0uMnJlbTtcclxuXHRcdHJpZ2h0OiAyLjRyZW07XHJcblx0fVxyXG5cclxuXHRAbWVkaWEgKG1pbi13aWR0aDogODMycHgpIHtcclxuXHRcdGEge1xyXG5cdFx0XHRjb2xvcjogdmFyKC0tc2lkZWJhci10ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRhOmhvdmVyLFxyXG5cdFx0LnNlY3Rpb246aG92ZXIsXHJcblx0XHQuc3Vic2VjdGlvbjpob3ZlcixcclxuXHRcdC5hY3RpdmUge1xyXG5cdFx0XHRjb2xvcjogd2hpdGVcclxuXHRcdH1cclxuXHR9XHJcbjwvc3R5bGU+XHJcblxyXG48dWxcclxuXHRiaW5kOnRoaXM9e3VsfVxyXG5cdGNsYXNzPVwicmVmZXJlbmNlLXRvY1wiXHJcblx0b246bW91c2VlbnRlcj1cInsoKSA9PiBwcmV2ZW50X3NpZGViYXJfc2Nyb2xsID0gdHJ1ZX1cIlxyXG5cdG9uOm1vdXNlbGVhdmU9XCJ7KCkgPT4gcHJldmVudF9zaWRlYmFyX3Njcm9sbCA9IGZhbHNlfVwiXHJcbj5cclxuXHR7I2VhY2ggc2VjdGlvbnMgYXMgc2VjdGlvbn1cclxuXHRcdDxsaT5cclxuXHRcdFx0PGEgY2xhc3M9XCJzZWN0aW9uXCIgY2xhc3M6YWN0aXZlPVwie3NlY3Rpb24uc2x1ZyA9PT0gYWN0aXZlX3NlY3Rpb259XCIgaHJlZj1cImRvY3Mje3NlY3Rpb24uc2x1Z31cIj5cclxuXHRcdFx0XHR7QGh0bWwgc2VjdGlvbi5tZXRhZGF0YS50aXRsZX1cclxuXHJcblx0XHRcdFx0eyNpZiBzZWN0aW9uLnNsdWcgPT09IGFjdGl2ZV9zZWN0aW9ufVxyXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImljb24tY29udGFpbmVyXCI+XHJcblx0XHRcdFx0XHRcdDxJY29uIG5hbWU9XCJhcnJvdy1yaWdodFwiIC8+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHR7L2lmfVxyXG5cdFx0XHQ8L2E+XHJcblxyXG5cdFx0XHR7I2VhY2ggc2VjdGlvbi5zdWJzZWN0aW9ucyBhcyBzdWJzZWN0aW9ufVxyXG5cdFx0XHRcdDwhLS0gc2VlIDxzY3JpcHQ+IGJlbG93OiBvbjpjbGljaz0nc2Nyb2xsVG8oZXZlbnQsIHN1YnNlY3Rpb24uc2x1ZyknIC0tPlxyXG5cdFx0XHRcdDxhXHJcblx0XHRcdFx0XHRjbGFzcz1cInN1YnNlY3Rpb25cIlxyXG5cdFx0XHRcdFx0Y2xhc3M6YWN0aXZlPVwie3N1YnNlY3Rpb24uc2x1ZyA9PT0gYWN0aXZlX3NlY3Rpb259XCJcclxuXHRcdFx0XHRcdGhyZWY9XCJkb2NzI3tzdWJzZWN0aW9uLnNsdWd9XCJcclxuXHRcdFx0XHRcdGRhdGEtbGV2ZWw9XCJ7c3Vic2VjdGlvbi5sZXZlbH1cIlxyXG5cdFx0XHRcdD5cclxuXHRcdFx0XHRcdHtAaHRtbCBzdWJzZWN0aW9uLnRpdGxlfVxyXG5cclxuXHRcdFx0XHRcdHsjaWYgc3Vic2VjdGlvbi5zbHVnID09PSBhY3RpdmVfc2VjdGlvbn1cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzcz1cImljb24tY29udGFpbmVyXCI+XHJcblx0XHRcdFx0XHRcdFx0PEljb24gbmFtZT1cImFycm93LXJpZ2h0XCIgLz5cclxuXHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHR7L2lmfVxyXG5cdFx0XHRcdDwvYT5cclxuXHRcdFx0ey9lYWNofVxyXG5cdFx0PC9saT5cclxuXHR7L2VhY2h9XHJcbjwvdWw+XHJcbiIsImV4cG9ydCBjb25zdCBnZXRGcmFnbWVudCA9ICgpID0+IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpO1xyXG4iLCI8c2NyaXB0PlxyXG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xyXG5cdGltcG9ydCBHdWlkZUNvbnRlbnRzIGZyb20gJy4vR3VpZGVDb250ZW50cy5zdmVsdGUnOyAvLyBUT0RPIHJlbmFtZVxyXG5cdGltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5zdmVsdGUnO1xyXG5cdGltcG9ydCB7IGdldEZyYWdtZW50IH0gZnJvbSAnLi4vdXRpbHMvbmF2aWdhdGlvbic7XHJcblxyXG5cdGV4cG9ydCBsZXQgb3duZXIgPSAnc3ZlbHRlanMnO1xyXG5cdGV4cG9ydCBsZXQgcHJvamVjdCA9ICdzdmVsdGUnO1xyXG5cdGV4cG9ydCBsZXQgcGF0aCA9ICcvc2l0ZS9jb250ZW50JztcclxuXHRleHBvcnQgbGV0IGRpciA9ICdkb2NzJztcclxuXHRleHBvcnQgbGV0IGVkaXRfdGl0bGUgPSAnZWRpdCB0aGlzIHNlY3Rpb24nO1xyXG5cdGV4cG9ydCBsZXQgc2VjdGlvbnM7XHJcblx0bGV0IGFjdGl2ZV9zZWN0aW9uO1xyXG5cclxuXHRsZXQgY29udGFpbmVyO1xyXG5cdGxldCBhc2lkZTtcclxuXHRsZXQgc2hvd19jb250ZW50cyA9IGZhbHNlO1xyXG5cclxuXHRvbk1vdW50KCgpID0+IHtcclxuXHRcdC8vIGRvbid0IHVwZGF0ZSBgYWN0aXZlX3NlY3Rpb25gIGZvciBoZWFkaW5ncyBhYm92ZSBsZXZlbCA0LCBzZWUgX3NlY3Rpb25zLmpzXHJcblx0XHRjb25zdCBhbmNob3JzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF06bm90KFtkYXRhLXNjcm9sbGlnbm9yZV0pJyk7XHJcblxyXG5cdFx0bGV0IHBvc2l0aW9ucztcclxuXHJcblx0XHRjb25zdCBvbnJlc2l6ZSA9ICgpID0+IHtcclxuXHRcdFx0Y29uc3QgeyB0b3AgfSA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRcdFx0cG9zaXRpb25zID0gW10ubWFwLmNhbGwoYW5jaG9ycywgYW5jaG9yID0+IHtcclxuXHRcdFx0XHRyZXR1cm4gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIHRvcDtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IGxhc3RfaWQgPSBnZXRGcmFnbWVudCgpO1xyXG5cclxuXHRcdGNvbnN0IG9uc2Nyb2xsID0gKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB0b3AgPSAtd2luZG93LnNjcm9sbFk7XHJcblxyXG5cdFx0XHRsZXQgaSA9IGFuY2hvcnMubGVuZ3RoO1xyXG5cdFx0XHR3aGlsZSAoaS0tKSB7XHJcblx0XHRcdFx0aWYgKHBvc2l0aW9uc1tpXSArIHRvcCA8IDQwKSB7XHJcblx0XHRcdFx0XHRjb25zdCBhbmNob3IgPSBhbmNob3JzW2ldO1xyXG5cdFx0XHRcdFx0Y29uc3QgeyBpZCB9ID0gYW5jaG9yO1xyXG5cclxuXHRcdFx0XHRcdGlmIChpZCAhPT0gbGFzdF9pZCkge1xyXG5cdFx0XHRcdFx0XHRhY3RpdmVfc2VjdGlvbiA9IGlkO1xyXG5cdFx0XHRcdFx0XHRsYXN0X2lkID0gaWQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25zY3JvbGwsIHRydWUpO1xyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9ucmVzaXplLCB0cnVlKTtcclxuXHJcblx0XHQvLyB3YWl0IGZvciBmb250cyB0byBsb2FkLi4uXHJcblx0XHRjb25zdCB0aW1lb3V0cyA9IFtcclxuXHRcdFx0c2V0VGltZW91dChvbnJlc2l6ZSwgMTAwMCksXHJcblx0XHRcdHNldFRpbWVvdXQob25zY3JvbGwsIDUwMDApXHJcblx0XHRdO1xyXG5cclxuXHRcdG9ucmVzaXplKCk7XHJcblx0XHRvbnNjcm9sbCgpO1xyXG5cclxuXHRcdHJldHVybiAoKSA9PiB7XHJcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvbnNjcm9sbCwgdHJ1ZSk7XHJcblx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbnJlc2l6ZSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHR0aW1lb3V0cy5mb3JFYWNoKHRpbWVvdXQgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXQpKTtcclxuXHRcdH07XHJcblx0fSk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdGFzaWRlIHtcclxuXHRcdHBvc2l0aW9uOiBmaXhlZDtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG5cdFx0bGVmdDogMC44cmVtO1xyXG5cdFx0Ym90dG9tOiAwLjhyZW07XHJcblx0XHR3aWR0aDogMmVtO1xyXG5cdFx0aGVpZ2h0OiAyZW07XHJcblx0XHRvdmVyZmxvdzogaGlkZGVuO1xyXG5cdFx0Ym9yZGVyOiAxcHggc29saWQgI2VlZTtcclxuXHRcdGJveC1zaGFkb3c6IDFweCAxcHggNnB4IHJnYmEoMCwwLDAsMC4xKTtcclxuXHRcdHRyYW5zaXRpb246IHdpZHRoIDAuMnMsIGhlaWdodCAwLjJzO1xyXG5cdH1cclxuXHJcblx0YXNpZGUgYnV0dG9uIHtcclxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuXHRcdGJvdHRvbTogMDtcclxuXHRcdGxlZnQ6IDA7XHJcblx0XHR3aWR0aDogMy40cmVtO1xyXG5cdFx0aGVpZ2h0OiAzLjRyZW07XHJcblx0fVxyXG5cclxuXHRhc2lkZS5vcGVuIHtcclxuXHRcdHdpZHRoOiBjYWxjKDEwMHZ3IC0gM3JlbSk7XHJcblx0XHRoZWlnaHQ6IGNhbGMoMTAwdmggLSB2YXIoLS1uYXYtaCkpO1xyXG5cdH1cclxuXHJcblx0YXNpZGUub3Blbjo6YmVmb3JlIHtcclxuXHRcdGNvbnRlbnQ6ICcnO1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0dG9wOiAwO1xyXG5cdFx0bGVmdDogMDtcclxuXHRcdHdpZHRoOiBjYWxjKDEwMCUgLSAycmVtKTtcclxuXHRcdGhlaWdodDogMmVtO1xyXG5cdFx0YmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHRvcCwgcmdiYSgyNTUsMjU1LDI1NSwwKSAwJSwgcmdiYSgyNTUsMjU1LDI1NSwwLjcpIDUwJSwgcmdiYSgyNTUsMjU1LDI1NSwxKSAxMDAlKTtcclxuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG5cdFx0ei1pbmRleDogMjtcclxuXHR9XHJcblxyXG5cdGFzaWRlOjphZnRlciB7XHJcblx0XHRjb250ZW50OiAnJztcclxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuXHRcdGxlZnQ6IDA7XHJcblx0XHRib3R0b206IDEuOWVtO1xyXG5cdFx0d2lkdGg6IGNhbGMoMTAwJSAtIDJyZW0pO1xyXG5cdFx0aGVpZ2h0OiAyZW07XHJcblx0XHRiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKDI1NSwyNTUsMjU1LDApIDAlLCByZ2JhKDI1NSwyNTUsMjU1LDAuNykgNTAlLCByZ2JhKDI1NSwyNTUsMjU1LDEpIDEwMCUpO1xyXG5cdFx0cG9pbnRlci1ldmVudHM6IG5vbmU7XHJcblx0fVxyXG5cclxuXHQuc2lkZWJhciB7XHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHRmb250LWZhbWlseTogdmFyKC0tZm9udCk7XHJcblx0XHRvdmVyZmxvdy15OiBhdXRvO1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRwYWRkaW5nOiA0ZW0gMS42cmVtIDJlbSAzLjJyZW07XHJcblx0XHRib3R0b206IDJlbTtcclxuXHR9XHJcblxyXG5cdC5jb250ZW50IHtcclxuXHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0bWFyZ2luOiAwO1xyXG5cdFx0cGFkZGluZzogdmFyKC0tdG9wLW9mZnNldCkgdmFyKC0tc2lkZS1uYXYpO1xyXG5cdFx0dGFiLXNpemU6IDI7XHJcblx0XHQtbW96LXRhYi1zaXplOiAyO1xyXG5cdH1cclxuXHJcblx0QG1lZGlhIChtaW4td2lkdGg6IDgzMnB4KSB7IC8qIGNhbid0IHVzZSB2YXJzIGluIEBtZWRpYSA6KCAqL1xyXG5cdFx0YXNpZGUge1xyXG5cdFx0XHRkaXNwbGF5OiBibG9jaztcclxuXHRcdFx0d2lkdGg6IHZhcigtLXNpZGViYXItdyk7XHJcblx0XHRcdGhlaWdodDogMTAwdmg7XHJcblx0XHRcdHRvcDogMDtcclxuXHRcdFx0bGVmdDogMDtcclxuXHRcdFx0b3ZlcmZsb3c6IGhpZGRlbjtcclxuXHRcdFx0Ym94LXNoYWRvdzogbm9uZTtcclxuXHRcdFx0Ym9yZGVyOiBub25lO1xyXG5cdFx0XHRvdmVyZmxvdzogaGlkZGVuO1xyXG5cdFx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zZWNvbmQpO1xyXG5cdFx0XHRjb2xvcjogd2hpdGU7XHJcblx0XHR9XHJcblxyXG5cdFx0YXNpZGUub3Blbjo6YmVmb3JlIHtcclxuXHRcdFx0ZGlzcGxheTogbm9uZTtcclxuXHRcdH1cclxuXHJcblx0XHRhc2lkZTo6YWZ0ZXIge1xyXG5cdFx0XHRjb250ZW50OiAnJztcclxuXHRcdFx0Ym90dG9tOiAwO1xyXG5cdFx0XHRoZWlnaHQ6IHZhcigtLXRvcC1vZmZzZXQpO1xyXG5cdFx0XHRiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCByZ2JhKDEwMywxMDMsMTIwLDApIDAlLCByZ2JhKDEwMywxMDMsMTIwLDAuNykgNTAlLCByZ2JhKDEwMywxMDMsMTIwLDEpIDEwMCUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFzaWRlIGJ1dHRvbiB7XHJcblx0XHRcdGRpc3BsYXk6IG5vbmU7XHJcblx0XHR9XHJcblxyXG5cdFx0LnNpZGViYXIge1xyXG5cdFx0XHRwYWRkaW5nOiB2YXIoLS10b3Atb2Zmc2V0KSAwIDYuNHJlbSAzLjJyZW07XHJcblx0XHRcdGZvbnQtZmFtaWx5OiB2YXIoLS1mb250KTtcclxuXHRcdFx0b3ZlcmZsb3cteTogYXV0bztcclxuXHRcdFx0aGVpZ2h0OiAxMDAlO1xyXG5cdFx0XHRib3R0b206IGF1dG87XHJcblx0XHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC5jb250ZW50IHtcclxuXHRcdFx0cGFkZGluZy1sZWZ0OiBjYWxjKHZhcigtLXNpZGViYXItdykgKyB2YXIoLS1zaWRlLW5hdikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC5jb250ZW50IDpnbG9iYWwoLnNpZGUtYnktc2lkZSkge1xyXG5cdFx0XHRkaXNwbGF5OiBncmlkO1xyXG5cdFx0XHRncmlkLXRlbXBsYXRlLWNvbHVtbnM6IGNhbGMoNTAlIC0gMC41ZW0pIGNhbGMoNTAlIC0gMC41ZW0pO1xyXG5cdFx0XHRncmlkLWdhcDogMWVtO1xyXG5cdFx0fVxyXG5cclxuXHRcdC5jb250ZW50IDpnbG9iYWwoLnNpZGUtYnktc2lkZSkgOmdsb2JhbCguY29kZSkge1xyXG5cdFx0XHRwYWRkaW5nOiAxZW0gMDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC5jb250ZW50IGgyIHtcclxuXHRcdG1hcmdpbi10b3A6IDhyZW07XHJcblx0XHRwYWRkaW5nOiAycmVtIDEuNnJlbSA0cmVtIDAuMnJlbTtcclxuXHRcdGJvcmRlci10b3A6IHZhcigtLWJvcmRlci13KSBzb2xpZCAjNjc2Nzc4NWI7IC8qIGJhc2VkIG9uIC0tc2Vjb25kICovXHJcblx0XHRjb2xvcjogdmFyKC0tdGV4dCk7XHJcblx0XHRsaW5lLWhlaWdodDogMTtcclxuXHRcdGZvbnQtc2l6ZTogdmFyKC0taDMpO1xyXG5cdFx0bGV0dGVyLXNwYWNpbmc6IC4wNWVtO1xyXG5cdFx0dGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcclxuXHR9XHJcblxyXG5cdC5jb250ZW50IHNlY3Rpb246Zmlyc3Qtb2YtdHlwZSA+IGgyIHtcclxuXHRcdG1hcmdpbi10b3A6IDA7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCA6Z2xvYmFsKGg0KSB7XHJcblx0XHRtYXJnaW46IDJlbSAwIDFlbSAwO1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgOmdsb2JhbCgub2Zmc2V0LWFuY2hvcikge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0XHR0b3A6IGNhbGMoLTEgKiAodmFyKC0tbmF2LWgpICsgdmFyKC0tdG9wLW9mZnNldCkgLSAxcmVtKSk7XHJcblx0XHR3aWR0aDogMDtcclxuXHRcdGhlaWdodDogMDtcclxuXHR9XHJcblxyXG5cdC5jb250ZW50IDpnbG9iYWwoLmFuY2hvcikge1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0XHRiYWNrZ3JvdW5kOiB1cmwoL2ljb25zL2xpbmsuc3ZnKSAwIDUwJSBuby1yZXBlYXQ7XHJcblx0XHRiYWNrZ3JvdW5kLXNpemU6IDFlbSAxZW07XHJcblx0XHR3aWR0aDogMS40ZW07XHJcblx0XHRoZWlnaHQ6IDFlbTtcclxuXHRcdGxlZnQ6IC0xLjNlbTtcclxuXHRcdG9wYWNpdHk6IDA7XHJcblx0XHR0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnM7XHJcblx0XHRib3JkZXI6IG5vbmUgIWltcG9ydGFudDsgLyogVE9ETyBnZXQgcmlkIG9mIGxpbmtpZnkgKi9cclxuXHR9XHJcblxyXG5cdEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCkge1xyXG5cdFx0LmNvbnRlbnQgOmdsb2JhbChoMik6aG92ZXIgOmdsb2JhbCguYW5jaG9yKSxcclxuXHRcdC5jb250ZW50IDpnbG9iYWwoaDMpOmhvdmVyIDpnbG9iYWwoLmFuY2hvciksXHJcblx0XHQuY29udGVudCA6Z2xvYmFsKGg0KTpob3ZlciA6Z2xvYmFsKC5hbmNob3IpLFxyXG5cdFx0LmNvbnRlbnQgOmdsb2JhbChoNSk6aG92ZXIgOmdsb2JhbCguYW5jaG9yKSxcclxuXHRcdC5jb250ZW50IDpnbG9iYWwoaDYpOmhvdmVyIDpnbG9iYWwoLmFuY2hvcikge1xyXG5cdFx0XHRvcGFjaXR5OiAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdC5jb250ZW50IDpnbG9iYWwoaDUpIDpnbG9iYWwoLmFuY2hvciksXHJcblx0XHQuY29udGVudCA6Z2xvYmFsKGg2KSA6Z2xvYmFsKC5hbmNob3IpIHtcclxuXHRcdFx0dG9wOiAwLjJlbTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC5jb250ZW50IDpnbG9iYWwoaDMpLFxyXG5cdC5jb250ZW50IDpnbG9iYWwoaDMgPiBjb2RlKSB7XHJcblx0XHRtYXJnaW46IDYuNHJlbSAwIDAgMDtcclxuXHRcdHBhZGRpbmc6IDJyZW0gMS42cmVtIDUuNnJlbSAuMnJlbTtcclxuXHRcdGNvbG9yOiB2YXIoLS10ZXh0KTtcclxuXHRcdGJvcmRlci10b3A6IHZhcigtLWJvcmRlci13KSBzb2xpZCAjNjc2Nzc4MWY7IC8qIGJhc2VkIG9uIC0tc2Vjb25kICovXHJcblx0XHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcclxuXHRcdGxpbmUtaGVpZ2h0OiAxO1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgOmdsb2JhbChoMyk6Zmlyc3Qtb2YtdHlwZSB7XHJcblx0XHRib3JkZXI6IG5vbmU7XHJcblx0XHRtYXJnaW46IDA7XHJcblx0fVxyXG5cclxuXHQvKiBhdm9pZCBkb3VibGVkIGJvcmRlci10b3AgKi9cclxuXHQuY29udGVudCA6Z2xvYmFsKGgzID4gY29kZSkge1xyXG5cdFx0Ym9yZGVyLXJhZGl1czogMCAwIDAgMDtcclxuXHRcdGJvcmRlcjogbm9uZTtcclxuXHRcdGZvbnQtc2l6ZTogaW5oZXJpdDtcclxuXHR9XHJcblxyXG5cclxuXHQuY29udGVudCA6Z2xvYmFsKGg0KSxcclxuXHQuY29udGVudCA6Z2xvYmFsKGg0ID4gY29kZSkge1xyXG5cdFx0Zm9udC1mYW1pbHk6IGluaGVyaXQ7XHJcblx0XHRmb250LXdlaWdodDogNjAwO1xyXG5cdFx0Zm9udC1zaXplOiAyLjRyZW07XHJcblx0XHRjb2xvcjogdmFyKC0tc2Vjb25kKTtcclxuXHRcdG1hcmdpbjogNi40cmVtIDAgMS42cmVtIDA7XHJcblx0XHRwYWRkaW5nLWxlZnQ6IDA7XHJcblx0XHRiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcclxuXHRcdGxpbmUtaGVpZ2h0OiAxO1xyXG5cdFx0cGFkZGluZzogMDtcclxuXHRcdHRvcDogMDtcclxuXHR9XHJcblxyXG5cdC5jb250ZW50IDpnbG9iYWwoaDQgPiBlbSkge1xyXG5cdFx0b3BhY2l0eTogMC43O1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgOmdsb2JhbChoNSkge1xyXG5cdFx0Zm9udC1zaXplOiAyLjRyZW07XHJcblx0XHRtYXJnaW46IDJlbSAwIDAuNWVtIDA7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCA6Z2xvYmFsKGNvZGUpIHtcclxuXHRcdHBhZGRpbmc6IC4zcmVtIC44cmVtIC4zcmVtO1xyXG5cdFx0bWFyZ2luOiAwIDAuMnJlbTtcclxuXHRcdHRvcDogLS4xcmVtO1xyXG5cdFx0YmFja2dyb3VuZDogdmFyKC0tYmFjay1hcGkpO1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgOmdsb2JhbChwcmUpIDpnbG9iYWwoY29kZSkge1xyXG5cdFx0cGFkZGluZzogMDtcclxuXHRcdG1hcmdpbjogMDtcclxuXHRcdHRvcDogMDtcclxuXHRcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xyXG5cdH1cclxuXHJcblx0LmNvbnRlbnQgOmdsb2JhbChwcmUpIHtcclxuXHRcdG1hcmdpbjogMCAwIDJlbSAwO1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRtYXgtd2lkdGg6IDEwMCU7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCA6Z2xvYmFsKC5pY29uKSB7XHJcblx0XHR3aWR0aDogMnJlbTtcclxuXHRcdGhlaWdodDogMnJlbTtcclxuXHRcdHN0cm9rZTogY3VycmVudENvbG9yO1xyXG5cdFx0c3Ryb2tlLXdpZHRoOiAyO1xyXG5cdFx0c3Ryb2tlLWxpbmVjYXA6IHJvdW5kO1xyXG5cdFx0c3Ryb2tlLWxpbmVqb2luOiByb3VuZDtcclxuXHRcdGZpbGw6IG5vbmU7XHJcblx0fVxyXG5cclxuXHQuY29udGVudCA6Z2xvYmFsKHRhYmxlKSB7XHJcblx0XHRtYXJnaW46IDAgMCAyZW0gMDtcclxuXHR9XHJcblxyXG5cdHNlY3Rpb24gPiA6Z2xvYmFsKC5jb2RlLWJsb2NrKSA+IDpnbG9iYWwocHJlKSB7XHJcblx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcblx0XHQvKiBiYWNrZ3JvdW5kOiB2YXIoLS1iYWNrLWFwaSk7ICovXHJcblx0XHRjb2xvcjogd2hpdGU7XHJcblx0XHRwYWRkaW5nOiAuM3JlbSAuOHJlbTtcclxuXHRcdG1hcmdpbjogMDtcclxuXHRcdG1heC13aWR0aDogMTAwJTtcclxuXHR9XHJcblxyXG5cdHNlY3Rpb24gPiA6Z2xvYmFsKC5jb2RlLWJsb2NrKT4gOmdsb2JhbChwcmUubGFuZ3VhZ2UtbWFya3VwKSB7XHJcblx0XHRwYWRkaW5nOiAuM3JlbSAuOHJlbSAuMnJlbTtcclxuXHRcdGJhY2tncm91bmQ6IHZhcigtLWJhY2stYXBpKTtcclxuXHR9XHJcblxyXG5cdHNlY3Rpb24gPiA6Z2xvYmFsKHApIHtcclxuXHRcdG1heC13aWR0aDogdmFyKC0tbGluZW1heClcclxuXHR9XHJcblxyXG5cdHNlY3Rpb24gOmdsb2JhbChwKSB7XHJcblx0XHRtYXJnaW46IDFlbSAwO1xyXG5cdH1cclxuXHJcblx0c21hbGwge1xyXG5cdFx0Zm9udC1zaXplOiB2YXIoLS1oNSk7XHJcblx0XHRmbG9hdDogcmlnaHQ7XHJcblx0XHRwb2ludGVyLWV2ZW50czogYWxsO1xyXG5cdFx0Y29sb3I6IHZhcigtLXByaW1lKTtcclxuXHRcdGN1cnNvcjogcG9pbnRlcjtcclxuXHR9XHJcblxyXG5cdC8qIG5vIGxpbmtpZnkgb24gdGhlc2UgKi9cclxuXHRzbWFsbCBhICAgICAgICB7IGFsbDogdW5zZXQgfVxyXG5cdHNtYWxsIGE6YmVmb3JlIHsgYWxsOiB1bnNldCB9XHJcblxyXG5cdHNlY3Rpb24gOmdsb2JhbChibG9ja3F1b3RlKSB7XHJcblx0XHRjb2xvcjogaHNsKDIwNCwgMTAwJSwgNTAlKTtcclxuXHRcdGJvcmRlcjogMnB4IHNvbGlkIHZhcigtLWZsYXNoKTtcclxuXHR9XHJcblxyXG5cdHNlY3Rpb24gOmdsb2JhbChibG9ja3F1b3RlKSA6Z2xvYmFsKGNvZGUpIHtcclxuXHRcdGJhY2tncm91bmQ6IGhzbCgyMDQsIDEwMCUsIDk1JSkgIWltcG9ydGFudDtcclxuXHRcdGNvbG9yOiBoc2woMjA0LCAxMDAlLCA1MCUpO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuXHJcbjxkaXYgYmluZDp0aGlzPXtjb250YWluZXJ9IGNsYXNzPVwiY29udGVudCBsaXN0aWZ5XCI+XHJcblx0eyNlYWNoIHNlY3Rpb25zIGFzIHNlY3Rpb259XHJcblx0XHQ8c2VjdGlvbiBkYXRhLWlkPXtzZWN0aW9uLnNsdWd9PlxyXG5cdFx0XHQ8aDI+XHJcblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJvZmZzZXQtYW5jaG9yXCIgaWQ9e3NlY3Rpb24uc2x1Z30+PC9zcGFuPlxyXG5cclxuXHRcdFx0XHQ8IS0tIHN2ZWx0ZS1pZ25vcmUgYTExeS1taXNzaW5nLWNvbnRlbnQgLS0+XHJcblx0XHRcdFx0PGEgaHJlZj1cImRvY3Mje3NlY3Rpb24uc2x1Z31cIiBjbGFzcz1cImFuY2hvclwiIGFyaWEtaGlkZGVuPjwvYT5cclxuXHJcblx0XHRcdFx0e0BodG1sIHNlY3Rpb24ubWV0YWRhdGEudGl0bGV9XHJcblx0XHRcdFx0PHNtYWxsPlxyXG5cdFx0XHRcdFx0PGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS97b3duZXJ9L3twcm9qZWN0fS9lZGl0L21hc3RlcntwYXRofS97ZGlyfS97c2VjdGlvbi5maWxlfVwiIHRpdGxlPVwie2VkaXRfdGl0bGV9XCI+XHJcblx0XHRcdFx0XHRcdDxJY29uIG5hbWU9J2VkaXQnIC8+XHJcblx0XHRcdFx0XHQ8L2E+XHJcblx0XHRcdFx0PC9zbWFsbD5cclxuXHRcdFx0PC9oMj5cclxuXHJcblx0XHRcdHtAaHRtbCBzZWN0aW9uLmh0bWx9XHJcblx0XHQ8L3NlY3Rpb24+XHJcblx0ey9lYWNofVxyXG48L2Rpdj5cclxuXHJcbjxhc2lkZSBiaW5kOnRoaXM9e2FzaWRlfSBjbGFzcz1cInNpZGViYXItY29udGFpbmVyXCIgY2xhc3M6b3Blbj17c2hvd19jb250ZW50c30+XHJcblx0PGRpdiBjbGFzcz1cInNpZGViYXJcIiBvbjpjbGljaz1cInsoKSA9PiBzaG93X2NvbnRlbnRzID0gZmFsc2V9XCI+IDwhLS0gc2Nyb2xsIGNvbnRhaW5lciAtLT5cclxuXHRcdDxHdWlkZUNvbnRlbnRzIHtzZWN0aW9uc30ge2FjdGl2ZV9zZWN0aW9ufSB7c2hvd19jb250ZW50c30gLz5cclxuXHQ8L2Rpdj5cclxuXHJcblx0PGJ1dHRvbiBvbjpjbGljaz1cInsoKSA9PiBzaG93X2NvbnRlbnRzID0gIXNob3dfY29udGVudHN9XCI+XHJcblx0XHQ8SWNvbiBuYW1lPVwie3Nob3dfY29udGVudHM/ICdjbG9zZScgOiAnbWVudSd9XCIvPlxyXG5cdDwvYnV0dG9uPlxyXG48L2FzaWRlPlxyXG4iLCI8c2NyaXB0PlxyXG5cdGV4cG9ydCBsZXQgc3JjO1xyXG5cdGV4cG9ydCBsZXQgYWx0O1xyXG5cclxuXHRsZXQgc3kgPSAwO1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdmVsdGU6d2luZG93IGJpbmQ6c2Nyb2xsWT17c3l9Lz5cclxuXHJcbjxzdHlsZT5cclxuXHQucGFyYWxsYXgge1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0dG9wOiAtNHJlbTtcclxuXHRcdHJpZ2h0OiAwcmVtO1xyXG5cdFx0d2lkdGg6IDUwcmVtO1xyXG5cdFx0d2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcclxuXHRcdGRpc3BsYXk6IG5vbmU7XHJcblx0fVxyXG5cclxuXHRAbWVkaWEgKG1pbi13aWR0aDogODAwcHgpIHtcclxuXHRcdC5wYXJhbGxheCB7XHJcblx0XHRcdGRpc3BsYXk6IGJsb2NrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QG1lZGlhIChtaW4td2lkdGg6IDEyMDBweCkge1xyXG5cdFx0LnBhcmFsbGF4IHtcclxuXHRcdFx0cmlnaHQ6IGNhbGMoNTB2dyAtIDYwcmVtKTtcclxuXHRcdH1cclxuXHR9XHJcbjwvc3R5bGU+XHJcblxyXG48aW1nIHthbHR9IHtzcmN9IGNsYXNzPVwicGFyYWxsYXhcIiBzdHlsZT1cInRyYW5zZm9ybTogdHJhbnNsYXRlKDAsIHtzeSAqIC4yfXB4KVwiPiIsIjxzY3JpcHQ+XHJcblx0aW1wb3J0IFBhcmFsbGF4TG9nbyBmcm9tICcuL1BhcmFsbGF4TG9nby5zdmVsdGUnO1xyXG5cclxuXHRleHBvcnQgbGV0IHRpdGxlO1xyXG5cdGV4cG9ydCBsZXQgdGFnbGluZTtcclxuXHRleHBvcnQgbGV0IGxvZ290eXBlO1xyXG5cdGV4cG9ydCBsZXQgb3V0bGluZTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0Lmhlcm8ge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0bWFyZ2luOiAxMHJlbSBhdXRvO1xyXG5cdFx0cGFkZGluZzogMCB2YXIoLS1zaWRlLW5hdik7XHJcblx0XHRtYXgtd2lkdGg6IDEyMHJlbTtcclxuXHR9XHJcblxyXG5cdGgzIHsgY29sb3I6IHZhcigtLXRleHQpIH1cclxuXHJcblx0Lmhlcm8ge1xyXG5cdFx0bWFyZ2luOiAxMHJlbSBhdXRvO1xyXG5cdH1cclxuXHJcblx0Lmhlcm8gaDMsIC5sb2dvdHlwZSB7XHJcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XHJcblx0XHRsZWZ0OiAxLjZyZW07XHJcblx0fVxyXG5cclxuXHQuaGVybyBoMyB7XHJcblx0XHRmb250LXNpemU6IDJyZW07XHJcblx0fVxyXG5cclxuXHQubG9nb3R5cGUge1xyXG5cdFx0aGVpZ2h0OiA0cmVtO1xyXG5cdH1cclxuXHJcblx0QG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XHJcblx0XHQubG9nb3R5cGUge1xyXG5cdFx0XHRoZWlnaHQ6IDZyZW07XHJcblx0XHR9XHJcblxyXG5cdFx0Lmhlcm8gaDMge1xyXG5cdFx0XHRmb250LXNpemU6IHZhcigtLWgzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdEBtZWRpYSAobWluLXdpZHRoOiA4MDBweCkge1xyXG5cdFx0Lmhlcm8ge1xyXG5cdFx0XHRtYXJnaW46IDE1cmVtIGF1dG87XHJcblx0XHR9XHJcblxyXG5cdFx0Lmhlcm8gaDMsIC5sb2dvdHlwZSB7XHJcblx0XHRcdGxlZnQ6IDNyZW07XHJcblx0XHR9XHJcblx0fVxyXG48L3N0eWxlPlxyXG5cclxuPFBhcmFsbGF4TG9nbyBhbHQ9XCJ7dGl0bGV9IGxvZ29cIiBzcmM9e291dGxpbmV9Lz5cclxuXHJcbjxzZWN0aW9uIGNsYXNzPVwiaGVyb1wiPlxyXG5cdDxpbWcgYWx0PVwie3RpdGxlfSBsb2dvdHlwZVwiIGNsYXNzPVwibG9nb3R5cGVcIiBzcmM9e2xvZ290eXBlfT5cclxuXHQ8aDM+e3RhZ2xpbmV9PC9oMz5cclxuPC9zZWN0aW9uPiIsIjxzY3JpcHQ+XHJcblx0aW1wb3J0IHsgb25Nb3VudCwgc2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XHJcblx0aW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xyXG5cdGltcG9ydCBJY29uIGZyb20gJy4vSWNvbi5zdmVsdGUnO1xyXG5cclxuXHRleHBvcnQgbGV0IHNlZ21lbnQ7XHJcblx0ZXhwb3J0IGxldCBwYWdlO1xyXG5cdGV4cG9ydCBsZXQgbG9nbztcclxuXHRleHBvcnQgbGV0IGhvbWUgPSAnSG9tZSc7XHJcblx0ZXhwb3J0IGxldCBob21lX3RpdGxlID0gJ0hvbWVwYWdlJztcclxuXHJcblx0Y29uc3QgY3VycmVudCA9IHdyaXRhYmxlKG51bGwpO1xyXG5cdHNldENvbnRleHQoJ25hdicsIGN1cnJlbnQpO1xyXG5cclxuXHRsZXQgb3BlbiA9IGZhbHNlO1xyXG5cdGxldCB2aXNpYmxlID0gdHJ1ZTtcclxuXHJcblx0Ly8gaGlkZSBuYXYgd2hlbmV2ZXIgd2UgbmF2aWdhdGVcclxuXHRwYWdlLnN1YnNjcmliZSgoKSA9PiB7XHJcblx0XHRvcGVuID0gZmFsc2U7XHJcblx0fSk7XHJcblxyXG5cdGZ1bmN0aW9uIGludGVyY2VwdF90b3VjaHN0YXJ0KGV2ZW50KSB7XHJcblx0XHRpZiAoIW9wZW4pIHtcclxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdG9wZW4gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gUHJldmVudHMgbmF2YmFyIHRvIHNob3cvaGlkZSB3aGVuIGNsaWNraW5nIGluIGRvY3Mgc2lkZWJhclxyXG5cdGxldCBoYXNoX2NoYW5nZWQgPSBmYWxzZTtcclxuXHRmdW5jdGlvbiBoYW5kbGVfaGFzaGNoYW5nZSgpIHtcclxuXHRcdGhhc2hfY2hhbmdlZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRsZXQgbGFzdF9zY3JvbGwgPSAwO1xyXG5cdGZ1bmN0aW9uIGhhbmRsZV9zY3JvbGwoKSB7XHJcblx0XHRjb25zdCBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XHJcblx0XHRpZiAoIWhhc2hfY2hhbmdlZCkge1xyXG5cdFx0XHR2aXNpYmxlID0gKHNjcm9sbCA8IDUwIHx8IHNjcm9sbCA8IGxhc3Rfc2Nyb2xsKTtcclxuXHRcdH1cclxuXHJcblx0XHRsYXN0X3Njcm9sbCA9IHNjcm9sbDtcclxuXHRcdGhhc2hfY2hhbmdlZCA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0JDogJGN1cnJlbnQgPSBzZWdtZW50O1xyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHRoZWFkZXIge1xyXG5cdFx0cG9zaXRpb246IGZpeGVkO1xyXG5cdFx0ZGlzcGxheTogZmxleDtcclxuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcblx0XHR3aWR0aDogMTAwdnc7XHJcblx0XHRoZWlnaHQ6IHZhcigtLW5hdi1oKTtcclxuXHRcdHBhZGRpbmc6IDAgdmFyKC0tc2lkZS1uYXYpO1xyXG5cdFx0bWFyZ2luOiAwIGF1dG87XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcclxuXHRcdGJveC1zaGFkb3c6IDAgLTAuNHJlbSAwLjlyZW0gMC4ycmVtIHJnYmEoMCwwLDAsLjUpO1xyXG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQpO1xyXG5cdFx0ei1pbmRleDogMTAwO1xyXG5cdFx0dXNlci1zZWxlY3Q6IG5vbmU7XHJcblx0XHR0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLGNhbGMoLTEwMCUgLSAxcmVtKSk7XHJcblx0XHR0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycztcclxuXHR9XHJcblxyXG5cdGhlYWRlci52aXNpYmxlIHtcclxuXHRcdHRyYW5zZm9ybTogbm9uZTtcclxuXHR9XHJcblxyXG5cdG5hdiB7XHJcblx0XHRwb3NpdGlvbjogZml4ZWQ7XHJcblx0XHR0b3A6IDA7XHJcblx0XHRsZWZ0OiAwO1xyXG5cdFx0d2lkdGg6IDEwMHZ3O1xyXG5cdFx0aGVpZ2h0OiB2YXIoLS1uYXYtaCk7XHJcblx0XHRwYWRkaW5nOiAwIHZhcigtLXNpZGUtbmF2KSAwIHZhcigtLXNpZGUtbmF2KTtcclxuXHRcdGRpc3BsYXk6IGZsZXg7XHJcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xyXG5cdFx0anVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcblx0XHR0cmFuc2Zvcm06IG5vbmU7XHJcblx0XHR0cmFuc2l0aW9uOiBub25lO1xyXG5cdFx0Ym94LXNoYWRvdzogbm9uZTtcclxuXHR9XHJcblxyXG5cdC5wcmltYXJ5IHtcclxuXHRcdGxpc3Qtc3R5bGU6IG5vbmU7XHJcblx0XHRmb250LWZhbWlseTogdmFyKC0tZm9udCk7XHJcblx0XHRtYXJnaW46IDA7XHJcblx0XHRsaW5lLWhlaWdodDogMTtcclxuXHR9XHJcblxyXG5cdHVsIDpnbG9iYWwobGkpIHtcclxuXHRcdGRpc3BsYXk6IGJsb2NrO1xyXG5cdFx0ZGlzcGxheTogbm9uZTtcclxuXHR9XHJcblxyXG5cdHVsIDpnbG9iYWwobGkpLmFjdGl2ZSB7XHJcblx0XHRkaXNwbGF5OiBibG9jaztcclxuXHR9XHJcblxyXG5cdHVsIHtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHRcdHBhZGRpbmc6IDAgM3JlbSAwIDA7XHJcblx0XHRiYWNrZ3JvdW5kOiB1cmwoL2ljb25zL2NoZXZyb24uc3ZnKSBjYWxjKDEwMCUgLSAxZW0pIDAuMDVlbSBuby1yZXBlYXQ7XHJcblx0XHRiYWNrZ3JvdW5kLXNpemU6IDFlbSAxZW07XHJcblx0fVxyXG5cclxuXHR1bDo6YWZ0ZXIge1xyXG5cdFx0LyogcHJldmVudCBjbGlja3MgZnJvbSByZWdpc3RlcmluZyBpZiBuYXYgaXMgY2xvc2VkICovXHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHRjb250ZW50OiAnJztcclxuXHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0aGVpZ2h0OiAxMDAlO1xyXG5cdFx0bGVmdDogMDtcclxuXHRcdHRvcDogMDtcclxuXHR9XHJcblxyXG5cdHVsLm9wZW4ge1xyXG5cdFx0cGFkZGluZzogMCAwIDFlbSAwO1xyXG5cdFx0YmFja2dyb3VuZDogd2hpdGU7XHJcblx0XHRib3JkZXItbGVmdDogMXB4IHNvbGlkICNlZWU7XHJcblx0XHRib3JkZXItcmlnaHQ6IDFweCBzb2xpZCAjZWVlO1xyXG5cdFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlZWU7XHJcblx0XHRib3JkZXItcmFkaXVzOiAwIDAgdmFyKC0tYm9yZGVyLXIpIHZhcigtLWJvcmRlci1yKTtcclxuXHRcdGFsaWduLXNlbGY6IHN0YXJ0O1xyXG5cdH1cclxuXHJcblx0dWwub3BlbiA6Z2xvYmFsKGxpKSB7XHJcblx0XHRkaXNwbGF5OiBibG9jaztcclxuXHRcdHRleHQtYWxpZ246IHJpZ2h0XHJcblx0fVxyXG5cclxuXHR1bC5vcGVuOjphZnRlciB7XHJcblx0XHRkaXNwbGF5OiBub25lO1xyXG5cdH1cclxuXHJcblx0dWwgOmdsb2JhbChsaSkgOmdsb2JhbChhKSB7XHJcblx0XHRmb250LXNpemU6IHZhcigtLWg1KTtcclxuXHRcdHBhZGRpbmc6IDAgLjhyZW07XHJcblx0XHRib3JkZXI6IG5vbmU7XHJcblx0XHRjb2xvcjogaW5oZXJpdDtcclxuXHR9XHJcblxyXG5cdHVsLm9wZW4gOmdsb2JhbChsaSkgOmdsb2JhbChhKSB7XHJcblx0XHRwYWRkaW5nOiAxLjVyZW0gMy43cmVtIDEuNXJlbSA0cmVtO1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0fVxyXG5cclxuXHR1bC5vcGVuIDpnbG9iYWwobGkpOmZpcnN0LWNoaWxkIDpnbG9iYWwoYSkge1xyXG5cdFx0cGFkZGluZy10b3A6IDIuM3JlbTtcclxuXHR9XHJcblxyXG5cdC5wcmltYXJ5IDpnbG9iYWwoc3ZnKSB7XHJcblx0XHR3aWR0aDogMnJlbTtcclxuXHRcdGhlaWdodDogMnJlbTtcclxuXHR9XHJcblxyXG5cdC5ob21lIHtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHRcdHRvcDogLS4xcmVtO1xyXG5cdFx0d2lkdGg6IDE4cmVtO1xyXG5cdFx0aGVpZ2h0OiA0LjJyZW07XHJcblx0XHQtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xyXG5cdFx0LXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xyXG5cdFx0YmFja2dyb3VuZDogMCA1MCUgbm8tcmVwZWF0O1xyXG5cdFx0YmFja2dyb3VuZC1zaXplOiBhdXRvIDEwMCU7XHJcblx0XHR0ZXh0LWluZGVudDogLTk5OTlweDtcclxuXHRcdC8qIHotaW5kZXg6IDExOyAqL1xyXG5cdH1cclxuXHJcblx0dWwgOmdsb2JhbChsaSkuYWN0aXZlIDpnbG9iYWwoYSkge1xyXG5cdFx0Y29sb3I6IHZhcigtLXByaW1lKVxyXG5cdH1cclxuXHJcblx0Lm1vZGFsLWJhY2tncm91bmQge1xyXG5cdFx0cG9zaXRpb246IGZpeGVkO1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRsZWZ0OiAwO1xyXG5cdFx0dG9wOiAwO1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xyXG5cdH1cclxuXHJcblx0YSB7XHJcblx0XHRjb2xvcjogaW5oZXJpdDtcclxuXHRcdGJvcmRlci1ib3R0b206IG5vbmU7XHJcblx0XHR0cmFuc2l0aW9uOiBub25lO1xyXG5cdH1cclxuXHJcblx0dWwgOmdsb2JhbChsaSk6bm90KC5hY3RpdmUpIDpnbG9iYWwoYSk6aG92ZXIge1xyXG5cdFx0Y29sb3I6IHZhcigtLWZsYXNoKTtcclxuXHR9XHJcblxyXG5cdEBtZWRpYSAobWluLXdpZHRoOiA4NDBweCkge1xyXG5cdFx0dWwge1xyXG5cdFx0XHRwYWRkaW5nOiAwO1xyXG5cdFx0XHRiYWNrZ3JvdW5kOiBub25lO1xyXG5cdFx0fVxyXG5cclxuXHRcdHVsLm9wZW4ge1xyXG5cdFx0XHRwYWRkaW5nOiAwO1xyXG5cdFx0XHRiYWNrZ3JvdW5kOiB3aGl0ZTtcclxuXHRcdFx0Ym9yZGVyOiBub25lO1xyXG5cdFx0XHRhbGlnbi1zZWxmOiBpbml0aWFsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHVsLm9wZW4gOmdsb2JhbChsaSkge1xyXG5cdFx0XHRkaXNwbGF5OiBpbmxpbmU7XHJcblx0XHRcdHRleHQtYWxpZ246IGxlZnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dWwub3BlbiA6Z2xvYmFsKGxpKSA6Z2xvYmFsKGEpIHtcclxuXHRcdFx0Zm9udC1zaXplOiB2YXIoLS1oNSk7XHJcblx0XHRcdHBhZGRpbmc6IDAgLjhyZW07XHJcblx0XHRcdGRpc3BsYXk6IGlubGluZTtcclxuXHRcdH1cclxuXHJcblx0XHR1bDo6YWZ0ZXIge1xyXG5cdFx0XHRkaXNwbGF5OiBub25lO1xyXG5cdFx0fVxyXG5cclxuXHRcdHVsIDpnbG9iYWwobGkpIHtcclxuXHRcdFx0ZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0LmhpZGUtaWYtZGVza3RvcCB7XHJcblx0XHRcdGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcclxuXHRcdH1cclxuXHR9XHJcbjwvc3R5bGU+XHJcblxyXG48c3ZlbHRlOndpbmRvdyBvbjpoYXNoY2hhbmdlPXtoYW5kbGVfaGFzaGNoYW5nZX0gb246c2Nyb2xsPXtoYW5kbGVfc2Nyb2xsfSAvPlxyXG5cclxuPGhlYWRlciBjbGFzczp2aXNpYmxlPVwie3Zpc2libGUgfHwgb3Blbn1cIj5cclxuXHQ8bmF2PlxyXG5cdFx0PGFcclxuXHRcdFx0cmVsPVwicHJlZmV0Y2hcIlxyXG5cdFx0XHRocmVmPVwiLlwiXHJcblx0XHRcdGNsYXNzPVwiaG9tZVwiXHJcblx0XHRcdHRpdGxlPVwie2hvbWVfdGl0bGV9XCJcclxuXHRcdFx0c3R5bGU9XCJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoe2xvZ299KVwiXHJcblx0XHQ+e2hvbWV9PC9hPlxyXG5cclxuXHRcdHsjaWYgb3Blbn1cclxuXHRcdFx0PGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tncm91bmQgaGlkZS1pZi1kZXNrdG9wXCIgb246Y2xpY2s9XCJ7KCkgPT4gb3BlbiA9IGZhbHNlfVwiPjwvZGl2PlxyXG5cdFx0ey9pZn1cclxuXHJcblx0XHQ8dWxcclxuXHRcdFx0Y2xhc3M9XCJwcmltYXJ5XCJcclxuXHRcdFx0Y2xhc3M6b3BlblxyXG5cdFx0XHRvbjp0b3VjaHN0YXJ0fGNhcHR1cmU9e2ludGVyY2VwdF90b3VjaHN0YXJ0fVxyXG5cdFx0XHRvbjptb3VzZWVudGVyPVwieygpID0+IG9wZW4gPSB0cnVlfVwiXHJcblx0XHRcdG9uOm1vdXNlbGVhdmU9XCJ7KCkgPT4gb3BlbiA9IGZhbHNlfVwiXHJcblx0XHQ+XHJcblx0XHRcdDxsaSBjbGFzcz1cImhpZGUtaWYtZGVza3RvcFwiIGNsYXNzOmFjdGl2ZT1cInshc2VnbWVudH1cIj48YSByZWw9XCJwcmVmZXRjaFwiIGhyZWY9XCIuXCI+e2hvbWV9PC9hPjwvbGk+XHJcblx0XHRcdDxzbG90Pjwvc2xvdD5cclxuXHRcdDwvdWw+XHJcblx0PC9uYXY+XHJcbjwvaGVhZGVyPlxyXG4iLCI8c2NyaXB0PlxyXG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xyXG5cclxuXHRleHBvcnQgbGV0IHNlZ21lbnQgPSBudWxsO1xyXG5cdGV4cG9ydCBsZXQgZXh0ZXJuYWwgPSBudWxsO1xyXG5cclxuXHRjb25zdCBjdXJyZW50ID0gZ2V0Q29udGV4dCgnbmF2Jyk7XHJcbjwvc2NyaXB0PlxyXG5cclxueyNpZiBleHRlcm5hbH1cclxuXHQ8bGk+PGEgaHJlZj17ZXh0ZXJuYWx9PjxzbG90Pjwvc2xvdD48L2E+PC9saT5cclxuezplbHNlfVxyXG5cdDxsaSBjbGFzczphY3RpdmU9XCJ7JGN1cnJlbnQgPT09IHNlZ21lbnR9XCI+PGEgcmVsPVwicHJlZmV0Y2hcIiBocmVmPXtzZWdtZW50fT48c2xvdD48L3Nsb3Q+PC9hPjwvbGk+XHJcbnsvaWZ9XHJcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrRUFjb0IsSUFBSTs7OzhCQURDLElBQUk7K0JBQVUsSUFBSTs7Ozs7Ozs7OztvRkFDdkIsSUFBSTs7Ozs7K0JBREMsSUFBSTtnQ0FBVSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FKbkMsTUFBSSxJQUFJLEVBQ0osSUFBSSxHQUFHLGNBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQ3NIVixVQUFVLENBQUMsS0FBSzs7cUJBRWxCLFVBQVUsQ0FBQyxJQUFJLFNBQUssY0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0RBTDNCLFVBQVUsQ0FBQyxJQUFJ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
