import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, o as onMount, e as element, c as claim_element, a as children, b as detach_dev, f as attr_dev, g as set_style, h as add_location, j as insert_dev, k as append_dev, l as space, m as empty, p as claim_space, n as noop, q as create_slot, v as validate_store, r as component_subscribe, t as setContext, u as set_store_value, w as mount_component, x as transition_in, y as transition_out, z as destroy_component, A as group_outros, B as check_outros, C as get_slot_changes, D as get_slot_context, E as text, F as claim_text, G as globals, H as set_data_dev, I as assign, J as get_spread_update, K as get_spread_object, L as getContext } from './index.4e52d202.js';
import { w as writable } from './index.ad9ca859.js';
import { I as Icons, N as Nav, a as NavItem, b as Icon } from './index.abf9c6bd.js';

const CONTEXT_KEY = {};

const preload = () => ({});

/* src\components\PreloadingIndicator.svelte generated by Svelte v3.12.0 */

const file = "src\\components\\PreloadingIndicator.svelte";

// (55:0) {#if visible}
function create_if_block_1(ctx) {
	var div1, div0;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			div0 = claim_element(div1_nodes, "DIV", { class: true, style: true }, false);
			var div0_nodes = children(div0);

			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div0, "class", "progress svelte-3253v6");
			set_style(div0, "width", "" + ctx.p * 100 + "%");
			add_location(div0, file, 56, 2, 894);
			attr_dev(div1, "class", "progress-container svelte-3253v6");
			add_location(div1, file, 55, 1, 858);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, div0);
		},

		p: function update(changed, ctx) {
			if (changed.p) {
				set_style(div0, "width", "" + ctx.p * 100 + "%");
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(55:0) {#if visible}", ctx });
	return block;
}

// (61:0) {#if p >= 0.4}
function create_if_block(ctx) {
	var div;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "fade svelte-3253v6");
			add_location(div, file, 61, 1, 985);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(61:0) {#if p >= 0.4}", ctx });
	return block;
}

function create_fragment(ctx) {
	var t, if_block1_anchor;

	var if_block0 = (ctx.visible) && create_if_block_1(ctx);

	var if_block1 = (ctx.p >= 0.4) && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (ctx.visible) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.p >= 0.4) {
				if (!if_block1) {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);

			if (detaching) {
				detach_dev(t);
			}

			if (if_block1) if_block1.d(detaching);

			if (detaching) {
				detach_dev(if_block1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function instance($$self, $$props, $$invalidate) {
	let p = 0;
	let visible = false;

	onMount(() => {
		function next() {
			$$invalidate('visible', visible = true);
			$$invalidate('p', p += 0.1);

			const remaining = 1 - p;
			if (remaining > 0.15) setTimeout(next, 500 / remaining);
		}

		setTimeout(next, 250);
	});

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ('p' in $$props) $$invalidate('p', p = $$props.p);
		if ('visible' in $$props) $$invalidate('visible', visible = $$props.visible);
	};

	return { p, visible };
}

class PreloadingIndicator extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, []);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "PreloadingIndicator", options, id: create_fragment.name });
	}
}

/* src\routes\_layout.svelte generated by Svelte v3.12.0 */

const file$1 = "src\\routes\\_layout.svelte";

// (34:0) {#if $preloading}
function create_if_block_1$1(ctx) {
	var current;

	var preloadingindicator = new PreloadingIndicator({ $$inline: true });

	const block = {
		c: function create() {
			preloadingindicator.$$.fragment.c();
		},

		l: function claim(nodes) {
			preloadingindicator.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(preloadingindicator, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(preloadingindicator.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(preloadingindicator.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(preloadingindicator, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$1.name, type: "if", source: "(34:0) {#if $preloading}", ctx });
	return block;
}

// (38:0) {#if $page.path !== '/repl/embed'}
function create_if_block$1(ctx) {
	var current;

	var nav = new Nav({
		props: {
		segment: ctx.segment,
		page: ctx.page,
		logo: "svelte-logo-horizontal.svg",
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			nav.$$.fragment.c();
		},

		l: function claim(nodes) {
			nav.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(nav, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var nav_changes = {};
			if (changed.segment) nav_changes.segment = ctx.segment;
			if (changed.$$scope) nav_changes.$$scope = { changed, ctx };
			nav.$set(nav_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(nav.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(nav.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(nav, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$1.name, type: "if", source: "(38:0) {#if $page.path !== '/repl/embed'}", ctx });
	return block;
}

// (40:2) <NavItem segment="tutorial">
function create_default_slot_9(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("教程");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "教程");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_9.name, type: "slot", source: "(40:2) <NavItem segment=\"tutorial\">", ctx });
	return block;
}

// (41:2) <NavItem segment="docs">
function create_default_slot_8(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("API");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "API");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_8.name, type: "slot", source: "(41:2) <NavItem segment=\"docs\">", ctx });
	return block;
}

// (42:2) <NavItem segment="examples">
function create_default_slot_7(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("实例");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "实例");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_7.name, type: "slot", source: "(42:2) <NavItem segment=\"examples\">", ctx });
	return block;
}

// (43:2) <NavItem segment="repl">
function create_default_slot_6(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("REPL");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "REPL");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_6.name, type: "slot", source: "(43:2) <NavItem segment=\"repl\">", ctx });
	return block;
}

// (44:2) <NavItem segment="blog">
function create_default_slot_5(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("博客");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "博客");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_5.name, type: "slot", source: "(44:2) <NavItem segment=\"blog\">", ctx });
	return block;
}

// (45:2) <NavItem segment="faq">
function create_default_slot_4(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("常见问题");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "常见问题");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_4.name, type: "slot", source: "(45:2) <NavItem segment=\"faq\">", ctx });
	return block;
}

// (47:2) <NavItem external="https://sapper.svelte.dev">
function create_default_slot_3(ctx) {
	var t;

	const block = {
		c: function create() {
			t = text("Sapper");
		},

		l: function claim(nodes) {
			t = claim_text(nodes, "Sapper");
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_3.name, type: "slot", source: "(47:2) <NavItem external=\"https://sapper.svelte.dev\">", ctx });
	return block;
}

// (49:2) <NavItem external="chat" title="Discord Chat">
function create_default_slot_2(ctx) {
	var current;

	var icon = new Icon({
		props: { name: "message-square" },
		$$inline: true
	});

	const block = {
		c: function create() {
			icon.$$.fragment.c();
		},

		l: function claim(nodes) {
			icon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_2.name, type: "slot", source: "(49:2) <NavItem external=\"chat\" title=\"Discord Chat\">", ctx });
	return block;
}

// (53:2) <NavItem external="https://github.com/sveltejs/svelte" title="GitHub Repo">
function create_default_slot_1(ctx) {
	var current;

	var icon = new Icon({
		props: { name: "github" },
		$$inline: true
	});

	const block = {
		c: function create() {
			icon.$$.fragment.c();
		},

		l: function claim(nodes) {
			icon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},

		p: noop,

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_1.name, type: "slot", source: "(53:2) <NavItem external=\"https://github.com/sveltejs/svelte\" title=\"GitHub Repo\">", ctx });
	return block;
}

// (39:1) <Nav {segment} {page} logo="svelte-logo-horizontal.svg">
function create_default_slot(ctx) {
	var t0, t1, t2, t3, t4, t5, t6, t7, current;

	var navitem0 = new NavItem({
		props: {
		segment: "tutorial",
		$$slots: { default: [create_default_slot_9] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var navitem1 = new NavItem({
		props: {
		segment: "docs",
		$$slots: { default: [create_default_slot_8] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var navitem2 = new NavItem({
		props: {
		segment: "examples",
		$$slots: { default: [create_default_slot_7] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var navitem3 = new NavItem({
		props: {
		segment: "repl",
		$$slots: { default: [create_default_slot_6] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var navitem4 = new NavItem({
		props: {
		segment: "blog",
		$$slots: { default: [create_default_slot_5] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var navitem5 = new NavItem({
		props: {
		segment: "faq",
		$$slots: { default: [create_default_slot_4] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var navitem6 = new NavItem({
		props: {
		external: "https://sapper.svelte.dev",
		$$slots: { default: [create_default_slot_3] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var navitem7 = new NavItem({
		props: {
		external: "chat",
		title: "Discord Chat",
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	var navitem8 = new NavItem({
		props: {
		external: "https://github.com/sveltejs/svelte",
		title: "GitHub Repo",
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	},
		$$inline: true
	});

	const block = {
		c: function create() {
			navitem0.$$.fragment.c();
			t0 = space();
			navitem1.$$.fragment.c();
			t1 = space();
			navitem2.$$.fragment.c();
			t2 = space();
			navitem3.$$.fragment.c();
			t3 = space();
			navitem4.$$.fragment.c();
			t4 = space();
			navitem5.$$.fragment.c();
			t5 = space();
			navitem6.$$.fragment.c();
			t6 = space();
			navitem7.$$.fragment.c();
			t7 = space();
			navitem8.$$.fragment.c();
		},

		l: function claim(nodes) {
			navitem0.$$.fragment.l(nodes);
			t0 = claim_space(nodes);
			navitem1.$$.fragment.l(nodes);
			t1 = claim_space(nodes);
			navitem2.$$.fragment.l(nodes);
			t2 = claim_space(nodes);
			navitem3.$$.fragment.l(nodes);
			t3 = claim_space(nodes);
			navitem4.$$.fragment.l(nodes);
			t4 = claim_space(nodes);
			navitem5.$$.fragment.l(nodes);
			t5 = claim_space(nodes);
			navitem6.$$.fragment.l(nodes);
			t6 = claim_space(nodes);
			navitem7.$$.fragment.l(nodes);
			t7 = claim_space(nodes);
			navitem8.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(navitem0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(navitem1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(navitem2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(navitem3, target, anchor);
			insert_dev(target, t3, anchor);
			mount_component(navitem4, target, anchor);
			insert_dev(target, t4, anchor);
			mount_component(navitem5, target, anchor);
			insert_dev(target, t5, anchor);
			mount_component(navitem6, target, anchor);
			insert_dev(target, t6, anchor);
			mount_component(navitem7, target, anchor);
			insert_dev(target, t7, anchor);
			mount_component(navitem8, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var navitem0_changes = {};
			if (changed.$$scope) navitem0_changes.$$scope = { changed, ctx };
			navitem0.$set(navitem0_changes);

			var navitem1_changes = {};
			if (changed.$$scope) navitem1_changes.$$scope = { changed, ctx };
			navitem1.$set(navitem1_changes);

			var navitem2_changes = {};
			if (changed.$$scope) navitem2_changes.$$scope = { changed, ctx };
			navitem2.$set(navitem2_changes);

			var navitem3_changes = {};
			if (changed.$$scope) navitem3_changes.$$scope = { changed, ctx };
			navitem3.$set(navitem3_changes);

			var navitem4_changes = {};
			if (changed.$$scope) navitem4_changes.$$scope = { changed, ctx };
			navitem4.$set(navitem4_changes);

			var navitem5_changes = {};
			if (changed.$$scope) navitem5_changes.$$scope = { changed, ctx };
			navitem5.$set(navitem5_changes);

			var navitem6_changes = {};
			if (changed.$$scope) navitem6_changes.$$scope = { changed, ctx };
			navitem6.$set(navitem6_changes);

			var navitem7_changes = {};
			if (changed.$$scope) navitem7_changes.$$scope = { changed, ctx };
			navitem7.$set(navitem7_changes);

			var navitem8_changes = {};
			if (changed.$$scope) navitem8_changes.$$scope = { changed, ctx };
			navitem8.$set(navitem8_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(navitem0.$$.fragment, local);

			transition_in(navitem1.$$.fragment, local);

			transition_in(navitem2.$$.fragment, local);

			transition_in(navitem3.$$.fragment, local);

			transition_in(navitem4.$$.fragment, local);

			transition_in(navitem5.$$.fragment, local);

			transition_in(navitem6.$$.fragment, local);

			transition_in(navitem7.$$.fragment, local);

			transition_in(navitem8.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(navitem0.$$.fragment, local);
			transition_out(navitem1.$$.fragment, local);
			transition_out(navitem2.$$.fragment, local);
			transition_out(navitem3.$$.fragment, local);
			transition_out(navitem4.$$.fragment, local);
			transition_out(navitem5.$$.fragment, local);
			transition_out(navitem6.$$.fragment, local);
			transition_out(navitem7.$$.fragment, local);
			transition_out(navitem8.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(navitem0, detaching);

			if (detaching) {
				detach_dev(t0);
			}

			destroy_component(navitem1, detaching);

			if (detaching) {
				detach_dev(t1);
			}

			destroy_component(navitem2, detaching);

			if (detaching) {
				detach_dev(t2);
			}

			destroy_component(navitem3, detaching);

			if (detaching) {
				detach_dev(t3);
			}

			destroy_component(navitem4, detaching);

			if (detaching) {
				detach_dev(t4);
			}

			destroy_component(navitem5, detaching);

			if (detaching) {
				detach_dev(t5);
			}

			destroy_component(navitem6, detaching);

			if (detaching) {
				detach_dev(t6);
			}

			destroy_component(navitem7, detaching);

			if (detaching) {
				detach_dev(t7);
			}

			destroy_component(navitem8, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot.name, type: "slot", source: "(39:1) <Nav {segment} {page} logo=\"svelte-logo-horizontal.svg\">", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var t0, t1, t2, main, current;

	var icons = new Icons({ $$inline: true });

	var if_block0 = (ctx.$preloading) && create_if_block_1$1(ctx);

	var if_block1 = (ctx.$page.path !== '/repl/embed') && create_if_block$1(ctx);

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, null);

	const block = {
		c: function create() {
			icons.$$.fragment.c();
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			main = element("main");

			if (default_slot) default_slot.c();
			this.h();
		},

		l: function claim(nodes) {
			icons.$$.fragment.l(nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t2 = claim_space(nodes);

			main = claim_element(nodes, "MAIN", { class: true }, false);
			var main_nodes = children(main);

			if (default_slot) default_slot.l(main_nodes);
			main_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(main, "class", "svelte-hxszvy");
			add_location(main, file$1, 58, 0, 1549);
		},

		m: function mount(target, anchor) {
			mount_component(icons, target, anchor);
			insert_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_dev(target, t2, anchor);
			insert_dev(target, main, anchor);

			if (default_slot) {
				default_slot.m(main, null);
			}

			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.$preloading) {
				if (!if_block0) {
					if_block0 = create_if_block_1$1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				} else transition_in(if_block0, 1);
			} else if (if_block0) {
				group_outros();
				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});
				check_outros();
			}

			if (ctx.$page.path !== '/repl/embed') {
				if (if_block1) {
					if_block1.p(changed, ctx);
					transition_in(if_block1, 1);
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(t2.parentNode, t2);
				}
			} else if (if_block1) {
				group_outros();
				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});
				check_outros();
			}

			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, null),
					get_slot_context(default_slot_template, ctx, null)
				);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icons.$$.fragment, local);

			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			current = true;
		},

		o: function outro(local) {
			transition_out(icons.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icons, detaching);

			if (detaching) {
				detach_dev(t0);
			}

			if (if_block0) if_block0.d(detaching);

			if (detaching) {
				detach_dev(t1);
			}

			if (if_block1) if_block1.d(detaching);

			if (detaching) {
				detach_dev(t2);
				detach_dev(main);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let $session, $preloading, $page;

	

	let { segment } = $$props;

	const { page, preloading, session } = stores$1(); validate_store(page, 'page'); component_subscribe($$self, page, $$value => { $page = $$value; $$invalidate('$page', $page); }); validate_store(preloading, 'preloading'); component_subscribe($$self, preloading, $$value => { $preloading = $$value; $$invalidate('$preloading', $preloading); }); validate_store(session, 'session'); component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

	setContext('app', {
		login: () => {
			const login_window = window.open(`${window.location.origin}/auth/login`, 'login', 'width=600,height=400');

			window.addEventListener('message', function handler(event) {
				login_window.close();
				window.removeEventListener('message', handler);
				set_store_value(session, $session.user = event.data.user, $session);
			});
		},

		logout: async () => {
			const r = await fetch(`/auth/logout`, {
				credentials: 'include'
			});

			if (r.ok) set_store_value(session, $session.user = null, $session);
		}
	});

	const writable_props = ['segment'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Layout> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => {
		return { segment, $session, $preloading, $page };
	};

	$$self.$inject_state = $$props => {
		if ('segment' in $$props) $$invalidate('segment', segment = $$props.segment);
		if ('$session' in $$props) session.set($session);
		if ('$preloading' in $$props) preloading.set($preloading);
		if ('$page' in $$props) page.set($page);
	};

	return {
		segment,
		page,
		preloading,
		session,
		$preloading,
		$page,
		$$slots,
		$$scope
	};
}

class Layout extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["segment"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Layout", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.segment === undefined && !('segment' in props)) {
			console.warn("<Layout> was created without expected prop 'segment'");
		}
	}

	get segment() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\_error.svelte generated by Svelte v3.12.0 */
const { Error: Error_1 } = globals;

const file$2 = "src\\routes\\_error.svelte";

// (66:1) {:else}
function create_else_block_2(ctx) {
	var h1, t0, t1, p, t2;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("It looks like you're offline");
			t1 = space();
			p = element("p");
			t2 = text("Reload the page once you've found the internet.");
			this.h();
		},

		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t0 = claim_text(h1_nodes, "It looks like you're offline");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t2 = claim_text(p_nodes, "Reload the page once you've found the internet.");
			p_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(h1, "class", "svelte-lk6uuh");
			add_location(h1, file$2, 66, 2, 1419);
			attr_dev(p, "class", "svelte-lk6uuh");
			add_location(p, file$2, 68, 2, 1462);
		},

		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t2);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(h1);
				detach_dev(t1);
				detach_dev(p);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block_2.name, type: "else", source: "(66:1) {:else}", ctx });
	return block;
}

// (48:1) {#if online}
function create_if_block$2(ctx) {
	var h1, t0, t1, t2, if_block1_anchor;

	function select_block_type_1(changed, ctx) {
		if (ctx.error.message) return create_if_block_3;
		return create_else_block_1;
	}

	var current_block_type = select_block_type_1(null, ctx);
	var if_block0 = current_block_type(ctx);

	function select_block_type_2(changed, ctx) {
		if (ctx.dev && ctx.error.stack) return create_if_block_1$2;
		return create_else_block;
	}

	var current_block_type_1 = select_block_type_2(null, ctx);
	var if_block1 = current_block_type_1(ctx);

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Yikes!");
			t1 = space();
			if_block0.c();
			t2 = space();
			if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t0 = claim_text(h1_nodes, "Yikes!");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if_block0.l(nodes);
			t2 = claim_space(nodes);
			if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr_dev(h1, "class", "svelte-lk6uuh");
			add_location(h1, file$2, 48, 2, 894);
		},

		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			if_block0.m(target, anchor);
			insert_dev(target, t2, anchor);
			if_block1.m(target, anchor);
			insert_dev(target, if_block1_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if (current_block_type === (current_block_type = select_block_type_1(changed, ctx)) && if_block0) {
				if_block0.p(changed, ctx);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);
				if (if_block0) {
					if_block0.c();
					if_block0.m(t2.parentNode, t2);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(changed, ctx)) && if_block1) {
				if_block1.p(changed, ctx);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);
				if (if_block1) {
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(h1);
				detach_dev(t1);
			}

			if_block0.d(detaching);

			if (detaching) {
				detach_dev(t2);
			}

			if_block1.d(detaching);

			if (detaching) {
				detach_dev(if_block1_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$2.name, type: "if", source: "(48:1) {#if online}", ctx });
	return block;
}

// (53:2) {:else}
function create_else_block_1(ctx) {
	var p, t0, t1, t2;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Encountered a ");
			t1 = text(ctx.status);
			t2 = text(" error");
			this.h();
		},

		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t0 = claim_text(p_nodes, "Encountered a ");
			t1 = claim_text(p_nodes, ctx.status);
			t2 = claim_text(p_nodes, " error");
			p_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(p, "class", "error svelte-lk6uuh");
			add_location(p, file$2, 53, 3, 1001);
		},

		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
			append_dev(p, t2);
		},

		p: function update(changed, ctx) {
			if (changed.status) {
				set_data_dev(t1, ctx.status);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(p);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block_1.name, type: "else", source: "(53:2) {:else}", ctx });
	return block;
}

// (51:2) {#if error.message}
function create_if_block_3(ctx) {
	var p, t0, t1, t2_value = ctx.error.message + "", t2;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text(ctx.status);
			t1 = text(": ");
			t2 = text(t2_value);
			this.h();
		},

		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t0 = claim_text(p_nodes, ctx.status);
			t1 = claim_text(p_nodes, ": ");
			t2 = claim_text(p_nodes, t2_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(p, "class", "error svelte-lk6uuh");
			add_location(p, file$2, 51, 3, 939);
		},

		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, t1);
			append_dev(p, t2);
		},

		p: function update(changed, ctx) {
			if (changed.status) {
				set_data_dev(t0, ctx.status);
			}

			if ((changed.error) && t2_value !== (t2_value = ctx.error.message + "")) {
				set_data_dev(t2, t2_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(p);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_3.name, type: "if", source: "(51:2) {#if error.message}", ctx });
	return block;
}

// (59:2) {:else}
function create_else_block(ctx) {
	var t0, p, t1, a0, t2, t3, a1, t4, t5;

	var if_block = (ctx.status >= 500) && create_if_block_2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			t0 = space();
			p = element("p");
			t1 = text("If the error persists, please drop by ");
			a0 = element("a");
			t2 = text("Discord chatroom");
			t3 = text(" and let us know, or raise an issue on ");
			a1 = element("a");
			t4 = text("GitHub");
			t5 = text(". Thanks!");
			this.h();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			t0 = claim_space(nodes);

			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t1 = claim_text(p_nodes, "If the error persists, please drop by ");

			a0 = claim_element(p_nodes, "A", { href: true }, false);
			var a0_nodes = children(a0);

			t2 = claim_text(a0_nodes, "Discord chatroom");
			a0_nodes.forEach(detach_dev);
			t3 = claim_text(p_nodes, " and let us know, or raise an issue on ");

			a1 = claim_element(p_nodes, "A", { href: true }, false);
			var a1_nodes = children(a1);

			t4 = claim_text(a1_nodes, "GitHub");
			a1_nodes.forEach(detach_dev);
			t5 = claim_text(p_nodes, ". Thanks!");
			p_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a0, "href", "chat");
			add_location(a0, file$2, 63, 44, 1254);
			attr_dev(a1, "href", "https://github.com/sveltejs/svelte");
			add_location(a1, file$2, 63, 118, 1328);
			attr_dev(p, "class", "svelte-lk6uuh");
			add_location(p, file$2, 63, 3, 1213);
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, t0, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t1);
			append_dev(p, a0);
			append_dev(a0, t2);
			append_dev(p, t3);
			append_dev(p, a1);
			append_dev(a1, t4);
			append_dev(p, t5);
		},

		p: function update(changed, ctx) {
			if (ctx.status >= 500) {
				if (!if_block) {
					if_block = create_if_block_2(ctx);
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach_dev(t0);
				detach_dev(p);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(59:2) {:else}", ctx });
	return block;
}

// (57:2) {#if dev && error.stack}
function create_if_block_1$2(ctx) {
	var pre, t_value = ctx.error.stack + "", t;

	const block = {
		c: function create() {
			pre = element("pre");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			pre = claim_element(nodes, "PRE", {}, false);
			var pre_nodes = children(pre);

			t = claim_text(pre_nodes, t_value);
			pre_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			add_location(pre, file$2, 57, 3, 1094);
		},

		m: function mount(target, anchor) {
			insert_dev(target, pre, anchor);
			append_dev(pre, t);
		},

		p: function update(changed, ctx) {
			if ((changed.error) && t_value !== (t_value = ctx.error.stack + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(pre);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$2.name, type: "if", source: "(57:2) {#if dev && error.stack}", ctx });
	return block;
}

// (60:3) {#if status >= 500}
function create_if_block_2(ctx) {
	var p, t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Please try reloading the page.");
			this.h();
		},

		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true }, false);
			var p_nodes = children(p);

			t = claim_text(p_nodes, "Please try reloading the page.");
			p_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(p, "class", "svelte-lk6uuh");
			add_location(p, file$2, 60, 4, 1159);
		},

		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(p);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(60:3) {#if status >= 500}", ctx });
	return block;
}

function create_fragment$2(ctx) {
	var title_value, t, div;

	document.title = title_value = ctx.status;

	function select_block_type(changed, ctx) {
		if (ctx.online) return create_if_block$2;
		return create_else_block_2;
	}

	var current_block_type = select_block_type(null, ctx);
	var if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			t = space();
			div = element("div");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);

			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "container svelte-lk6uuh");
			add_location(div, file$2, 46, 0, 852);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);
			if_block.m(div, null);
		},

		p: function update(changed, ctx) {
			if ((changed.status) && title_value !== (title_value = ctx.status)) {
				document.title = title_value;
			}

			if_block.p(changed, ctx);
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(div);
			}

			if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$2.name, type: "component", source: "", ctx });
	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	const dev = "development" === 'development';

	let { status, error } = $$props;

	// we don't want to use <svelte:window bind:online> here,
	// because we only care about the online state when
	// the page first loads
	const online = typeof navigator !== 'undefined'
		? navigator.onLine
		: true;

	const writable_props = ['status', 'error'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Error> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
	};

	$$self.$capture_state = () => {
		return { status, error };
	};

	$$self.$inject_state = $$props => {
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
	};

	return { dev, status, error, online };
}

class Error$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["status", "error"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Error", options, id: create_fragment$2.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.status === undefined && !('status' in props)) {
			console.warn("<Error> was created without expected prop 'status'");
		}
		if (ctx.error === undefined && !('error' in props)) {
			console.warn("<Error> was created without expected prop 'error'");
		}
	}

	get status() {
		throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error_1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error_1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\node_modules\@sapper\internal\App.svelte generated by Svelte v3.12.0 */
const { Error: Error_1$1 } = globals;

// (22:1) {:else}
function create_else_block$1(ctx) {
	var switch_instance_anchor, current;

	var switch_instance_spread_levels = [
		{ segment: ctx.segments[1] },
		ctx.level1.props
	];

	var switch_value = ctx.level1.component;

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot_1$1] },
			$$scope: { ctx }
		};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}
		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) switch_instance.$$.fragment.c();
			switch_instance_anchor = empty();
		},

		l: function claim(nodes) {
			if (switch_instance) switch_instance.$$.fragment.l(nodes);
			switch_instance_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var switch_instance_changes = (changed.segments || changed.level1) ? get_spread_update(switch_instance_spread_levels, [
									(changed.segments) && { segment: ctx.segments[1] },
			(changed.level1) && get_spread_object(ctx.level1.props)
								]) : {};
			if (changed.$$scope || changed.level2) switch_instance_changes.$$scope = { changed, ctx };

			if (switch_value !== (switch_value = ctx.level1.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block$1.name, type: "else", source: "(22:1) {:else}", ctx });
	return block;
}

// (20:1) {#if error}
function create_if_block$3(ctx) {
	var current;

	var error_1 = new Error$1({
		props: { error: ctx.error, status: ctx.status },
		$$inline: true
	});

	const block = {
		c: function create() {
			error_1.$$.fragment.c();
		},

		l: function claim(nodes) {
			error_1.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(error_1, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var error_1_changes = {};
			if (changed.error) error_1_changes.error = ctx.error;
			if (changed.status) error_1_changes.status = ctx.status;
			error_1.$set(error_1_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(error_1.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(error_1.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(error_1, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$3.name, type: "if", source: "(20:1) {#if error}", ctx });
	return block;
}

// (24:3) {#if level2}
function create_if_block_1$3(ctx) {
	var switch_instance_anchor, current;

	var switch_instance_spread_levels = [
		ctx.level2.props
	];

	var switch_value = ctx.level2.component;

	function switch_props(ctx) {
		let switch_instance_props = {};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}
		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) switch_instance.$$.fragment.c();
			switch_instance_anchor = empty();
		},

		l: function claim(nodes) {
			if (switch_instance) switch_instance.$$.fragment.l(nodes);
			switch_instance_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert_dev(target, switch_instance_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var switch_instance_changes = (changed.level2) ? get_spread_update(switch_instance_spread_levels, [
									get_spread_object(ctx.level2.props)
								]) : {};

			if (switch_value !== (switch_value = ctx.level2.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());

					switch_instance.$$.fragment.c();
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$3.name, type: "if", source: "(24:3) {#if level2}", ctx });
	return block;
}

// (23:2) <svelte:component this="{level1.component}" segment="{segments[1]}" {...level1.props}>
function create_default_slot_1$1(ctx) {
	var if_block_anchor, current;

	var if_block = (ctx.level2) && create_if_block_1$3(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			if (ctx.level2) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block_1$3(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot_1$1.name, type: "slot", source: "(23:2) <svelte:component this=\"{level1.component}\" segment=\"{segments[1]}\" {...level1.props}>", ctx });
	return block;
}

// (19:0) <Layout segment="{segments[0]}" {...level0.props}>
function create_default_slot$1(ctx) {
	var current_block_type_index, if_block, if_block_anchor, current;

	var if_block_creators = [
		create_if_block$3,
		create_else_block$1
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.error) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},

		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},

		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(changed, ctx);
			} else {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block = if_blocks[current_block_type_index];
				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}
				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_default_slot$1.name, type: "slot", source: "(19:0) <Layout segment=\"{segments[0]}\" {...level0.props}>", ctx });
	return block;
}

function create_fragment$3(ctx) {
	var current;

	var layout_spread_levels = [
		{ segment: ctx.segments[0] },
		ctx.level0.props
	];

	let layout_props = {
		$$slots: { default: [create_default_slot$1] },
		$$scope: { ctx }
	};
	for (var i = 0; i < layout_spread_levels.length; i += 1) {
		layout_props = assign(layout_props, layout_spread_levels[i]);
	}
	var layout = new Layout({ props: layout_props, $$inline: true });

	const block = {
		c: function create() {
			layout.$$.fragment.c();
		},

		l: function claim(nodes) {
			layout.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(layout, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var layout_changes = (changed.segments || changed.level0) ? get_spread_update(layout_spread_levels, [
									(changed.segments) && { segment: ctx.segments[0] },
			(changed.level0) && get_spread_object(ctx.level0.props)
								]) : {};
			if (changed.$$scope || changed.error || changed.status || changed.level1 || changed.segments || changed.level2) layout_changes.$$scope = { changed, ctx };
			layout.$set(layout_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(layout.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(layout.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(layout, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$3.name, type: "component", source: "", ctx });
	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	

	let { stores, error, status, segments, level0, level1 = null, level2 = null } = $$props;

	setContext(CONTEXT_KEY, stores);

	const writable_props = ['stores', 'error', 'status', 'segments', 'level0', 'level1', 'level2'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<App> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('stores' in $$props) $$invalidate('stores', stores = $$props.stores);
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('segments' in $$props) $$invalidate('segments', segments = $$props.segments);
		if ('level0' in $$props) $$invalidate('level0', level0 = $$props.level0);
		if ('level1' in $$props) $$invalidate('level1', level1 = $$props.level1);
		if ('level2' in $$props) $$invalidate('level2', level2 = $$props.level2);
	};

	$$self.$capture_state = () => {
		return { stores, error, status, segments, level0, level1, level2 };
	};

	$$self.$inject_state = $$props => {
		if ('stores' in $$props) $$invalidate('stores', stores = $$props.stores);
		if ('error' in $$props) $$invalidate('error', error = $$props.error);
		if ('status' in $$props) $$invalidate('status', status = $$props.status);
		if ('segments' in $$props) $$invalidate('segments', segments = $$props.segments);
		if ('level0' in $$props) $$invalidate('level0', level0 = $$props.level0);
		if ('level1' in $$props) $$invalidate('level1', level1 = $$props.level1);
		if ('level2' in $$props) $$invalidate('level2', level2 = $$props.level2);
	};

	return {
		stores,
		error,
		status,
		segments,
		level0,
		level1,
		level2
	};
}

class App extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["stores", "error", "status", "segments", "level0", "level1", "level2"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "App", options, id: create_fragment$3.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.stores === undefined && !('stores' in props)) {
			console.warn("<App> was created without expected prop 'stores'");
		}
		if (ctx.error === undefined && !('error' in props)) {
			console.warn("<App> was created without expected prop 'error'");
		}
		if (ctx.status === undefined && !('status' in props)) {
			console.warn("<App> was created without expected prop 'status'");
		}
		if (ctx.segments === undefined && !('segments' in props)) {
			console.warn("<App> was created without expected prop 'segments'");
		}
		if (ctx.level0 === undefined && !('level0' in props)) {
			console.warn("<App> was created without expected prop 'level0'");
		}
	}

	get stores() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stores(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get error() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set error(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get status() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set status(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get segments() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segments(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level0() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level0(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level1() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level1(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get level2() {
		throw new Error_1$1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set level2(value) {
		throw new Error_1$1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

// This file is generated by Sapper — do not edit it!

const ignore = [/^\/examples.json$/, /^\/examples\/([^\/]+?).json$/, /^\/tutorial.json$/, /^\/tutorial\/random-number\/?$/, /^\/tutorial\/([^\/]+?).json$/, /^\/apps.json$/, /^\/auth\/callback\/?$/, /^\/auth\/logout\/?$/, /^\/auth\/login\/?$/, /^\/blog.json$/, /^\/blog\/rss.xml$/, /^\/blog\/([^\/]+?).json$/, /^\/chat\/?$/, /^\/docs.json$/, /^\/repl\/create.json$/, /^\/repl\/local\/(.+)$/, /^\/repl\/([^\/]+?).json$/, /^\/faq\/?$/];

const components = [
	{
		js: () => import('./index.eb8baedd.js'),
		css: ["index.eb8baedd.css","index.abf9c6bd.css","Repl.f1ddc62a.css","InputOutputToggle.cf9a1ce1.css","ReplWidget.9e27fb73.css"]
	},
	{
		js: () => import('./index.faa917b5.js'),
		css: ["index.faa917b5.css","app.623f0ee4.css","index.abf9c6bd.css","Repl.f1ddc62a.css","config.582076a5.css"]
	},
	{
		js: () => import('./_layout.48078c70.js'),
		css: []
	},
	{
		js: () => import('./index.a179c623.js'),
		css: []
	},
	{
		js: () => import('./index.62206069.js'),
		css: ["index.62206069.css","app.623f0ee4.css","index.abf9c6bd.css","Repl.f1ddc62a.css","config.582076a5.css"]
	},
	{
		js: () => import('./index.82abdbd2.js'),
		css: ["index.82abdbd2.css"]
	},
	{
		js: () => import('./index.c311bf42.js'),
		css: ["index.c311bf42.css"]
	},
	{
		js: () => import('./[slug].82163464.js'),
		css: ["[slug].82163464.css"]
	},
	{
		js: () => import('./index.7c138582.js'),
		css: ["index.abf9c6bd.css"]
	},
	{
		js: () => import('./index.e6fda4a1.js'),
		css: []
	},
	{
		js: () => import('./embed.e83d46bf.js'),
		css: ["embed.e83d46bf.css","Repl.f1ddc62a.css","InputOutputToggle.cf9a1ce1.css","ReplWidget.9e27fb73.css"]
	},
	{
		js: () => import('./index.79f9b8bb.js'),
		css: ["index.79f9b8bb.css","app.623f0ee4.css","index.abf9c6bd.css","Repl.f1ddc62a.css","InputOutputToggle.cf9a1ce1.css"]
	}
];

const routes = (d => [
	{
		// index.svelte
		pattern: /^\/$/,
		parts: [
			{ i: 0 }
		]
	},

	{
		// examples/index.svelte
		pattern: /^\/examples\/?$/,
		parts: [
			{ i: 1 }
		]
	},

	{
		// tutorial/index.svelte
		pattern: /^\/tutorial\/?$/,
		parts: [
			{ i: 2 },
			{ i: 3 }
		]
	},

	{
		// tutorial/[slug]/index.svelte
		pattern: /^\/tutorial\/([^\/]+?)\/?$/,
		parts: [
			{ i: 2 },
			{ i: 4, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// apps/index.svelte
		pattern: /^\/apps\/?$/,
		parts: [
			{ i: 5 }
		]
	},

	{
		// blog/index.svelte
		pattern: /^\/blog\/?$/,
		parts: [
			{ i: 6 }
		]
	},

	{
		// blog/[slug].svelte
		pattern: /^\/blog\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 7, params: match => ({ slug: d(match[1]) }) }
		]
	},

	{
		// docs/index.svelte
		pattern: /^\/docs\/?$/,
		parts: [
			{ i: 8 }
		]
	},

	{
		// repl/index.svelte
		pattern: /^\/repl\/?$/,
		parts: [
			{ i: 9 }
		]
	},

	{
		// repl/embed.svelte
		pattern: /^\/repl\/embed\/?$/,
		parts: [
			null,
			{ i: 10 }
		]
	},

	{
		// repl/[id]/index.svelte
		pattern: /^\/repl\/([^\/]+?)\/?$/,
		parts: [
			null,
			{ i: 11, params: match => ({ id: d(match[1]) }) }
		]
	}
])(decodeURIComponent);

if (typeof window !== 'undefined') {
	import('./sapper-dev-client.ce2664ff.js').then(client => {
		client.connect(10000);
	});
}

function goto(href, opts = { replaceState: false }) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		_history[opts.replaceState ? 'replaceState' : 'pushState']({ id: cid }, '', href);
		return navigate(target, null).then(() => {});
	}

	location.href = href;
	return new Promise(f => {}); // never resolves
}

const initial_data = typeof __SAPPER__ !== 'undefined' && __SAPPER__;

let ready = false;
let root_component;
let current_token;
let root_preloaded;
let current_branch = [];
let current_query = '{}';

const stores = {
	page: writable({}),
	preloading: writable(null),
	session: writable(initial_data && initial_data.session)
};

let $session;
let session_dirty;

stores.session.subscribe(async value => {
	$session = value;

	if (!ready) return;
	session_dirty = true;

	const target = select_target(new URL(location.href));

	const token = current_token = {};
	const { redirect, props, branch } = await hydrate_target(target);
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
});

let prefetching


 = null;
function set_prefetching(href, promise) {
	prefetching = { href, promise };
}

let target;
function set_target(element) {
	target = element;
}

let uid = 1;
function set_uid(n) {
	uid = n;
}

let cid;
function set_cid(n) {
	cid = n;
}

const _history = typeof history !== 'undefined' ? history : {
	pushState: (state, title, href) => {},
	replaceState: (state, title, href) => {},
	scrollRestoration: ''
};

const scroll_history = {};

function extract_query(search) {
	const query = Object.create(null);
	if (search.length > 0) {
		search.slice(1).split('&').forEach(searchParam => {
			let [, key, value = ''] = /([^=]*)(?:=(.*))?/.exec(decodeURIComponent(searchParam.replace(/\+/g, ' ')));
			if (typeof query[key] === 'string') query[key] = [query[key]];
			if (typeof query[key] === 'object') (query[key] ).push(value);
			else query[key] = value;
		});
	}
	return query;
}

function select_target(url) {
	if (url.origin !== location.origin) return null;
	if (!url.pathname.startsWith(initial_data.baseUrl)) return null;

	let path = url.pathname.slice(initial_data.baseUrl.length);

	if (path === '') {
		path = '/';
	}

	// avoid accidental clashes between server routes and page routes
	if (ignore.some(pattern => pattern.test(path))) return;

	for (let i = 0; i < routes.length; i += 1) {
		const route = routes[i];

		const match = route.pattern.exec(path);

		if (match) {
			const query = extract_query(url.search);
			const part = route.parts[route.parts.length - 1];
			const params = part.params ? part.params(match) : {};

			const page = { host: location.host, path, query, params };

			return { href: url.href, route, match, page };
		}
	}
}

function handle_error(url) {
	const { host, pathname, search } = location;
	const { session, preloaded, status, error } = initial_data;

	if (!root_preloaded) {
		root_preloaded = preloaded && preloaded[0];
	}

	const props = {
		error,
		status,
		session,
		level0: {
			props: root_preloaded
		},
		level1: {
			props: {
				status,
				error
			},
			component: Error$1
		},
		segments: preloaded

	};
	const query = extract_query(search);
	render(null, [], props, { host, path: pathname, query, params: {} });
}

function scroll_state() {
	return {
		x: pageXOffset,
		y: pageYOffset
	};
}

async function navigate(target, id, noscroll, hash) {
	if (id) {
		// popstate or initial navigation
		cid = id;
	} else {
		const current_scroll = scroll_state();

		// clicked on a link. preserve scroll state
		scroll_history[cid] = current_scroll;

		id = cid = ++uid;
		scroll_history[cid] = noscroll ? current_scroll : { x: 0, y: 0 };
	}

	cid = id;

	if (root_component) stores.preloading.set(true);

	const loaded = prefetching && prefetching.href === target.href ?
		prefetching.promise :
		hydrate_target(target);

	prefetching = null;

	const token = current_token = {};
	const { redirect, props, branch } = await loaded;
	if (token !== current_token) return; // a secondary navigation happened while we were loading

	await render(redirect, branch, props, target.page);
	if (document.activeElement) document.activeElement.blur();

	if (!noscroll) {
		let scroll = scroll_history[id];

		if (hash) {
			// scroll is an element id (from a hash), we need to compute y.
			const deep_linked = document.getElementById(hash.slice(1));

			if (deep_linked) {
				scroll = {
					x: 0,
					y: deep_linked.getBoundingClientRect().top
				};
			}
		}

		scroll_history[cid] = scroll;
		if (scroll) scrollTo(scroll.x, scroll.y);
	}
}

async function render(redirect, branch, props, page) {
	if (redirect) return goto(redirect.location, { replaceState: true });

	stores.page.set(page);
	stores.preloading.set(false);

	if (root_component) {
		root_component.$set(props);
	} else {
		props.stores = {
			page: { subscribe: stores.page.subscribe },
			preloading: { subscribe: stores.preloading.subscribe },
			session: stores.session
		};
		props.level0 = {
			props: await root_preloaded
		};

		// first load — remove SSR'd <head> contents
		const start = document.querySelector('#sapper-head-start');
		const end = document.querySelector('#sapper-head-end');

		if (start && end) {
			while (start.nextSibling !== end) detach(start.nextSibling);
			detach(start);
			detach(end);
		}

		root_component = new App({
			target,
			props,
			hydrate: true
		});
	}

	current_branch = branch;
	current_query = JSON.stringify(page.query);
	ready = true;
	session_dirty = false;
}

function part_changed(i, segment, match, stringified_query) {
	// TODO only check query string changes for preload functions
	// that do in fact depend on it (using static analysis or
	// runtime instrumentation)
	if (stringified_query !== current_query) return true;

	const previous = current_branch[i];

	if (!previous) return false;
	if (segment !== previous.segment) return true;
	if (previous.match) {
		if (JSON.stringify(previous.match.slice(1, i + 2)) !== JSON.stringify(match.slice(1, i + 2))) {
			return true;
		}
	}
}

async function hydrate_target(target)



 {
	const { route, page } = target;
	const segments = page.path.split('/').filter(Boolean);

	let redirect = null;

	const props = { error: null, status: 200, segments: [segments[0]] };

	const preload_context = {
		fetch: (url, opts) => fetch(url, opts),
		redirect: (statusCode, location) => {
			if (redirect && (redirect.statusCode !== statusCode || redirect.location !== location)) {
				throw new Error(`Conflicting redirects`);
			}
			redirect = { statusCode, location };
		},
		error: (status, error) => {
			props.error = typeof error === 'string' ? new Error(error) : error;
			props.status = status;
		}
	};

	if (!root_preloaded) {
		root_preloaded = initial_data.preloaded[0] || preload.call(preload_context, {
			host: page.host,
			path: page.path,
			query: page.query,
			params: {}
		}, $session);
	}

	let branch;
	let l = 1;

	try {
		const stringified_query = JSON.stringify(page.query);
		const match = route.pattern.exec(page.path);

		let segment_dirty = false;

		branch = await Promise.all(route.parts.map(async (part, i) => {
			const segment = segments[i];

			if (part_changed(i, segment, match, stringified_query)) segment_dirty = true;

			props.segments[l] = segments[i + 1]; // TODO make this less confusing
			if (!part) return { segment };

			const j = l++;

			if (!session_dirty && !segment_dirty && current_branch[i] && current_branch[i].part === part.i) {
				return current_branch[i];
			}

			segment_dirty = false;

			const { default: component, preload } = await load_component(components[part.i]);

			let preloaded;
			if (ready || !initial_data.preloaded[i + 1]) {
				preloaded = preload
					? await preload.call(preload_context, {
						host: page.host,
						path: page.path,
						query: page.query,
						params: part.params ? part.params(target.match) : {}
					}, $session)
					: {};
			} else {
				preloaded = initial_data.preloaded[i + 1];
			}

			return (props[`level${j}`] = { component, props: preloaded, segment, match, part: part.i });
		}));
	} catch (error) {
		props.error = error;
		props.status = 500;
		branch = [];
	}

	return { redirect, props, branch };
}

function load_css(chunk) {
	const href = `client/${chunk}`;
	if (document.querySelector(`link[href="${href}"]`)) return;

	return new Promise((fulfil, reject) => {
		const link = document.createElement('link');
		link.rel = 'stylesheet';
		link.href = href;

		link.onload = () => fulfil();
		link.onerror = reject;

		document.head.appendChild(link);
	});
}

function load_component(component)


 {
	// TODO this is temporary — once placeholders are
	// always rewritten, scratch the ternary
	const promises = (typeof component.css === 'string' ? [] : component.css.map(load_css));
	promises.unshift(component.js());
	return Promise.all(promises).then(values => values[0]);
}

function detach(node) {
	node.parentNode.removeChild(node);
}

function prefetch(href) {
	const target = select_target(new URL(href, document.baseURI));

	if (target) {
		if (!prefetching || href !== prefetching.href) {
			set_prefetching(href, hydrate_target(target));
		}

		return prefetching.promise;
	}
}

function start(opts

) {
	if ('scrollRestoration' in _history) {
		_history.scrollRestoration = 'manual';
	}

	set_target(opts.target);

	addEventListener('click', handle_click);
	addEventListener('popstate', handle_popstate);

	// prefetch
	addEventListener('touchstart', trigger_prefetch);
	addEventListener('mousemove', handle_mousemove);

	return Promise.resolve().then(() => {
		const { hash, href } = location;

		_history.replaceState({ id: uid }, '', href);

		const url = new URL(location.href);

		if (initial_data.error) return handle_error();

		const target = select_target(url);
		if (target) return navigate(target, uid, true, hash);
	});
}

let mousemove_timeout;

function handle_mousemove(event) {
	clearTimeout(mousemove_timeout);
	mousemove_timeout = setTimeout(() => {
		trigger_prefetch(event);
	}, 20);
}

function trigger_prefetch(event) {
	const a = find_anchor(event.target);
	if (!a || a.rel !== 'prefetch') return;

	prefetch(a.href);
}

function handle_click(event) {
	// Adapted from https://github.com/visionmedia/page.js
	// MIT license https://github.com/visionmedia/page.js#license
	if (which(event) !== 1) return;
	if (event.metaKey || event.ctrlKey || event.shiftKey) return;
	if (event.defaultPrevented) return;

	const a = find_anchor(event.target);
	if (!a) return;

	if (!a.href) return;

	// check if link is inside an svg
	// in this case, both href and target are always inside an object
	const svg = typeof a.href === 'object' && a.href.constructor.name === 'SVGAnimatedString';
	const href = String(svg ? (a).href.baseVal : a.href);

	if (href === location.href) {
		if (!location.hash) event.preventDefault();
		return;
	}

	// Ignore if tag has
	// 1. 'download' attribute
	// 2. rel='external' attribute
	if (a.hasAttribute('download') || a.getAttribute('rel') === 'external') return;

	// Ignore if <a> has a target
	if (svg ? (a).target.baseVal : a.target) return;

	const url = new URL(href);

	// Don't handle hash changes
	if (url.pathname === location.pathname && url.search === location.search) return;

	const target = select_target(url);
	if (target) {
		const noscroll = a.hasAttribute('sapper-noscroll');
		navigate(target, null, noscroll, url.hash);
		event.preventDefault();
		_history.pushState({ id: cid }, '', url.href);
	}
}

function which(event) {
	return event.which === null ? event.button : event.which;
}

function find_anchor(node) {
	while (node && node.nodeName.toUpperCase() !== 'A') node = node.parentNode; // SVG <a> elements have a lowercase name
	return node;
}

function handle_popstate(event) {
	scroll_history[cid] = scroll_state();

	if (event.state) {
		const url = new URL(location.href);
		const target = select_target(url);
		if (target) {
			navigate(target, event.state.id);
		} else {
			location.href = location.href;
		}
	} else {
		// hashchange
		set_uid(uid + 1);
		set_cid(uid);
		_history.replaceState({ id: cid }, '', location.href);
	}
}

const stores$1 = () => getContext(CONTEXT_KEY);

export { stores$1 as a, goto as g, start as s };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLjYyM2YwZWU0LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbm9kZV9tb2R1bGVzL0BzYXBwZXIvaW50ZXJuYWwvc2hhcmVkLm1qcyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1ByZWxvYWRpbmdJbmRpY2F0b3Iuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9fbGF5b3V0LnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvX2Vycm9yLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9ub2RlX21vZHVsZXMvQHNhcHBlci9pbnRlcm5hbC9BcHAuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL25vZGVfbW9kdWxlcy9Ac2FwcGVyL2ludGVybmFsL21hbmlmZXN0LWNsaWVudC5tanMiLCIuLi8uLi8uLi9zcmMvbm9kZV9tb2R1bGVzL0BzYXBwZXIvYXBwLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gJ3N2ZWx0ZS9zdG9yZSc7XHJcblxyXG5leHBvcnQgY29uc3QgQ09OVEVYVF9LRVkgPSB7fTtcclxuXHJcbmV4cG9ydCBjb25zdCBwcmVsb2FkID0gKCkgPT4gKHt9KTsiLCI8c2NyaXB0PlxyXG5cdGltcG9ydCB7IG9uTW91bnQgfSBmcm9tICdzdmVsdGUnO1xyXG5cclxuXHRsZXQgcCA9IDA7XHJcblx0bGV0IHZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0b25Nb3VudCgoKSA9PiB7XHJcblx0XHRmdW5jdGlvbiBuZXh0KCkge1xyXG5cdFx0XHR2aXNpYmxlID0gdHJ1ZTtcclxuXHRcdFx0cCArPSAwLjE7XHJcblxyXG5cdFx0XHRjb25zdCByZW1haW5pbmcgPSAxIC0gcDtcclxuXHRcdFx0aWYgKHJlbWFpbmluZyA+IDAuMTUpIHNldFRpbWVvdXQobmV4dCwgNTAwIC8gcmVtYWluaW5nKTtcclxuXHRcdH1cclxuXHJcblx0XHRzZXRUaW1lb3V0KG5leHQsIDI1MCk7XHJcblx0fSk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5wcm9ncmVzcy1jb250YWluZXIge1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0dG9wOiAwO1xyXG5cdFx0bGVmdDogMDtcclxuXHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0aGVpZ2h0OiA0cHg7XHJcblx0XHR6LWluZGV4OiA5OTk7XHJcblx0fVxyXG5cclxuXHQucHJvZ3Jlc3Mge1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0bGVmdDogMDtcclxuXHRcdHRvcDogMDtcclxuXHRcdGhlaWdodDogMTAwJTtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHZhcigtLXByaW1lKTtcclxuXHRcdHRyYW5zaXRpb246IHdpZHRoIDAuNHM7XHJcblx0fVxyXG5cclxuXHQuZmFkZSB7XHJcblx0XHRwb3NpdGlvbjogZml4ZWQ7XHJcblx0XHR3aWR0aDogMTAwJTtcclxuXHRcdGhlaWdodDogMTAwJTtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC4zKTtcclxuXHRcdHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG5cdFx0ei1pbmRleDogOTk4O1xyXG5cdFx0YW5pbWF0aW9uOiBmYWRlIDAuNHM7XHJcblx0fVxyXG5cclxuXHRAa2V5ZnJhbWVzIGZhZGUge1xyXG5cdFx0ZnJvbSB7IG9wYWNpdHk6IDAgfVxyXG5cdFx0dG8geyBvcGFjaXR5OiAxIH1cclxuXHR9XHJcbjwvc3R5bGU+XHJcblxyXG57I2lmIHZpc2libGV9XHJcblx0PGRpdiBjbGFzcz1cInByb2dyZXNzLWNvbnRhaW5lclwiPlxyXG5cdFx0PGRpdiBjbGFzcz1cInByb2dyZXNzXCIgc3R5bGU9XCJ3aWR0aDoge3AgKiAxMDB9JVwiPjwvZGl2PlxyXG5cdDwvZGl2PlxyXG57L2lmfVxyXG5cclxueyNpZiBwID49IDAuNH1cclxuXHQ8ZGl2IGNsYXNzPVwiZmFkZVwiPjwvZGl2PlxyXG57L2lmfSIsIjxzY3JpcHQ+XHJcblx0aW1wb3J0IHsgc2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XHJcblx0aW1wb3J0IHsgc3RvcmVzIH0gZnJvbSAnQHNhcHBlci9hcHAnO1xyXG5cdGltcG9ydCB7IEljb24sIEljb25zLCBOYXYsIE5hdkl0ZW0gfSBmcm9tICdAc3ZlbHRlanMvc2l0ZS1raXQnO1xyXG5cdGltcG9ydCBQcmVsb2FkaW5nSW5kaWNhdG9yIGZyb20gJy4uL2NvbXBvbmVudHMvUHJlbG9hZGluZ0luZGljYXRvci5zdmVsdGUnO1xyXG5cclxuXHRleHBvcnQgbGV0IHNlZ21lbnQ7XHJcblxyXG5cdGNvbnN0IHsgcGFnZSwgcHJlbG9hZGluZywgc2Vzc2lvbiB9ID0gc3RvcmVzKCk7XHJcblxyXG5cdHNldENvbnRleHQoJ2FwcCcsIHtcclxuXHRcdGxvZ2luOiAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IGxvZ2luX3dpbmRvdyA9IHdpbmRvdy5vcGVuKGAke3dpbmRvdy5sb2NhdGlvbi5vcmlnaW59L2F1dGgvbG9naW5gLCAnbG9naW4nLCAnd2lkdGg9NjAwLGhlaWdodD00MDAnKTtcclxuXHJcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xyXG5cdFx0XHRcdGxvZ2luX3dpbmRvdy5jbG9zZSgpO1xyXG5cdFx0XHRcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlcik7XHJcblx0XHRcdFx0JHNlc3Npb24udXNlciA9IGV2ZW50LmRhdGEudXNlcjtcclxuXHRcdFx0fSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGxvZ291dDogYXN5bmMgKCkgPT4ge1xyXG5cdFx0XHRjb25zdCByID0gYXdhaXQgZmV0Y2goYC9hdXRoL2xvZ291dGAsIHtcclxuXHRcdFx0XHRjcmVkZW50aWFsczogJ2luY2x1ZGUnXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYgKHIub2spICRzZXNzaW9uLnVzZXIgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG48L3NjcmlwdD5cclxuXHJcbjxJY29ucy8+XHJcblxyXG57I2lmICRwcmVsb2FkaW5nfVxyXG5cdDxQcmVsb2FkaW5nSW5kaWNhdG9yLz5cclxuey9pZn1cclxuXHJcbnsjaWYgJHBhZ2UucGF0aCAhPT0gJy9yZXBsL2VtYmVkJ31cclxuXHQ8TmF2IHtzZWdtZW50fSB7cGFnZX0gbG9nbz1cInN2ZWx0ZS1sb2dvLWhvcml6b250YWwuc3ZnXCI+XHJcblx0XHQ8TmF2SXRlbSBzZWdtZW50PVwidHV0b3JpYWxcIj7mlZnnqIs8L05hdkl0ZW0+XHJcblx0XHQ8TmF2SXRlbSBzZWdtZW50PVwiZG9jc1wiPkFQSTwvTmF2SXRlbT5cclxuXHRcdDxOYXZJdGVtIHNlZ21lbnQ9XCJleGFtcGxlc1wiPuWunuS+izwvTmF2SXRlbT5cclxuXHRcdDxOYXZJdGVtIHNlZ21lbnQ9XCJyZXBsXCI+UkVQTDwvTmF2SXRlbT5cclxuXHRcdDxOYXZJdGVtIHNlZ21lbnQ9XCJibG9nXCI+5Y2a5a6iPC9OYXZJdGVtPlxyXG5cdFx0PE5hdkl0ZW0gc2VnbWVudD1cImZhcVwiPuW4uOingemXrumimDwvTmF2SXRlbT5cclxuXHJcblx0XHQ8TmF2SXRlbSBleHRlcm5hbD1cImh0dHBzOi8vc2FwcGVyLnN2ZWx0ZS5kZXZcIj5TYXBwZXI8L05hdkl0ZW0+XHJcblxyXG5cdFx0PE5hdkl0ZW0gZXh0ZXJuYWw9XCJjaGF0XCIgdGl0bGU9XCJEaXNjb3JkIENoYXRcIj5cclxuXHRcdFx0PEljb24gbmFtZT1cIm1lc3NhZ2Utc3F1YXJlXCIvPlxyXG5cdFx0PC9OYXZJdGVtPlxyXG5cclxuXHRcdDxOYXZJdGVtIGV4dGVybmFsPVwiaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZVwiIHRpdGxlPVwiR2l0SHViIFJlcG9cIj5cclxuXHRcdFx0PEljb24gbmFtZT1cImdpdGh1YlwiLz5cclxuXHRcdDwvTmF2SXRlbT5cclxuXHQ8L05hdj5cclxuey9pZn1cclxuXHJcbjxtYWluPlxyXG5cdDxzbG90Pjwvc2xvdD5cclxuPC9tYWluPlxyXG5cclxuPHN0eWxlPlxyXG5cdG1haW4ge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0bWFyZ2luOiAwIGF1dG87XHJcblx0XHQvKiBwYWRkaW5nOiB2YXIoLS1uYXYtaCkgdmFyKC0tc2lkZS1uYXYpIDAgdmFyKC0tc2lkZS1uYXYpOyAqL1xyXG5cdFx0cGFkZGluZzogdmFyKC0tbmF2LWgpIDAgMCAwO1xyXG5cdFx0b3ZlcmZsb3cteDogaGlkZGVuO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuIiwiPHNjcmlwdD5cclxuXHRjb25zdCBkZXYgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JztcclxuXHJcblx0ZXhwb3J0IGxldCBzdGF0dXM7XHJcblx0ZXhwb3J0IGxldCBlcnJvcjtcclxuXHJcblx0Ly8gd2UgZG9uJ3Qgd2FudCB0byB1c2UgPHN2ZWx0ZTp3aW5kb3cgYmluZDpvbmxpbmU+IGhlcmUsXHJcblx0Ly8gYmVjYXVzZSB3ZSBvbmx5IGNhcmUgYWJvdXQgdGhlIG9ubGluZSBzdGF0ZSB3aGVuXHJcblx0Ly8gdGhlIHBhZ2UgZmlyc3QgbG9hZHNcclxuXHRjb25zdCBvbmxpbmUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xyXG5cdFx0PyBuYXZpZ2F0b3Iub25MaW5lXHJcblx0XHQ6IHRydWU7XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5jb250YWluZXIge1xyXG5cdFx0cGFkZGluZzogdmFyKC0tdG9wLW9mZnNldCkgdmFyKC0tc2lkZS1uYXYpIDZyZW0gdmFyKC0tc2lkZS1uYXYpO1xyXG5cdH1cclxuXHJcblx0aDEsIHAgeyBtYXJnaW46IDAgYXV0byB9XHJcblxyXG5cdGgxIHtcclxuXHRcdGZvbnQtc2l6ZTogMi44ZW07XHJcblx0XHRmb250LXdlaWdodDogMzAwO1xyXG5cdFx0bWFyZ2luOiAwIDAgMC41ZW0gMDtcclxuXHR9XHJcblxyXG5cdHAgeyBtYXJnaW46IDFlbSBhdXRvIH1cclxuXHJcblx0LmVycm9yIHtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6ICNkYTEwNmU7XHJcblx0XHRjb2xvcjogd2hpdGU7XHJcblx0XHRwYWRkaW5nOiAxMnB4IDE2cHg7XHJcblx0XHRmb250OiA2MDAgMTZweC8xLjcgdmFyKC0tZm9udCk7XHJcblx0XHRib3JkZXItcmFkaXVzOiAycHg7XHJcblx0fVxyXG5cclxuXHQvKiBAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIHtcclxuXHRcdGgxIHsgZm9udC1zaXplOiA0ZW0gfVxyXG5cdH0gKi9cclxuPC9zdHlsZT5cclxuXHJcbjxzdmVsdGU6aGVhZD5cclxuXHQ8dGl0bGU+e3N0YXR1c308L3RpdGxlPlxyXG48L3N2ZWx0ZTpoZWFkPlxyXG5cclxuPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxyXG5cdHsjaWYgb25saW5lfVxyXG5cdFx0PGgxPllpa2VzITwvaDE+XHJcblxyXG5cdFx0eyNpZiBlcnJvci5tZXNzYWdlfVxyXG5cdFx0XHQ8cCBjbGFzcz1cImVycm9yXCI+e3N0YXR1c306IHtlcnJvci5tZXNzYWdlfTwvcD5cclxuXHRcdHs6ZWxzZX1cclxuXHRcdFx0PHAgY2xhc3M9XCJlcnJvclwiPkVuY291bnRlcmVkIGEge3N0YXR1c30gZXJyb3I8L3A+XHJcblx0XHR7L2lmfVxyXG5cclxuXHRcdHsjaWYgZGV2ICYmIGVycm9yLnN0YWNrfVxyXG5cdFx0XHQ8cHJlPntlcnJvci5zdGFja308L3ByZT5cclxuXHRcdHs6ZWxzZX1cclxuXHRcdFx0eyNpZiBzdGF0dXMgPj0gNTAwfVxyXG5cdFx0XHRcdDxwPlBsZWFzZSB0cnkgcmVsb2FkaW5nIHRoZSBwYWdlLjwvcD5cclxuXHRcdFx0ey9pZn1cclxuXHJcblx0XHRcdDxwPklmIHRoZSBlcnJvciBwZXJzaXN0cywgcGxlYXNlIGRyb3AgYnkgPGEgaHJlZj1cImNoYXRcIj5EaXNjb3JkIGNoYXRyb29tPC9hPiBhbmQgbGV0IHVzIGtub3csIG9yIHJhaXNlIGFuIGlzc3VlIG9uIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlXCI+R2l0SHViPC9hPi4gVGhhbmtzITwvcD5cclxuXHRcdHsvaWZ9XHJcblx0ezplbHNlfVxyXG5cdFx0PGgxPkl0IGxvb2tzIGxpa2UgeW91J3JlIG9mZmxpbmU8L2gxPlxyXG5cclxuXHRcdDxwPlJlbG9hZCB0aGUgcGFnZSBvbmNlIHlvdSd2ZSBmb3VuZCB0aGUgaW50ZXJuZXQuPC9wPlxyXG5cdHsvaWZ9XHJcbjwvZGl2PiIsIjwhLS0gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBTYXBwZXIg4oCUIGRvIG5vdCBlZGl0IGl0ISAtLT5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IHNldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xuXHRpbXBvcnQgeyBDT05URVhUX0tFWSB9IGZyb20gJy4vc2hhcmVkJztcblx0aW1wb3J0IExheW91dCBmcm9tICcuLi8uLi8uLi9yb3V0ZXMvX2xheW91dC5zdmVsdGUnO1xuXHRpbXBvcnQgRXJyb3IgZnJvbSAnLi4vLi4vLi4vcm91dGVzL19lcnJvci5zdmVsdGUnO1xuXG5cdGV4cG9ydCBsZXQgc3RvcmVzO1xuXHRleHBvcnQgbGV0IGVycm9yO1xuXHRleHBvcnQgbGV0IHN0YXR1cztcblx0ZXhwb3J0IGxldCBzZWdtZW50cztcblx0ZXhwb3J0IGxldCBsZXZlbDA7XG5cdGV4cG9ydCBsZXQgbGV2ZWwxID0gbnVsbDtcblx0ZXhwb3J0IGxldCBsZXZlbDIgPSBudWxsO1xuXG5cdHNldENvbnRleHQoQ09OVEVYVF9LRVksIHN0b3Jlcyk7XG48L3NjcmlwdD5cblxuPExheW91dCBzZWdtZW50PVwie3NlZ21lbnRzWzBdfVwiIHsuLi5sZXZlbDAucHJvcHN9PlxuXHR7I2lmIGVycm9yfVxuXHRcdDxFcnJvciB7ZXJyb3J9IHtzdGF0dXN9Lz5cblx0ezplbHNlfVxuXHRcdDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9XCJ7bGV2ZWwxLmNvbXBvbmVudH1cIiBzZWdtZW50PVwie3NlZ21lbnRzWzFdfVwiIHsuLi5sZXZlbDEucHJvcHN9PlxuXHRcdFx0eyNpZiBsZXZlbDJ9XG5cdFx0XHRcdDxzdmVsdGU6Y29tcG9uZW50IHRoaXM9XCJ7bGV2ZWwyLmNvbXBvbmVudH1cIiB7Li4ubGV2ZWwyLnByb3BzfS8+XG5cdFx0XHR7L2lmfVxuXHRcdDwvc3ZlbHRlOmNvbXBvbmVudD5cblx0ey9pZn1cbjwvTGF5b3V0PiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgU2FwcGVyIOKAlCBkbyBub3QgZWRpdCBpdCFcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUm9vdCB9IGZyb20gJy4uLy4uLy4uL3JvdXRlcy9fbGF5b3V0LnN2ZWx0ZSc7XG5leHBvcnQgeyBwcmVsb2FkIGFzIHJvb3RfcHJlbG9hZCB9IGZyb20gJy4vc2hhcmVkJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRXJyb3JDb21wb25lbnQgfSBmcm9tICcuLi8uLi8uLi9yb3V0ZXMvX2Vycm9yLnN2ZWx0ZSc7XG5cbmV4cG9ydCBjb25zdCBpZ25vcmUgPSBbL15cXC9leGFtcGxlcy5qc29uJC8sIC9eXFwvZXhhbXBsZXNcXC8oW15cXC9dKz8pLmpzb24kLywgL15cXC90dXRvcmlhbC5qc29uJC8sIC9eXFwvdHV0b3JpYWxcXC9yYW5kb20tbnVtYmVyXFwvPyQvLCAvXlxcL3R1dG9yaWFsXFwvKFteXFwvXSs/KS5qc29uJC8sIC9eXFwvYXBwcy5qc29uJC8sIC9eXFwvYXV0aFxcL2NhbGxiYWNrXFwvPyQvLCAvXlxcL2F1dGhcXC9sb2dvdXRcXC8/JC8sIC9eXFwvYXV0aFxcL2xvZ2luXFwvPyQvLCAvXlxcL2Jsb2cuanNvbiQvLCAvXlxcL2Jsb2dcXC9yc3MueG1sJC8sIC9eXFwvYmxvZ1xcLyhbXlxcL10rPykuanNvbiQvLCAvXlxcL2NoYXRcXC8/JC8sIC9eXFwvZG9jcy5qc29uJC8sIC9eXFwvcmVwbFxcL2NyZWF0ZS5qc29uJC8sIC9eXFwvcmVwbFxcL2xvY2FsXFwvKC4rKSQvLCAvXlxcL3JlcGxcXC8oW15cXC9dKz8pLmpzb24kLywgL15cXC9mYXFcXC8/JC9dO1xuXG5leHBvcnQgY29uc3QgY29tcG9uZW50cyA9IFtcblx0e1xuXHRcdGpzOiAoKSA9PiBpbXBvcnQoXCIuLi8uLi8uLi9yb3V0ZXMvaW5kZXguc3ZlbHRlXCIpLFxuXHRcdGNzczogXCJfX1NBUFBFUl9DU1NfUExBQ0VIT0xERVI6aW5kZXguc3ZlbHRlX19cIlxuXHR9LFxuXHR7XG5cdFx0anM6ICgpID0+IGltcG9ydChcIi4uLy4uLy4uL3JvdXRlcy9leGFtcGxlcy9pbmRleC5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjpleGFtcGxlcy9pbmRleC5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL3R1dG9yaWFsL19sYXlvdXQuc3ZlbHRlXCIpLFxuXHRcdGNzczogXCJfX1NBUFBFUl9DU1NfUExBQ0VIT0xERVI6dHV0b3JpYWwvX2xheW91dC5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL3R1dG9yaWFsL2luZGV4LnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOnR1dG9yaWFsL2luZGV4LnN2ZWx0ZV9fXCJcblx0fSxcblx0e1xuXHRcdGpzOiAoKSA9PiBpbXBvcnQoXCIuLi8uLi8uLi9yb3V0ZXMvdHV0b3JpYWwvW3NsdWddL2luZGV4LnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOnR1dG9yaWFsL1tzbHVnXS9pbmRleC5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL2FwcHMvaW5kZXguc3ZlbHRlXCIpLFxuXHRcdGNzczogXCJfX1NBUFBFUl9DU1NfUExBQ0VIT0xERVI6YXBwcy9pbmRleC5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL2Jsb2cvaW5kZXguc3ZlbHRlXCIpLFxuXHRcdGNzczogXCJfX1NBUFBFUl9DU1NfUExBQ0VIT0xERVI6YmxvZy9pbmRleC5zdmVsdGVfX1wiXG5cdH0sXG5cdHtcblx0XHRqczogKCkgPT4gaW1wb3J0KFwiLi4vLi4vLi4vcm91dGVzL2Jsb2cvW3NsdWddLnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOmJsb2cvW3NsdWddLnN2ZWx0ZV9fXCJcblx0fSxcblx0e1xuXHRcdGpzOiAoKSA9PiBpbXBvcnQoXCIuLi8uLi8uLi9yb3V0ZXMvZG9jcy9pbmRleC5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjpkb2NzL2luZGV4LnN2ZWx0ZV9fXCJcblx0fSxcblx0e1xuXHRcdGpzOiAoKSA9PiBpbXBvcnQoXCIuLi8uLi8uLi9yb3V0ZXMvcmVwbC9pbmRleC5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjpyZXBsL2luZGV4LnN2ZWx0ZV9fXCJcblx0fSxcblx0e1xuXHRcdGpzOiAoKSA9PiBpbXBvcnQoXCIuLi8uLi8uLi9yb3V0ZXMvcmVwbC9lbWJlZC5zdmVsdGVcIiksXG5cdFx0Y3NzOiBcIl9fU0FQUEVSX0NTU19QTEFDRUhPTERFUjpyZXBsL2VtYmVkLnN2ZWx0ZV9fXCJcblx0fSxcblx0e1xuXHRcdGpzOiAoKSA9PiBpbXBvcnQoXCIuLi8uLi8uLi9yb3V0ZXMvcmVwbC9baWRdL2luZGV4LnN2ZWx0ZVwiKSxcblx0XHRjc3M6IFwiX19TQVBQRVJfQ1NTX1BMQUNFSE9MREVSOnJlcGwvW2lkXS9pbmRleC5zdmVsdGVfX1wiXG5cdH1cbl07XG5cbmV4cG9ydCBjb25zdCByb3V0ZXMgPSAoZCA9PiBbXG5cdHtcblx0XHQvLyBpbmRleC5zdmVsdGVcblx0XHRwYXR0ZXJuOiAvXlxcLyQvLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHR7IGk6IDAgfVxuXHRcdF1cblx0fSxcblxuXHR7XG5cdFx0Ly8gZXhhbXBsZXMvaW5kZXguc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9leGFtcGxlc1xcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBpOiAxIH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIHR1dG9yaWFsL2luZGV4LnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvdHV0b3JpYWxcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgaTogMiB9LFxuXHRcdFx0eyBpOiAzIH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIHR1dG9yaWFsL1tzbHVnXS9pbmRleC5zdmVsdGVcblx0XHRwYXR0ZXJuOiAvXlxcL3R1dG9yaWFsXFwvKFteXFwvXSs/KVxcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBpOiAyIH0sXG5cdFx0XHR7IGk6IDQsIHBhcmFtczogbWF0Y2ggPT4gKHsgc2x1ZzogZChtYXRjaFsxXSkgfSkgfVxuXHRcdF1cblx0fSxcblxuXHR7XG5cdFx0Ly8gYXBwcy9pbmRleC5zdmVsdGVcblx0XHRwYXR0ZXJuOiAvXlxcL2FwcHNcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgaTogNSB9XG5cdFx0XVxuXHR9LFxuXG5cdHtcblx0XHQvLyBibG9nL2luZGV4LnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvYmxvZ1xcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBpOiA2IH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIGJsb2cvW3NsdWddLnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvYmxvZ1xcLyhbXlxcL10rPylcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdG51bGwsXG5cdFx0XHR7IGk6IDcsIHBhcmFtczogbWF0Y2ggPT4gKHsgc2x1ZzogZChtYXRjaFsxXSkgfSkgfVxuXHRcdF1cblx0fSxcblxuXHR7XG5cdFx0Ly8gZG9jcy9pbmRleC5zdmVsdGVcblx0XHRwYXR0ZXJuOiAvXlxcL2RvY3NcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdHsgaTogOCB9XG5cdFx0XVxuXHR9LFxuXG5cdHtcblx0XHQvLyByZXBsL2luZGV4LnN2ZWx0ZVxuXHRcdHBhdHRlcm46IC9eXFwvcmVwbFxcLz8kLyxcblx0XHRwYXJ0czogW1xuXHRcdFx0eyBpOiA5IH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIHJlcGwvZW1iZWQuc3ZlbHRlXG5cdFx0cGF0dGVybjogL15cXC9yZXBsXFwvZW1iZWRcXC8/JC8sXG5cdFx0cGFydHM6IFtcblx0XHRcdG51bGwsXG5cdFx0XHR7IGk6IDEwIH1cblx0XHRdXG5cdH0sXG5cblx0e1xuXHRcdC8vIHJlcGwvW2lkXS9pbmRleC5zdmVsdGVcblx0XHRwYXR0ZXJuOiAvXlxcL3JlcGxcXC8oW15cXC9dKz8pXFwvPyQvLFxuXHRcdHBhcnRzOiBbXG5cdFx0XHRudWxsLFxuXHRcdFx0eyBpOiAxMSwgcGFyYW1zOiBtYXRjaCA9PiAoeyBpZDogZChtYXRjaFsxXSkgfSkgfVxuXHRcdF1cblx0fVxuXSkoZGVjb2RlVVJJQ29tcG9uZW50KTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdGltcG9ydChcIkM6L1VzZXJzL1J1bm5pbmd6cy9EZXNrdG9wL2xlYXJuL3N2ZWx0ZS1tYXN0ZXIvc2l0ZS9ub2RlX21vZHVsZXMvc2FwcGVyL3NhcHBlci1kZXYtY2xpZW50LmpzXCIpLnRoZW4oY2xpZW50ID0+IHtcblx0XHRjbGllbnQuY29ubmVjdCgxMDAwMCk7XG5cdH0pO1xufSIsImltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xyXG5pbXBvcnQgeyBDT05URVhUX0tFWSB9IGZyb20gJy4vaW50ZXJuYWwvc2hhcmVkJztcclxuaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tICdzdmVsdGUvc3RvcmUnO1xyXG5pbXBvcnQgQXBwIGZyb20gJy4vaW50ZXJuYWwvQXBwLnN2ZWx0ZSc7XHJcbmltcG9ydCB7IGlnbm9yZSwgcm91dGVzLCByb290X3ByZWxvYWQsIGNvbXBvbmVudHMsIEVycm9yQ29tcG9uZW50IH0gZnJvbSAnLi9pbnRlcm5hbC9tYW5pZmVzdC1jbGllbnQnO1xyXG5cclxuZnVuY3Rpb24gZ290byhocmVmLCBvcHRzID0geyByZXBsYWNlU3RhdGU6IGZhbHNlIH0pIHtcclxuXHRjb25zdCB0YXJnZXQgPSBzZWxlY3RfdGFyZ2V0KG5ldyBVUkwoaHJlZiwgZG9jdW1lbnQuYmFzZVVSSSkpO1xyXG5cclxuXHRpZiAodGFyZ2V0KSB7XHJcblx0XHRfaGlzdG9yeVtvcHRzLnJlcGxhY2VTdGF0ZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHsgaWQ6IGNpZCB9LCAnJywgaHJlZik7XHJcblx0XHRyZXR1cm4gbmF2aWdhdGUodGFyZ2V0LCBudWxsKS50aGVuKCgpID0+IHt9KTtcclxuXHR9XHJcblxyXG5cdGxvY2F0aW9uLmhyZWYgPSBocmVmO1xyXG5cdHJldHVybiBuZXcgUHJvbWlzZShmID0+IHt9KTsgLy8gbmV2ZXIgcmVzb2x2ZXNcclxufVxyXG5cclxuY29uc3QgaW5pdGlhbF9kYXRhID0gdHlwZW9mIF9fU0FQUEVSX18gIT09ICd1bmRlZmluZWQnICYmIF9fU0FQUEVSX187XHJcblxyXG5sZXQgcmVhZHkgPSBmYWxzZTtcclxubGV0IHJvb3RfY29tcG9uZW50O1xyXG5sZXQgY3VycmVudF90b2tlbjtcclxubGV0IHJvb3RfcHJlbG9hZGVkO1xyXG5sZXQgY3VycmVudF9icmFuY2ggPSBbXTtcclxubGV0IGN1cnJlbnRfcXVlcnkgPSAne30nO1xyXG5cclxuY29uc3Qgc3RvcmVzID0ge1xyXG5cdHBhZ2U6IHdyaXRhYmxlKHt9KSxcclxuXHRwcmVsb2FkaW5nOiB3cml0YWJsZShudWxsKSxcclxuXHRzZXNzaW9uOiB3cml0YWJsZShpbml0aWFsX2RhdGEgJiYgaW5pdGlhbF9kYXRhLnNlc3Npb24pXHJcbn07XHJcblxyXG5sZXQgJHNlc3Npb247XHJcbmxldCBzZXNzaW9uX2RpcnR5O1xyXG5cclxuc3RvcmVzLnNlc3Npb24uc3Vic2NyaWJlKGFzeW5jIHZhbHVlID0+IHtcclxuXHQkc2Vzc2lvbiA9IHZhbHVlO1xyXG5cclxuXHRpZiAoIXJlYWR5KSByZXR1cm47XHJcblx0c2Vzc2lvbl9kaXJ0eSA9IHRydWU7XHJcblxyXG5cdGNvbnN0IHRhcmdldCA9IHNlbGVjdF90YXJnZXQobmV3IFVSTChsb2NhdGlvbi5ocmVmKSk7XHJcblxyXG5cdGNvbnN0IHRva2VuID0gY3VycmVudF90b2tlbiA9IHt9O1xyXG5cdGNvbnN0IHsgcmVkaXJlY3QsIHByb3BzLCBicmFuY2ggfSA9IGF3YWl0IGh5ZHJhdGVfdGFyZ2V0KHRhcmdldCk7XHJcblx0aWYgKHRva2VuICE9PSBjdXJyZW50X3Rva2VuKSByZXR1cm47IC8vIGEgc2Vjb25kYXJ5IG5hdmlnYXRpb24gaGFwcGVuZWQgd2hpbGUgd2Ugd2VyZSBsb2FkaW5nXHJcblxyXG5cdGF3YWl0IHJlbmRlcihyZWRpcmVjdCwgYnJhbmNoLCBwcm9wcywgdGFyZ2V0LnBhZ2UpO1xyXG59KTtcclxuXHJcbmxldCBwcmVmZXRjaGluZ1xyXG5cclxuXHJcbiA9IG51bGw7XHJcbmZ1bmN0aW9uIHNldF9wcmVmZXRjaGluZyhocmVmLCBwcm9taXNlKSB7XHJcblx0cHJlZmV0Y2hpbmcgPSB7IGhyZWYsIHByb21pc2UgfTtcclxufVxyXG5cclxubGV0IHRhcmdldDtcclxuZnVuY3Rpb24gc2V0X3RhcmdldChlbGVtZW50KSB7XHJcblx0dGFyZ2V0ID0gZWxlbWVudDtcclxufVxyXG5cclxubGV0IHVpZCA9IDE7XHJcbmZ1bmN0aW9uIHNldF91aWQobikge1xyXG5cdHVpZCA9IG47XHJcbn1cclxuXHJcbmxldCBjaWQ7XHJcbmZ1bmN0aW9uIHNldF9jaWQobikge1xyXG5cdGNpZCA9IG47XHJcbn1cclxuXHJcbmNvbnN0IF9oaXN0b3J5ID0gdHlwZW9mIGhpc3RvcnkgIT09ICd1bmRlZmluZWQnID8gaGlzdG9yeSA6IHtcclxuXHRwdXNoU3RhdGU6IChzdGF0ZSwgdGl0bGUsIGhyZWYpID0+IHt9LFxyXG5cdHJlcGxhY2VTdGF0ZTogKHN0YXRlLCB0aXRsZSwgaHJlZikgPT4ge30sXHJcblx0c2Nyb2xsUmVzdG9yYXRpb246ICcnXHJcbn07XHJcblxyXG5jb25zdCBzY3JvbGxfaGlzdG9yeSA9IHt9O1xyXG5cclxuZnVuY3Rpb24gZXh0cmFjdF9xdWVyeShzZWFyY2gpIHtcclxuXHRjb25zdCBxdWVyeSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblx0aWYgKHNlYXJjaC5sZW5ndGggPiAwKSB7XHJcblx0XHRzZWFyY2guc2xpY2UoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKHNlYXJjaFBhcmFtID0+IHtcclxuXHRcdFx0bGV0IFssIGtleSwgdmFsdWUgPSAnJ10gPSAvKFtePV0qKSg/Oj0oLiopKT8vLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHNlYXJjaFBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpKSk7XHJcblx0XHRcdGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3N0cmluZycpIHF1ZXJ5W2tleV0gPSBbcXVlcnlba2V5XV07XHJcblx0XHRcdGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ29iamVjdCcpIChxdWVyeVtrZXldICkucHVzaCh2YWx1ZSk7XHJcblx0XHRcdGVsc2UgcXVlcnlba2V5XSA9IHZhbHVlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdHJldHVybiBxdWVyeTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2VsZWN0X3RhcmdldCh1cmwpIHtcclxuXHRpZiAodXJsLm9yaWdpbiAhPT0gbG9jYXRpb24ub3JpZ2luKSByZXR1cm4gbnVsbDtcclxuXHRpZiAoIXVybC5wYXRobmFtZS5zdGFydHNXaXRoKGluaXRpYWxfZGF0YS5iYXNlVXJsKSkgcmV0dXJuIG51bGw7XHJcblxyXG5cdGxldCBwYXRoID0gdXJsLnBhdGhuYW1lLnNsaWNlKGluaXRpYWxfZGF0YS5iYXNlVXJsLmxlbmd0aCk7XHJcblxyXG5cdGlmIChwYXRoID09PSAnJykge1xyXG5cdFx0cGF0aCA9ICcvJztcclxuXHR9XHJcblxyXG5cdC8vIGF2b2lkIGFjY2lkZW50YWwgY2xhc2hlcyBiZXR3ZWVuIHNlcnZlciByb3V0ZXMgYW5kIHBhZ2Ugcm91dGVzXHJcblx0aWYgKGlnbm9yZS5zb21lKHBhdHRlcm4gPT4gcGF0dGVybi50ZXN0KHBhdGgpKSkgcmV0dXJuO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlcy5sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0Y29uc3Qgcm91dGUgPSByb3V0ZXNbaV07XHJcblxyXG5cdFx0Y29uc3QgbWF0Y2ggPSByb3V0ZS5wYXR0ZXJuLmV4ZWMocGF0aCk7XHJcblxyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdGNvbnN0IHF1ZXJ5ID0gZXh0cmFjdF9xdWVyeSh1cmwuc2VhcmNoKTtcclxuXHRcdFx0Y29uc3QgcGFydCA9IHJvdXRlLnBhcnRzW3JvdXRlLnBhcnRzLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRjb25zdCBwYXJhbXMgPSBwYXJ0LnBhcmFtcyA/IHBhcnQucGFyYW1zKG1hdGNoKSA6IHt9O1xyXG5cclxuXHRcdFx0Y29uc3QgcGFnZSA9IHsgaG9zdDogbG9jYXRpb24uaG9zdCwgcGF0aCwgcXVlcnksIHBhcmFtcyB9O1xyXG5cclxuXHRcdFx0cmV0dXJuIHsgaHJlZjogdXJsLmhyZWYsIHJvdXRlLCBtYXRjaCwgcGFnZSB9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gaGFuZGxlX2Vycm9yKHVybCkge1xyXG5cdGNvbnN0IHsgaG9zdCwgcGF0aG5hbWUsIHNlYXJjaCB9ID0gbG9jYXRpb247XHJcblx0Y29uc3QgeyBzZXNzaW9uLCBwcmVsb2FkZWQsIHN0YXR1cywgZXJyb3IgfSA9IGluaXRpYWxfZGF0YTtcclxuXHJcblx0aWYgKCFyb290X3ByZWxvYWRlZCkge1xyXG5cdFx0cm9vdF9wcmVsb2FkZWQgPSBwcmVsb2FkZWQgJiYgcHJlbG9hZGVkWzBdO1xyXG5cdH1cclxuXHJcblx0Y29uc3QgcHJvcHMgPSB7XHJcblx0XHRlcnJvcixcclxuXHRcdHN0YXR1cyxcclxuXHRcdHNlc3Npb24sXHJcblx0XHRsZXZlbDA6IHtcclxuXHRcdFx0cHJvcHM6IHJvb3RfcHJlbG9hZGVkXHJcblx0XHR9LFxyXG5cdFx0bGV2ZWwxOiB7XHJcblx0XHRcdHByb3BzOiB7XHJcblx0XHRcdFx0c3RhdHVzLFxyXG5cdFx0XHRcdGVycm9yXHJcblx0XHRcdH0sXHJcblx0XHRcdGNvbXBvbmVudDogRXJyb3JDb21wb25lbnRcclxuXHRcdH0sXHJcblx0XHRzZWdtZW50czogcHJlbG9hZGVkXHJcblxyXG5cdH07XHJcblx0Y29uc3QgcXVlcnkgPSBleHRyYWN0X3F1ZXJ5KHNlYXJjaCk7XHJcblx0cmVuZGVyKG51bGwsIFtdLCBwcm9wcywgeyBob3N0LCBwYXRoOiBwYXRobmFtZSwgcXVlcnksIHBhcmFtczoge30gfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNjcm9sbF9zdGF0ZSgpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogcGFnZVhPZmZzZXQsXHJcblx0XHR5OiBwYWdlWU9mZnNldFxyXG5cdH07XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKHRhcmdldCwgaWQsIG5vc2Nyb2xsLCBoYXNoKSB7XHJcblx0aWYgKGlkKSB7XHJcblx0XHQvLyBwb3BzdGF0ZSBvciBpbml0aWFsIG5hdmlnYXRpb25cclxuXHRcdGNpZCA9IGlkO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjb25zdCBjdXJyZW50X3Njcm9sbCA9IHNjcm9sbF9zdGF0ZSgpO1xyXG5cclxuXHRcdC8vIGNsaWNrZWQgb24gYSBsaW5rLiBwcmVzZXJ2ZSBzY3JvbGwgc3RhdGVcclxuXHRcdHNjcm9sbF9oaXN0b3J5W2NpZF0gPSBjdXJyZW50X3Njcm9sbDtcclxuXHJcblx0XHRpZCA9IGNpZCA9ICsrdWlkO1xyXG5cdFx0c2Nyb2xsX2hpc3RvcnlbY2lkXSA9IG5vc2Nyb2xsID8gY3VycmVudF9zY3JvbGwgOiB7IHg6IDAsIHk6IDAgfTtcclxuXHR9XHJcblxyXG5cdGNpZCA9IGlkO1xyXG5cclxuXHRpZiAocm9vdF9jb21wb25lbnQpIHN0b3Jlcy5wcmVsb2FkaW5nLnNldCh0cnVlKTtcclxuXHJcblx0Y29uc3QgbG9hZGVkID0gcHJlZmV0Y2hpbmcgJiYgcHJlZmV0Y2hpbmcuaHJlZiA9PT0gdGFyZ2V0LmhyZWYgP1xyXG5cdFx0cHJlZmV0Y2hpbmcucHJvbWlzZSA6XHJcblx0XHRoeWRyYXRlX3RhcmdldCh0YXJnZXQpO1xyXG5cclxuXHRwcmVmZXRjaGluZyA9IG51bGw7XHJcblxyXG5cdGNvbnN0IHRva2VuID0gY3VycmVudF90b2tlbiA9IHt9O1xyXG5cdGNvbnN0IHsgcmVkaXJlY3QsIHByb3BzLCBicmFuY2ggfSA9IGF3YWl0IGxvYWRlZDtcclxuXHRpZiAodG9rZW4gIT09IGN1cnJlbnRfdG9rZW4pIHJldHVybjsgLy8gYSBzZWNvbmRhcnkgbmF2aWdhdGlvbiBoYXBwZW5lZCB3aGlsZSB3ZSB3ZXJlIGxvYWRpbmdcclxuXHJcblx0YXdhaXQgcmVuZGVyKHJlZGlyZWN0LCBicmFuY2gsIHByb3BzLCB0YXJnZXQucGFnZSk7XHJcblx0aWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xyXG5cclxuXHRpZiAoIW5vc2Nyb2xsKSB7XHJcblx0XHRsZXQgc2Nyb2xsID0gc2Nyb2xsX2hpc3RvcnlbaWRdO1xyXG5cclxuXHRcdGlmIChoYXNoKSB7XHJcblx0XHRcdC8vIHNjcm9sbCBpcyBhbiBlbGVtZW50IGlkIChmcm9tIGEgaGFzaCksIHdlIG5lZWQgdG8gY29tcHV0ZSB5LlxyXG5cdFx0XHRjb25zdCBkZWVwX2xpbmtlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2guc2xpY2UoMSkpO1xyXG5cclxuXHRcdFx0aWYgKGRlZXBfbGlua2VkKSB7XHJcblx0XHRcdFx0c2Nyb2xsID0ge1xyXG5cdFx0XHRcdFx0eDogMCxcclxuXHRcdFx0XHRcdHk6IGRlZXBfbGlua2VkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzY3JvbGxfaGlzdG9yeVtjaWRdID0gc2Nyb2xsO1xyXG5cdFx0aWYgKHNjcm9sbCkgc2Nyb2xsVG8oc2Nyb2xsLngsIHNjcm9sbC55KTtcclxuXHR9XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIHJlbmRlcihyZWRpcmVjdCwgYnJhbmNoLCBwcm9wcywgcGFnZSkge1xyXG5cdGlmIChyZWRpcmVjdCkgcmV0dXJuIGdvdG8ocmVkaXJlY3QubG9jYXRpb24sIHsgcmVwbGFjZVN0YXRlOiB0cnVlIH0pO1xyXG5cclxuXHRzdG9yZXMucGFnZS5zZXQocGFnZSk7XHJcblx0c3RvcmVzLnByZWxvYWRpbmcuc2V0KGZhbHNlKTtcclxuXHJcblx0aWYgKHJvb3RfY29tcG9uZW50KSB7XHJcblx0XHRyb290X2NvbXBvbmVudC4kc2V0KHByb3BzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cHJvcHMuc3RvcmVzID0ge1xyXG5cdFx0XHRwYWdlOiB7IHN1YnNjcmliZTogc3RvcmVzLnBhZ2Uuc3Vic2NyaWJlIH0sXHJcblx0XHRcdHByZWxvYWRpbmc6IHsgc3Vic2NyaWJlOiBzdG9yZXMucHJlbG9hZGluZy5zdWJzY3JpYmUgfSxcclxuXHRcdFx0c2Vzc2lvbjogc3RvcmVzLnNlc3Npb25cclxuXHRcdH07XHJcblx0XHRwcm9wcy5sZXZlbDAgPSB7XHJcblx0XHRcdHByb3BzOiBhd2FpdCByb290X3ByZWxvYWRlZFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmaXJzdCBsb2FkIOKAlCByZW1vdmUgU1NSJ2QgPGhlYWQ+IGNvbnRlbnRzXHJcblx0XHRjb25zdCBzdGFydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzYXBwZXItaGVhZC1zdGFydCcpO1xyXG5cdFx0Y29uc3QgZW5kID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NhcHBlci1oZWFkLWVuZCcpO1xyXG5cclxuXHRcdGlmIChzdGFydCAmJiBlbmQpIHtcclxuXHRcdFx0d2hpbGUgKHN0YXJ0Lm5leHRTaWJsaW5nICE9PSBlbmQpIGRldGFjaChzdGFydC5uZXh0U2libGluZyk7XHJcblx0XHRcdGRldGFjaChzdGFydCk7XHJcblx0XHRcdGRldGFjaChlbmQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJvb3RfY29tcG9uZW50ID0gbmV3IEFwcCh7XHJcblx0XHRcdHRhcmdldCxcclxuXHRcdFx0cHJvcHMsXHJcblx0XHRcdGh5ZHJhdGU6IHRydWVcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Y3VycmVudF9icmFuY2ggPSBicmFuY2g7XHJcblx0Y3VycmVudF9xdWVyeSA9IEpTT04uc3RyaW5naWZ5KHBhZ2UucXVlcnkpO1xyXG5cdHJlYWR5ID0gdHJ1ZTtcclxuXHRzZXNzaW9uX2RpcnR5ID0gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHBhcnRfY2hhbmdlZChpLCBzZWdtZW50LCBtYXRjaCwgc3RyaW5naWZpZWRfcXVlcnkpIHtcclxuXHQvLyBUT0RPIG9ubHkgY2hlY2sgcXVlcnkgc3RyaW5nIGNoYW5nZXMgZm9yIHByZWxvYWQgZnVuY3Rpb25zXHJcblx0Ly8gdGhhdCBkbyBpbiBmYWN0IGRlcGVuZCBvbiBpdCAodXNpbmcgc3RhdGljIGFuYWx5c2lzIG9yXHJcblx0Ly8gcnVudGltZSBpbnN0cnVtZW50YXRpb24pXHJcblx0aWYgKHN0cmluZ2lmaWVkX3F1ZXJ5ICE9PSBjdXJyZW50X3F1ZXJ5KSByZXR1cm4gdHJ1ZTtcclxuXHJcblx0Y29uc3QgcHJldmlvdXMgPSBjdXJyZW50X2JyYW5jaFtpXTtcclxuXHJcblx0aWYgKCFwcmV2aW91cykgcmV0dXJuIGZhbHNlO1xyXG5cdGlmIChzZWdtZW50ICE9PSBwcmV2aW91cy5zZWdtZW50KSByZXR1cm4gdHJ1ZTtcclxuXHRpZiAocHJldmlvdXMubWF0Y2gpIHtcclxuXHRcdGlmIChKU09OLnN0cmluZ2lmeShwcmV2aW91cy5tYXRjaC5zbGljZSgxLCBpICsgMikpICE9PSBKU09OLnN0cmluZ2lmeShtYXRjaC5zbGljZSgxLCBpICsgMikpKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gaHlkcmF0ZV90YXJnZXQodGFyZ2V0KVxyXG5cclxuXHJcblxyXG4ge1xyXG5cdGNvbnN0IHsgcm91dGUsIHBhZ2UgfSA9IHRhcmdldDtcclxuXHRjb25zdCBzZWdtZW50cyA9IHBhZ2UucGF0aC5zcGxpdCgnLycpLmZpbHRlcihCb29sZWFuKTtcclxuXHJcblx0bGV0IHJlZGlyZWN0ID0gbnVsbDtcclxuXHJcblx0Y29uc3QgcHJvcHMgPSB7IGVycm9yOiBudWxsLCBzdGF0dXM6IDIwMCwgc2VnbWVudHM6IFtzZWdtZW50c1swXV0gfTtcclxuXHJcblx0Y29uc3QgcHJlbG9hZF9jb250ZXh0ID0ge1xyXG5cdFx0ZmV0Y2g6ICh1cmwsIG9wdHMpID0+IGZldGNoKHVybCwgb3B0cyksXHJcblx0XHRyZWRpcmVjdDogKHN0YXR1c0NvZGUsIGxvY2F0aW9uKSA9PiB7XHJcblx0XHRcdGlmIChyZWRpcmVjdCAmJiAocmVkaXJlY3Quc3RhdHVzQ29kZSAhPT0gc3RhdHVzQ29kZSB8fCByZWRpcmVjdC5sb2NhdGlvbiAhPT0gbG9jYXRpb24pKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBDb25mbGljdGluZyByZWRpcmVjdHNgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZWRpcmVjdCA9IHsgc3RhdHVzQ29kZSwgbG9jYXRpb24gfTtcclxuXHRcdH0sXHJcblx0XHRlcnJvcjogKHN0YXR1cywgZXJyb3IpID0+IHtcclxuXHRcdFx0cHJvcHMuZXJyb3IgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gbmV3IEVycm9yKGVycm9yKSA6IGVycm9yO1xyXG5cdFx0XHRwcm9wcy5zdGF0dXMgPSBzdGF0dXM7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0aWYgKCFyb290X3ByZWxvYWRlZCkge1xyXG5cdFx0cm9vdF9wcmVsb2FkZWQgPSBpbml0aWFsX2RhdGEucHJlbG9hZGVkWzBdIHx8IHJvb3RfcHJlbG9hZC5jYWxsKHByZWxvYWRfY29udGV4dCwge1xyXG5cdFx0XHRob3N0OiBwYWdlLmhvc3QsXHJcblx0XHRcdHBhdGg6IHBhZ2UucGF0aCxcclxuXHRcdFx0cXVlcnk6IHBhZ2UucXVlcnksXHJcblx0XHRcdHBhcmFtczoge31cclxuXHRcdH0sICRzZXNzaW9uKTtcclxuXHR9XHJcblxyXG5cdGxldCBicmFuY2g7XHJcblx0bGV0IGwgPSAxO1xyXG5cclxuXHR0cnkge1xyXG5cdFx0Y29uc3Qgc3RyaW5naWZpZWRfcXVlcnkgPSBKU09OLnN0cmluZ2lmeShwYWdlLnF1ZXJ5KTtcclxuXHRcdGNvbnN0IG1hdGNoID0gcm91dGUucGF0dGVybi5leGVjKHBhZ2UucGF0aCk7XHJcblxyXG5cdFx0bGV0IHNlZ21lbnRfZGlydHkgPSBmYWxzZTtcclxuXHJcblx0XHRicmFuY2ggPSBhd2FpdCBQcm9taXNlLmFsbChyb3V0ZS5wYXJ0cy5tYXAoYXN5bmMgKHBhcnQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xyXG5cclxuXHRcdFx0aWYgKHBhcnRfY2hhbmdlZChpLCBzZWdtZW50LCBtYXRjaCwgc3RyaW5naWZpZWRfcXVlcnkpKSBzZWdtZW50X2RpcnR5ID0gdHJ1ZTtcclxuXHJcblx0XHRcdHByb3BzLnNlZ21lbnRzW2xdID0gc2VnbWVudHNbaSArIDFdOyAvLyBUT0RPIG1ha2UgdGhpcyBsZXNzIGNvbmZ1c2luZ1xyXG5cdFx0XHRpZiAoIXBhcnQpIHJldHVybiB7IHNlZ21lbnQgfTtcclxuXHJcblx0XHRcdGNvbnN0IGogPSBsKys7XHJcblxyXG5cdFx0XHRpZiAoIXNlc3Npb25fZGlydHkgJiYgIXNlZ21lbnRfZGlydHkgJiYgY3VycmVudF9icmFuY2hbaV0gJiYgY3VycmVudF9icmFuY2hbaV0ucGFydCA9PT0gcGFydC5pKSB7XHJcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRfYnJhbmNoW2ldO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzZWdtZW50X2RpcnR5ID0gZmFsc2U7XHJcblxyXG5cdFx0XHRjb25zdCB7IGRlZmF1bHQ6IGNvbXBvbmVudCwgcHJlbG9hZCB9ID0gYXdhaXQgbG9hZF9jb21wb25lbnQoY29tcG9uZW50c1twYXJ0LmldKTtcclxuXHJcblx0XHRcdGxldCBwcmVsb2FkZWQ7XHJcblx0XHRcdGlmIChyZWFkeSB8fCAhaW5pdGlhbF9kYXRhLnByZWxvYWRlZFtpICsgMV0pIHtcclxuXHRcdFx0XHRwcmVsb2FkZWQgPSBwcmVsb2FkXHJcblx0XHRcdFx0XHQ/IGF3YWl0IHByZWxvYWQuY2FsbChwcmVsb2FkX2NvbnRleHQsIHtcclxuXHRcdFx0XHRcdFx0aG9zdDogcGFnZS5ob3N0LFxyXG5cdFx0XHRcdFx0XHRwYXRoOiBwYWdlLnBhdGgsXHJcblx0XHRcdFx0XHRcdHF1ZXJ5OiBwYWdlLnF1ZXJ5LFxyXG5cdFx0XHRcdFx0XHRwYXJhbXM6IHBhcnQucGFyYW1zID8gcGFydC5wYXJhbXModGFyZ2V0Lm1hdGNoKSA6IHt9XHJcblx0XHRcdFx0XHR9LCAkc2Vzc2lvbilcclxuXHRcdFx0XHRcdDoge307XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJlbG9hZGVkID0gaW5pdGlhbF9kYXRhLnByZWxvYWRlZFtpICsgMV07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiAocHJvcHNbYGxldmVsJHtqfWBdID0geyBjb21wb25lbnQsIHByb3BzOiBwcmVsb2FkZWQsIHNlZ21lbnQsIG1hdGNoLCBwYXJ0OiBwYXJ0LmkgfSk7XHJcblx0XHR9KSk7XHJcblx0fSBjYXRjaCAoZXJyb3IpIHtcclxuXHRcdHByb3BzLmVycm9yID0gZXJyb3I7XHJcblx0XHRwcm9wcy5zdGF0dXMgPSA1MDA7XHJcblx0XHRicmFuY2ggPSBbXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB7IHJlZGlyZWN0LCBwcm9wcywgYnJhbmNoIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRfY3NzKGNodW5rKSB7XHJcblx0Y29uc3QgaHJlZiA9IGBjbGllbnQvJHtjaHVua31gO1xyXG5cdGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBsaW5rW2hyZWY9XCIke2hyZWZ9XCJdYCkpIHJldHVybjtcclxuXHJcblx0cmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWwsIHJlamVjdCkgPT4ge1xyXG5cdFx0Y29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcclxuXHRcdGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xyXG5cdFx0bGluay5ocmVmID0gaHJlZjtcclxuXHJcblx0XHRsaW5rLm9ubG9hZCA9ICgpID0+IGZ1bGZpbCgpO1xyXG5cdFx0bGluay5vbmVycm9yID0gcmVqZWN0O1xyXG5cclxuXHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxvYWRfY29tcG9uZW50KGNvbXBvbmVudClcclxuXHJcblxyXG4ge1xyXG5cdC8vIFRPRE8gdGhpcyBpcyB0ZW1wb3Jhcnkg4oCUIG9uY2UgcGxhY2Vob2xkZXJzIGFyZVxyXG5cdC8vIGFsd2F5cyByZXdyaXR0ZW4sIHNjcmF0Y2ggdGhlIHRlcm5hcnlcclxuXHRjb25zdCBwcm9taXNlcyA9ICh0eXBlb2YgY29tcG9uZW50LmNzcyA9PT0gJ3N0cmluZycgPyBbXSA6IGNvbXBvbmVudC5jc3MubWFwKGxvYWRfY3NzKSk7XHJcblx0cHJvbWlzZXMudW5zaGlmdChjb21wb25lbnQuanMoKSk7XHJcblx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKHZhbHVlcyA9PiB2YWx1ZXNbMF0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xyXG5cdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJlZmV0Y2goaHJlZikge1xyXG5cdGNvbnN0IHRhcmdldCA9IHNlbGVjdF90YXJnZXQobmV3IFVSTChocmVmLCBkb2N1bWVudC5iYXNlVVJJKSk7XHJcblxyXG5cdGlmICh0YXJnZXQpIHtcclxuXHRcdGlmICghcHJlZmV0Y2hpbmcgfHwgaHJlZiAhPT0gcHJlZmV0Y2hpbmcuaHJlZikge1xyXG5cdFx0XHRzZXRfcHJlZmV0Y2hpbmcoaHJlZiwgaHlkcmF0ZV90YXJnZXQodGFyZ2V0KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHByZWZldGNoaW5nLnByb21pc2U7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdGFydChvcHRzXHJcblxyXG4pIHtcclxuXHRpZiAoJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiBfaGlzdG9yeSkge1xyXG5cdFx0X2hpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcclxuXHR9XHJcblxyXG5cdHNldF90YXJnZXQob3B0cy50YXJnZXQpO1xyXG5cclxuXHRhZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZV9jbGljayk7XHJcblx0YWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBoYW5kbGVfcG9wc3RhdGUpO1xyXG5cclxuXHQvLyBwcmVmZXRjaFxyXG5cdGFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0cmlnZ2VyX3ByZWZldGNoKTtcclxuXHRhZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVfbW91c2Vtb3ZlKTtcclxuXHJcblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xyXG5cdFx0Y29uc3QgeyBoYXNoLCBocmVmIH0gPSBsb2NhdGlvbjtcclxuXHJcblx0XHRfaGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBpZDogdWlkIH0sICcnLCBocmVmKTtcclxuXHJcblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKGxvY2F0aW9uLmhyZWYpO1xyXG5cclxuXHRcdGlmIChpbml0aWFsX2RhdGEuZXJyb3IpIHJldHVybiBoYW5kbGVfZXJyb3IoKTtcclxuXHJcblx0XHRjb25zdCB0YXJnZXQgPSBzZWxlY3RfdGFyZ2V0KHVybCk7XHJcblx0XHRpZiAodGFyZ2V0KSByZXR1cm4gbmF2aWdhdGUodGFyZ2V0LCB1aWQsIHRydWUsIGhhc2gpO1xyXG5cdH0pO1xyXG59XHJcblxyXG5sZXQgbW91c2Vtb3ZlX3RpbWVvdXQ7XHJcblxyXG5mdW5jdGlvbiBoYW5kbGVfbW91c2Vtb3ZlKGV2ZW50KSB7XHJcblx0Y2xlYXJUaW1lb3V0KG1vdXNlbW92ZV90aW1lb3V0KTtcclxuXHRtb3VzZW1vdmVfdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0dHJpZ2dlcl9wcmVmZXRjaChldmVudCk7XHJcblx0fSwgMjApO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmlnZ2VyX3ByZWZldGNoKGV2ZW50KSB7XHJcblx0Y29uc3QgYSA9IGZpbmRfYW5jaG9yKGV2ZW50LnRhcmdldCk7XHJcblx0aWYgKCFhIHx8IGEucmVsICE9PSAncHJlZmV0Y2gnKSByZXR1cm47XHJcblxyXG5cdHByZWZldGNoKGEuaHJlZik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZV9jbGljayhldmVudCkge1xyXG5cdC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdmlzaW9ubWVkaWEvcGFnZS5qc1xyXG5cdC8vIE1JVCBsaWNlbnNlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNpb25tZWRpYS9wYWdlLmpzI2xpY2Vuc2VcclxuXHRpZiAod2hpY2goZXZlbnQpICE9PSAxKSByZXR1cm47XHJcblx0aWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSkgcmV0dXJuO1xyXG5cdGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XHJcblxyXG5cdGNvbnN0IGEgPSBmaW5kX2FuY2hvcihldmVudC50YXJnZXQpO1xyXG5cdGlmICghYSkgcmV0dXJuO1xyXG5cclxuXHRpZiAoIWEuaHJlZikgcmV0dXJuO1xyXG5cclxuXHQvLyBjaGVjayBpZiBsaW5rIGlzIGluc2lkZSBhbiBzdmdcclxuXHQvLyBpbiB0aGlzIGNhc2UsIGJvdGggaHJlZiBhbmQgdGFyZ2V0IGFyZSBhbHdheXMgaW5zaWRlIGFuIG9iamVjdFxyXG5cdGNvbnN0IHN2ZyA9IHR5cGVvZiBhLmhyZWYgPT09ICdvYmplY3QnICYmIGEuaHJlZi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnU1ZHQW5pbWF0ZWRTdHJpbmcnO1xyXG5cdGNvbnN0IGhyZWYgPSBTdHJpbmcoc3ZnID8gKGEpLmhyZWYuYmFzZVZhbCA6IGEuaHJlZik7XHJcblxyXG5cdGlmIChocmVmID09PSBsb2NhdGlvbi5ocmVmKSB7XHJcblx0XHRpZiAoIWxvY2F0aW9uLmhhc2gpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHQvLyBJZ25vcmUgaWYgdGFnIGhhc1xyXG5cdC8vIDEuICdkb3dubG9hZCcgYXR0cmlidXRlXHJcblx0Ly8gMi4gcmVsPSdleHRlcm5hbCcgYXR0cmlidXRlXHJcblx0aWYgKGEuaGFzQXR0cmlidXRlKCdkb3dubG9hZCcpIHx8IGEuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2V4dGVybmFsJykgcmV0dXJuO1xyXG5cclxuXHQvLyBJZ25vcmUgaWYgPGE+IGhhcyBhIHRhcmdldFxyXG5cdGlmIChzdmcgPyAoYSkudGFyZ2V0LmJhc2VWYWwgOiBhLnRhcmdldCkgcmV0dXJuO1xyXG5cclxuXHRjb25zdCB1cmwgPSBuZXcgVVJMKGhyZWYpO1xyXG5cclxuXHQvLyBEb24ndCBoYW5kbGUgaGFzaCBjaGFuZ2VzXHJcblx0aWYgKHVybC5wYXRobmFtZSA9PT0gbG9jYXRpb24ucGF0aG5hbWUgJiYgdXJsLnNlYXJjaCA9PT0gbG9jYXRpb24uc2VhcmNoKSByZXR1cm47XHJcblxyXG5cdGNvbnN0IHRhcmdldCA9IHNlbGVjdF90YXJnZXQodXJsKTtcclxuXHRpZiAodGFyZ2V0KSB7XHJcblx0XHRjb25zdCBub3Njcm9sbCA9IGEuaGFzQXR0cmlidXRlKCdzYXBwZXItbm9zY3JvbGwnKTtcclxuXHRcdG5hdmlnYXRlKHRhcmdldCwgbnVsbCwgbm9zY3JvbGwsIHVybC5oYXNoKTtcclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRfaGlzdG9yeS5wdXNoU3RhdGUoeyBpZDogY2lkIH0sICcnLCB1cmwuaHJlZik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB3aGljaChldmVudCkge1xyXG5cdHJldHVybiBldmVudC53aGljaCA9PT0gbnVsbCA/IGV2ZW50LmJ1dHRvbiA6IGV2ZW50LndoaWNoO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kX2FuY2hvcihub2RlKSB7XHJcblx0d2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQScpIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7IC8vIFNWRyA8YT4gZWxlbWVudHMgaGF2ZSBhIGxvd2VyY2FzZSBuYW1lXHJcblx0cmV0dXJuIG5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhhbmRsZV9wb3BzdGF0ZShldmVudCkge1xyXG5cdHNjcm9sbF9oaXN0b3J5W2NpZF0gPSBzY3JvbGxfc3RhdGUoKTtcclxuXHJcblx0aWYgKGV2ZW50LnN0YXRlKSB7XHJcblx0XHRjb25zdCB1cmwgPSBuZXcgVVJMKGxvY2F0aW9uLmhyZWYpO1xyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gc2VsZWN0X3RhcmdldCh1cmwpO1xyXG5cdFx0aWYgKHRhcmdldCkge1xyXG5cdFx0XHRuYXZpZ2F0ZSh0YXJnZXQsIGV2ZW50LnN0YXRlLmlkKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxvY2F0aW9uLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHQvLyBoYXNoY2hhbmdlXHJcblx0XHRzZXRfdWlkKHVpZCArIDEpO1xyXG5cdFx0c2V0X2NpZCh1aWQpO1xyXG5cdFx0X2hpc3RvcnkucmVwbGFjZVN0YXRlKHsgaWQ6IGNpZCB9LCAnJywgbG9jYXRpb24uaHJlZik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBwcmVmZXRjaFJvdXRlcyhwYXRobmFtZXMpIHtcclxuXHRyZXR1cm4gcm91dGVzXHJcblx0XHQuZmlsdGVyKHBhdGhuYW1lc1xyXG5cdFx0XHQ/IHJvdXRlID0+IHBhdGhuYW1lcy5zb21lKHBhdGhuYW1lID0+IHJvdXRlLnBhdHRlcm4udGVzdChwYXRobmFtZSkpXHJcblx0XHRcdDogKCkgPT4gdHJ1ZVxyXG5cdFx0KVxyXG5cdFx0LnJlZHVjZSgocHJvbWlzZSwgcm91dGUpID0+IHByb21pc2UudGhlbigoKSA9PiB7XHJcblx0XHRcdHJldHVybiBQcm9taXNlLmFsbChyb3V0ZS5wYXJ0cy5tYXAocGFydCA9PiBwYXJ0ICYmIGxvYWRfY29tcG9uZW50KGNvbXBvbmVudHNbcGFydC5pXSkpKTtcclxuXHRcdH0pLCBQcm9taXNlLnJlc29sdmUoKSk7XHJcbn1cclxuXHJcbmNvbnN0IHN0b3JlcyQxID0gKCkgPT4gZ2V0Q29udGV4dChDT05URVhUX0tFWSk7XHJcblxyXG5leHBvcnQgeyBnb3RvLCBwcmVmZXRjaCwgcHJlZmV0Y2hSb3V0ZXMsIHN0YXJ0LCBzdG9yZXMkMSBhcyBzdG9yZXMgfTtcclxuIl0sIm5hbWVzIjpbInN0b3JlcyIsIkVycm9yQ29tcG9uZW50Iiwicm9vdF9wcmVsb2FkIl0sIm1hcHBpbmdzIjoiOzs7O0FBRU8sTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDOztBQUU5QixBQUFPLE1BQU0sT0FBTyxHQUFHLE9BQU8sRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FDQ29ETSxDQUFDLEdBQUcsR0FBRzs7Ozs7Ozs7Ozs7OztzQ0FBUCxDQUFDLEdBQUcsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQUZ6QyxPQUFPOztzQkFNUCxDQUFDLElBQUksR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQU5SLE9BQU87Ozs7Ozs7Ozs7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
