import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_store, r as component_subscribe, L as getContext, e as element, E as text, l as space, c as claim_element, a as children, F as claim_text, b as detach_dev, p as claim_space, f as attr_dev, h as add_location, T as listen_dev, j as insert_dev, k as append_dev, H as set_data_dev, n as noop, U as run_all, G as globals, g as set_style, _ as set_input_value, w as mount_component, A as group_outros, y as transition_out, B as check_outros, x as transition_in, a1 as prop_dev, z as destroy_component, Y as createEventDispatcher, a8 as prevent_default, W as add_render_callback, o as onMount, m as empty, Q as toggle_class, V as binding_callbacks, a4 as bind, a5 as add_flush_callback } from './index.4e52d202.js';
import './index.ad9ca859.js';
import { a as stores$1, g as goto } from './app.623f0ee4.js';
import { b as Icon } from './index.abf9c6bd.js';
import { R as Repl } from './Repl.f1ddc62a.js';
import { I as InputOutputToggle } from './InputOutputToggle.cf9a1ce1.js';

/* src\routes\repl\[id]\_components\AppControls\UserMenu.svelte generated by Svelte v3.12.0 */

const file = "src\\routes\\repl\\[id]\\_components\\AppControls\\UserMenu.svelte";

// (18:1) {#if showMenu}
function create_if_block(ctx) {
	var div, a, t0, t1, button, t2, dispose;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t0 = text("Your saved apps");
			t1 = space();
			button = element("button");
			t2 = text("Log out");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			a = claim_element(div_nodes, "A", { href: true, class: true }, false);
			var a_nodes = children(a);

			t0 = claim_text(a_nodes, "Your saved apps");
			a_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);

			button = claim_element(div_nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			t2 = claim_text(button_nodes, "Log out");
			button_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "href", "apps");
			attr_dev(a, "class", "svelte-1741g67");
			add_location(a, file, 19, 3, 498);
			attr_dev(button, "class", "svelte-1741g67");
			add_location(button, file, 20, 3, 537);
			attr_dev(div, "class", "menu svelte-1741g67");
			add_location(div, file, 18, 2, 475);
			dispose = listen_dev(button, "click", ctx.logout);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t0);
			append_dev(div, t1);
			append_dev(div, button);
			append_dev(button, t2);
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(18:1) {#if showMenu}", ctx });
	return block;
}

function create_fragment(ctx) {
	var div, span, t0, t1, img, img_alt_value, img_src_value, t2, dispose;

	var if_block = (ctx.showMenu) && create_if_block(ctx);

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text(ctx.name);
			t1 = space();
			img = element("img");
			t2 = space();
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			span = claim_element(div_nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t0 = claim_text(span_nodes, ctx.name);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);

			img = claim_element(div_nodes, "IMG", { alt: true, src: true, class: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "svelte-1741g67");
			add_location(span, file, 14, 1, 376);
			attr_dev(img, "alt", img_alt_value = "" + ctx.name + " avatar");
			attr_dev(img, "src", img_src_value = ctx.$session.user.avatar);
			attr_dev(img, "class", "svelte-1741g67");
			add_location(img, file, 15, 1, 398);
			attr_dev(div, "class", "user svelte-1741g67");
			add_location(div, file, 13, 0, 274);

			dispose = [
				listen_dev(div, "mouseenter", ctx.mouseenter_handler),
				listen_dev(div, "mouseleave", ctx.mouseleave_handler)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, span);
			append_dev(span, t0);
			append_dev(div, t1);
			append_dev(div, img);
			append_dev(div, t2);
			if (if_block) if_block.m(div, null);
		},

		p: function update(changed, ctx) {
			if (changed.name) {
				set_data_dev(t0, ctx.name);
			}

			if ((changed.name) && img_alt_value !== (img_alt_value = "" + ctx.name + " avatar")) {
				attr_dev(img, "alt", img_alt_value);
			}

			if ((changed.$session) && img_src_value !== (img_src_value = ctx.$session.user.avatar)) {
				attr_dev(img, "src", img_src_value);
			}

			if (ctx.showMenu) {
				if (!if_block) {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			if (if_block) if_block.d();
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $session;

	
	const { session } = stores$1(); validate_store(session, 'session'); component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

	const { logout } = getContext('app');

	let showMenu = false;
	let name;

	const mouseenter_handler = () => $$invalidate('showMenu', showMenu = true);

	const mouseleave_handler = () => $$invalidate('showMenu', showMenu = false);

	$$self.$capture_state = () => {
		return {};
	};

	$$self.$inject_state = $$props => {
		if ('showMenu' in $$props) $$invalidate('showMenu', showMenu = $$props.showMenu);
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('$session' in $$props) session.set($session);
	};

	$$self.$$.update = ($$dirty = { $session: 1 }) => {
		if ($$dirty.$session) { $$invalidate('name', name = $session.user.name || $session.user.username); }
	};

	return {
		session,
		logout,
		showMenu,
		name,
		$session,
		mouseenter_handler,
		mouseleave_handler
	};
}

class UserMenu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, []);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "UserMenu", options, id: create_fragment.name });
	}
}

const table = [];
for (let n = 0; n < 256; n++) {
	let c = n;
	for (let k = 0; k < 8; k++) {
		c = c & 1 ? 0xEDB88320 ^ (c >>> 1) : c >>> 1;
	}
	table[n] = c;
}

var crc32 = bytes => {
	let sum = -1;
	for (const byte of bytes) {
		sum = (sum >>> 8) ^ table[(sum ^ byte) & 0xFF];
	}
	return sum ^ -1;
};

const int = (n, length) => {
	const out = [];
	while (length--) {
		out.push(n & 0xFF);
		n >>>= 8;
	}
	return out;
};

const toBytes = data => typeof data === 'string' ? [...data].map(char => char.charCodeAt(0)) : data;

var toArray = files => {
	let fileData = [];
	const centralDirectory = [];
	for (const { path, data } of files) {
		const dataBytes = toBytes(data);
		const pathBytes = toBytes(path);
		const commonHeader = [0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...int(crc32(dataBytes), 4), ...int(dataBytes.length, 4), ...int(dataBytes.length, 4), ...int(pathBytes.length, 2), 0x00, 0x00];
		centralDirectory.push(0x50, 0x4B, 0x01, 0x02, 0x14, 0x00, ...commonHeader, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, ...int(fileData.length, 4), ...pathBytes);
		fileData = [...fileData, 0x50, 0x4B, 0x03, 0x04, ...commonHeader, ...pathBytes, ...dataBytes];
	}
	return [...fileData, ...centralDirectory, 0x50, 0x4B, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, ...int(files.length, 2), ...int(files.length, 2), ...int(centralDirectory.length, 4), ...int(fileData.length, 4), 0x00, 0x00];
};

var toBlob = files => new Blob([Uint8Array.from(toArray(files))], { type: 'application/zip' });

var downloadBlob = (blob, filename) => {
	const url = URL.createObjectURL(blob);
	const link = document.createElement('a');
	link.href = url;
	link.download = filename;
	link.style.display = 'none';
	document.body.appendChild(link);
	link.click();
	URL.revokeObjectURL(url);
	link.remove();
};

function keyEvent(code) {
	return function (node, callback) {
		node.addEventListener('keydown', handleKeydown);

		function handleKeydown(event) {
			if (event.keyCode === code) {
				callback.call(this, event);
			}
		}

		return {
			destroy() {
				node.removeEventListener('keydown', handleKeydown);
			}
		};
	};
}

const enter = keyEvent(13);

const isMac = typeof navigator !== 'undefined' && navigator.platform === 'MacIntel';

/* src\routes\repl\[id]\_components\AppControls\index.svelte generated by Svelte v3.12.0 */
const { Error: Error_1 } = globals;

const file$1 = "src\\routes\\repl\\[id]\\_components\\AppControls\\index.svelte";

// (181:3) {:else}
function create_else_block_3(ctx) {
	var current;

	var icon = new Icon({
		props: { name: "maximize" },
		$$inline: true
	});

	const block = {
		c: function create() {
			icon.$$.fragment.c();
		},

		l: function claim(nodes) {
			icon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block_3.name, type: "else", source: "(181:3) {:else}", ctx });
	return block;
}

// (179:3) {#if zen_mode}
function create_if_block_3(ctx) {
	var current;

	var icon = new Icon({ props: { name: "close" }, $$inline: true });

	const block = {
		c: function create() {
			icon.$$.fragment.c();
		},

		l: function claim(nodes) {
			icon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_3.name, type: "if", source: "(179:3) {#if zen_mode}", ctx });
	return block;
}

// (193:3) {:else}
function create_else_block_2(ctx) {
	var current;

	var icon = new Icon({
		props: { name: "git-branch" },
		$$inline: true
	});

	const block = {
		c: function create() {
			icon.$$.fragment.c();
		},

		l: function claim(nodes) {
			icon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block_2.name, type: "else", source: "(193:3) {:else}", ctx });
	return block;
}

// (191:3) {#if justForked}
function create_if_block_2(ctx) {
	var current;

	var icon = new Icon({ props: { name: "check" }, $$inline: true });

	const block = {
		c: function create() {
			icon.$$.fragment.c();
		},

		l: function claim(nodes) {
			icon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(191:3) {#if justForked}", ctx });
	return block;
}

// (201:3) {:else}
function create_else_block_1(ctx) {
	var current;

	var icon = new Icon({ props: { name: "save" }, $$inline: true });

	const block = {
		c: function create() {
			icon.$$.fragment.c();
		},

		l: function claim(nodes) {
			icon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block_1.name, type: "else", source: "(201:3) {:else}", ctx });
	return block;
}

// (199:3) {#if justSaved}
function create_if_block_1(ctx) {
	var current;

	var icon = new Icon({ props: { name: "check" }, $$inline: true });

	const block = {
		c: function create() {
			icon.$$.fragment.c();
		},

		l: function claim(nodes) {
			icon.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(icon, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(199:3) {#if justSaved}", ctx });
	return block;
}

// (208:2) {:else}
function create_else_block(ctx) {
	var button, t0, span, t1, current, dispose;

	var icon = new Icon({
		props: { name: "log-in" },
		$$inline: true
	});

	const block = {
		c: function create() {
			button = element("button");
			icon.$$.fragment.c();
			t0 = space();
			span = element("span");
			t1 = text(" Log in to save");
			this.h();
		},

		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			icon.$$.fragment.l(button_nodes);
			t0 = claim_space(button_nodes);

			span = claim_element(button_nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t1 = claim_text(span_nodes, " Log in to save");
			span_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(span, "class", "svelte-1ez15pl");
			add_location(span, file$1, 210, 4, 5225);
			attr_dev(button, "class", "icon svelte-1ez15pl");
			add_location(button, file$1, 208, 3, 5138);
			dispose = listen_dev(button, "click", prevent_default(ctx.login), false, true);
		},

		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			mount_component(icon, button, null);
			append_dev(button, t0);
			append_dev(button, span);
			append_dev(span, t1);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}

			destroy_component(icon);

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(208:2) {:else}", ctx });
	return block;
}

// (206:2) {#if $session.user}
function create_if_block$1(ctx) {
	var current;

	var usermenu = new UserMenu({ $$inline: true });

	const block = {
		c: function create() {
			usermenu.$$.fragment.c();
		},

		l: function claim(nodes) {
			usermenu.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(usermenu, target, anchor);
			current = true;
		},

		i: function intro(local) {
			if (current) return;
			transition_in(usermenu.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(usermenu.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(usermenu, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$1.name, type: "if", source: "(206:2) {#if $session.user}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var div1, input, enter_action, t0, div0, button0, current_block_type_index, if_block0, t1, button1, t2, button2, current_block_type_index_1, if_block1, button2_disabled_value, t3, button3, current_block_type_index_2, if_block2, button3_disabled_value, t4, current_block_type_index_3, if_block3, current, dispose;

	var if_block_creators = [
		create_if_block_3,
		create_else_block_3
	];

	var if_blocks = [];

	function select_block_type(changed, ctx) {
		if (ctx.zen_mode) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(null, ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	var icon = new Icon({
		props: { name: "download" },
		$$inline: true
	});

	var if_block_creators_1 = [
		create_if_block_2,
		create_else_block_2
	];

	var if_blocks_1 = [];

	function select_block_type_1(changed, ctx) {
		if (ctx.justForked) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(null, ctx);
	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

	var if_block_creators_2 = [
		create_if_block_1,
		create_else_block_1
	];

	var if_blocks_2 = [];

	function select_block_type_2(changed, ctx) {
		if (ctx.justSaved) return 0;
		return 1;
	}

	current_block_type_index_2 = select_block_type_2(null, ctx);
	if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

	var if_block_creators_3 = [
		create_if_block$1,
		create_else_block
	];

	var if_blocks_3 = [];

	function select_block_type_3(changed, ctx) {
		if (ctx.$session.user) return 0;
		return 1;
	}

	current_block_type_index_3 = select_block_type_3(null, ctx);
	if_block3 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			input = element("input");
			t0 = space();
			div0 = element("div");
			button0 = element("button");
			if_block0.c();
			t1 = space();
			button1 = element("button");
			icon.$$.fragment.c();
			t2 = space();
			button2 = element("button");
			if_block1.c();
			t3 = space();
			button3 = element("button");
			if_block2.c();
			t4 = space();
			if_block3.c();
			this.h();
		},

		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			input = claim_element(div1_nodes, "INPUT", { class: true }, false);
			var input_nodes = children(input);

			input_nodes.forEach(detach_dev);
			t0 = claim_space(div1_nodes);

			div0 = claim_element(div1_nodes, "DIV", { style: true }, false);
			var div0_nodes = children(div0);

			button0 = claim_element(div0_nodes, "BUTTON", { class: true, title: true }, false);
			var button0_nodes = children(button0);

			if_block0.l(button0_nodes);
			button0_nodes.forEach(detach_dev);
			t1 = claim_space(div0_nodes);

			button1 = claim_element(div0_nodes, "BUTTON", { class: true, disabled: true, title: true }, false);
			var button1_nodes = children(button1);

			icon.$$.fragment.l(button1_nodes);
			button1_nodes.forEach(detach_dev);
			t2 = claim_space(div0_nodes);

			button2 = claim_element(div0_nodes, "BUTTON", { class: true, disabled: true, title: true }, false);
			var button2_nodes = children(button2);

			if_block1.l(button2_nodes);
			button2_nodes.forEach(detach_dev);
			t3 = claim_space(div0_nodes);

			button3 = claim_element(div0_nodes, "BUTTON", { class: true, disabled: true, title: true }, false);
			var button3_nodes = children(button3);

			if_block2.l(button3_nodes);
			button3_nodes.forEach(detach_dev);
			t4 = claim_space(div0_nodes);
			if_block3.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(input, "class", "svelte-1ez15pl");
			add_location(input, file$1, 170, 1, 4153);
			attr_dev(button0, "class", "icon svelte-1ez15pl");
			attr_dev(button0, "title", "fullscreen editor");
			add_location(button0, file$1, 177, 2, 4321);
			attr_dev(button1, "class", "icon svelte-1ez15pl");
			button1.disabled = ctx.downloading;
			attr_dev(button1, "title", "download zip file");
			add_location(button1, file$1, 185, 2, 4525);
			attr_dev(button2, "class", "icon svelte-1ez15pl");
			button2.disabled = button2_disabled_value = ctx.saving || !ctx.$session.user;
			attr_dev(button2, "title", "fork");
			add_location(button2, file$1, 189, 2, 4663);
			attr_dev(button3, "class", "icon svelte-1ez15pl");
			button3.disabled = button3_disabled_value = ctx.saving || !ctx.$session.user;
			attr_dev(button3, "title", "save");
			add_location(button3, file$1, 197, 2, 4885);
			set_style(div0, "text-align", "right");
			set_style(div0, "margin-right", ".4rem");
			add_location(div0, file$1, 176, 1, 4266);
			attr_dev(div1, "class", "app-controls svelte-1ez15pl");
			add_location(div1, file$1, 169, 0, 4124);

			dispose = [
				listen_dev(window, "keydown", ctx.handleKeydown),
				listen_dev(input, "input", ctx.input_input_handler),
				listen_dev(input, "focus", focus_handler),
				listen_dev(button0, "click", ctx.click_handler),
				listen_dev(button1, "click", ctx.download),
				listen_dev(button2, "click", ctx.click_handler_1),
				listen_dev(button3, "click", ctx.save)
			];
		},

		m: function mount(target, anchor) {
			insert_dev(target, div1, anchor);
			append_dev(div1, input);

			set_input_value(input, ctx.name);

			enter_action = enter.call(null, input, enter_function) || {};
			append_dev(div1, t0);
			append_dev(div1, div0);
			append_dev(div0, button0);
			if_blocks[current_block_type_index].m(button0, null);
			append_dev(div0, t1);
			append_dev(div0, button1);
			mount_component(icon, button1, null);
			append_dev(div0, t2);
			append_dev(div0, button2);
			if_blocks_1[current_block_type_index_1].m(button2, null);
			append_dev(div0, t3);
			append_dev(div0, button3);
			if_blocks_2[current_block_type_index_2].m(button3, null);
			append_dev(div0, t4);
			if_blocks_3[current_block_type_index_3].m(div0, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if (changed.name && (input.value !== ctx.name)) set_input_value(input, ctx.name);

			var previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(changed, ctx);
			if (current_block_type_index !== previous_block_index) {
				group_outros();
				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});
				check_outros();

				if_block0 = if_blocks[current_block_type_index];
				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				}
				transition_in(if_block0, 1);
				if_block0.m(button0, null);
			}

			if (!current || changed.downloading) {
				prop_dev(button1, "disabled", ctx.downloading);
			}

			var previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(changed, ctx);
			if (current_block_type_index_1 !== previous_block_index_1) {
				group_outros();
				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});
				check_outros();

				if_block1 = if_blocks_1[current_block_type_index_1];
				if (!if_block1) {
					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block1.c();
				}
				transition_in(if_block1, 1);
				if_block1.m(button2, null);
			}

			if ((!current || changed.saving || changed.$session) && button2_disabled_value !== (button2_disabled_value = ctx.saving || !ctx.$session.user)) {
				prop_dev(button2, "disabled", button2_disabled_value);
			}

			var previous_block_index_2 = current_block_type_index_2;
			current_block_type_index_2 = select_block_type_2(changed, ctx);
			if (current_block_type_index_2 !== previous_block_index_2) {
				group_outros();
				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
					if_blocks_2[previous_block_index_2] = null;
				});
				check_outros();

				if_block2 = if_blocks_2[current_block_type_index_2];
				if (!if_block2) {
					if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
					if_block2.c();
				}
				transition_in(if_block2, 1);
				if_block2.m(button3, null);
			}

			if ((!current || changed.saving || changed.$session) && button3_disabled_value !== (button3_disabled_value = ctx.saving || !ctx.$session.user)) {
				prop_dev(button3, "disabled", button3_disabled_value);
			}

			var previous_block_index_3 = current_block_type_index_3;
			current_block_type_index_3 = select_block_type_3(changed, ctx);
			if (current_block_type_index_3 !== previous_block_index_3) {
				group_outros();
				transition_out(if_blocks_3[previous_block_index_3], 1, 1, () => {
					if_blocks_3[previous_block_index_3] = null;
				});
				check_outros();

				if_block3 = if_blocks_3[current_block_type_index_3];
				if (!if_block3) {
					if_block3 = if_blocks_3[current_block_type_index_3] = if_block_creators_3[current_block_type_index_3](ctx);
					if_block3.c();
				}
				transition_in(if_block3, 1);
				if_block3.m(div0, null);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);

			transition_in(icon.$$.fragment, local);

			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},

		o: function outro(local) {
			transition_out(if_block0);
			transition_out(icon.$$.fragment, local);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div1);
			}

			if (enter_action && typeof enter_action.destroy === 'function') enter_action.destroy();
			if_blocks[current_block_type_index].d();

			destroy_component(icon);

			if_blocks_1[current_block_type_index_1].d();
			if_blocks_2[current_block_type_index_2].d();
			if_blocks_3[current_block_type_index_3].d();
			run_all(dispose);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

function wait(ms) {
	return new Promise(f => setTimeout(f, ms));
}

const focus_handler = (e) => e.target.select();

const enter_function = (e) => e.target.blur();

function instance$1($$self, $$props, $$invalidate) {
	let $session;

	

	const dispatch = createEventDispatcher();
	const { session } = stores$1(); validate_store(session, 'session'); component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });
	const { login } = getContext('app');

	let { repl, gist, name, zen_mode, bundle } = $$props;

	let saving = false;
	let downloading = false;
	let justSaved = false;
	let justForked = false;

	function handleKeydown(event) {
		if (event.which === 83 && (isMac ? event.metaKey : event.ctrlKey)) {
			event.preventDefault();
			save();
		}
	}

	async function fork(intentWasSave) {
		$$invalidate('saving', saving = true);

		const { components } = repl.toJSON();

		try {
			const r = await fetch(`repl/create.json`, {
				method: 'POST',
				credentials: 'include',
				body: JSON.stringify({
					name,
					files: components.map(component => ({
						name: `${component.name}.${component.type}`,
						source: component.source
					}))
				})
			});

			if (r.status < 200 || r.status >= 300) {
				const { error } = await r.json();
				throw new Error(`Received an HTTP ${r.status} response: ${error}`);
			}

			const gist = await r.json();
			dispatch('forked', { gist });

			if (intentWasSave) {
				$$invalidate('justSaved', justSaved = true);
				await wait(600);
				$$invalidate('justSaved', justSaved = false);
			} else {
				$$invalidate('justForked', justForked = true);
				await wait(600);
				$$invalidate('justForked', justForked = false);
			}
		} catch (err) {
			if (navigator.onLine) {
				alert(err.message);
			} else {
				alert(`It looks like you're offline! Find the internet and try again`);
			}
		}

		$$invalidate('saving', saving = false);
	}

	async function save() {
		if (saving) return;

		if (!canSave) {
			fork(true);
			return;
		}

		$$invalidate('saving', saving = true);

		try {
			// Send all files back to API
			// ~> Any missing files are considered deleted!
			const { components } = repl.toJSON();

			const r = await fetch(`repl/${gist.uid}.json`, {
				method: 'PATCH',
				credentials: 'include',
				body: JSON.stringify({
					name,
					files: components.map(component => ({
						name: `${component.name}.${component.type}`,
						source: component.source
					}))
				})
			});

			if (r.status < 200 || r.status >= 300) {
				const { error } = await r.json();
				throw new Error(`Received an HTTP ${r.status} response: ${error}`);
			}

			await r.json();

			$$invalidate('justSaved', justSaved = true);
			await wait(600);
			$$invalidate('justSaved', justSaved = false);
		} catch (err) {
			if (navigator.onLine) {
				alert(err.message);
			} else {
				alert(`It looks like you're offline! Find the internet and try again`);
			}
		}

		$$invalidate('saving', saving = false);
	}

	async function download() {
		$$invalidate('downloading', downloading = true);

		const { components, imports } = repl.toJSON();

		const files = await (await fetch('/svelte-app.json')).json();

		if (imports.length > 0) {
			const idx = files.findIndex(({ path }) => path === 'package.json');
			const pkg = JSON.parse(files[idx].data);
			const { devDependencies } = pkg;
			imports.forEach(mod => {
				const match = /^(@[^/]+\/)?[^@/]+/.exec(mod);
				devDependencies[match[0]] = 'latest';
			});
			pkg.devDependencies = devDependencies;
			files[idx].data = JSON.stringify(pkg, null, '  ');
		}

		files.push(...components.map(component => ({ path: `src/${component.name}.${component.type}`, data: component.source })));
		files.push({
			path: `src/main.js`, data: `import App from './App.svelte';

var app = new App({
	target: document.body
});

export default app;` });

		downloadBlob(toBlob(files), 'svelte-app.zip');

		$$invalidate('downloading', downloading = false);
	}

	const writable_props = ['repl', 'gist', 'name', 'zen_mode', 'bundle'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		name = this.value;
		$$invalidate('name', name);
	}

	const click_handler = () => $$invalidate('zen_mode', zen_mode = !zen_mode);

	const click_handler_1 = () => fork(false);

	$$self.$set = $$props => {
		if ('repl' in $$props) $$invalidate('repl', repl = $$props.repl);
		if ('gist' in $$props) $$invalidate('gist', gist = $$props.gist);
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('zen_mode' in $$props) $$invalidate('zen_mode', zen_mode = $$props.zen_mode);
		if ('bundle' in $$props) $$invalidate('bundle', bundle = $$props.bundle);
	};

	$$self.$capture_state = () => {
		return { repl, gist, name, zen_mode, bundle, saving, downloading, justSaved, justForked, canSave, $session };
	};

	$$self.$inject_state = $$props => {
		if ('repl' in $$props) $$invalidate('repl', repl = $$props.repl);
		if ('gist' in $$props) $$invalidate('gist', gist = $$props.gist);
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('zen_mode' in $$props) $$invalidate('zen_mode', zen_mode = $$props.zen_mode);
		if ('bundle' in $$props) $$invalidate('bundle', bundle = $$props.bundle);
		if ('saving' in $$props) $$invalidate('saving', saving = $$props.saving);
		if ('downloading' in $$props) $$invalidate('downloading', downloading = $$props.downloading);
		if ('justSaved' in $$props) $$invalidate('justSaved', justSaved = $$props.justSaved);
		if ('justForked' in $$props) $$invalidate('justForked', justForked = $$props.justForked);
		if ('canSave' in $$props) canSave = $$props.canSave;
		if ('$session' in $$props) session.set($session);
	};

	let canSave;

	$$self.$$.update = ($$dirty = { $session: 1, gist: 1 }) => {
		if ($$dirty.$session || $$dirty.gist) { canSave = $session.user && gist && gist.owner === $session.user.uid; }
	};

	return {
		session,
		login,
		repl,
		gist,
		name,
		zen_mode,
		bundle,
		saving,
		downloading,
		justSaved,
		justForked,
		handleKeydown,
		fork,
		save,
		download,
		$session,
		input_input_handler,
		click_handler,
		click_handler_1
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["repl", "gist", "name", "zen_mode", "bundle"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.repl === undefined && !('repl' in props)) {
			console.warn("<Index> was created without expected prop 'repl'");
		}
		if (ctx.gist === undefined && !('gist' in props)) {
			console.warn("<Index> was created without expected prop 'gist'");
		}
		if (ctx.name === undefined && !('name' in props)) {
			console.warn("<Index> was created without expected prop 'name'");
		}
		if (ctx.zen_mode === undefined && !('zen_mode' in props)) {
			console.warn("<Index> was created without expected prop 'zen_mode'");
		}
		if (ctx.bundle === undefined && !('bundle' in props)) {
			console.warn("<Index> was created without expected prop 'bundle'");
		}
	}

	get repl() {
		throw new Error_1("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set repl(value) {
		throw new Error_1("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get gist() {
		throw new Error_1("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set gist(value) {
		throw new Error_1("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error_1("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error_1("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get zen_mode() {
		throw new Error_1("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set zen_mode(value) {
		throw new Error_1("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bundle() {
		throw new Error_1("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bundle(value) {
		throw new Error_1("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\repl\[id]\index.svelte generated by Svelte v3.12.0 */
const { console: console_1, window: window_1 } = globals;

const file$2 = "src\\routes\\repl\\[id]\\index.svelte";

// (206:1) {#if true}
function create_if_block$2(ctx) {
	var div, t, if_block_anchor, current;

	let repl_1_props = {
		workersUrl: "workers",
		svelteUrl: ctx.svelteUrl,
		rollupUrl: ctx.rollupUrl,
		relaxed: ctx.relaxed,
		fixed: ctx.mobile,
		injectedJS: ctx.mapbox_setup
	};
	var repl_1 = new Repl({ props: repl_1_props, $$inline: true });

	ctx.repl_1_binding(repl_1);

	var if_block = (ctx.mobile) && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			repl_1.$$.fragment.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			repl_1.$$.fragment.l(div_nodes);
			div_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr_dev(div, "class", "viewport svelte-1jnlh7l");
			toggle_class(div, "offset", ctx.checked);
			add_location(div, file$2, 206, 2, 4763);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			mount_component(repl_1, div, null);
			insert_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var repl_1_changes = {};
			if (changed.svelteUrl) repl_1_changes.svelteUrl = ctx.svelteUrl;
			if (changed.relaxed) repl_1_changes.relaxed = ctx.relaxed;
			if (changed.mobile) repl_1_changes.fixed = ctx.mobile;
			repl_1.$set(repl_1_changes);

			if (changed.checked) {
				toggle_class(div, "offset", ctx.checked);
			}

			if (ctx.mobile) {
				if (if_block) {
					if_block.p(changed, ctx);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();
				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(repl_1.$$.fragment, local);

			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(repl_1.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}

			ctx.repl_1_binding(null);

			destroy_component(repl_1);

			if (detaching) {
				detach_dev(t);
			}

			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block$2.name, type: "if", source: "(206:1) {#if true}", ctx });
	return block;
}

// (219:2) {#if mobile}
function create_if_block_1$1(ctx) {
	var updating_checked, current;

	function inputoutputtoggle_checked_binding(value) {
		ctx.inputoutputtoggle_checked_binding.call(null, value);
		updating_checked = true;
		add_flush_callback(() => updating_checked = false);
	}

	let inputoutputtoggle_props = {};
	if (ctx.checked !== void 0) {
		inputoutputtoggle_props.checked = ctx.checked;
	}
	var inputoutputtoggle = new InputOutputToggle({
		props: inputoutputtoggle_props,
		$$inline: true
	});

	binding_callbacks.push(() => bind(inputoutputtoggle, 'checked', inputoutputtoggle_checked_binding));

	const block = {
		c: function create() {
			inputoutputtoggle.$$.fragment.c();
		},

		l: function claim(nodes) {
			inputoutputtoggle.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(inputoutputtoggle, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var inputoutputtoggle_changes = {};
			if (!updating_checked && changed.checked) {
				inputoutputtoggle_changes.checked = ctx.checked;
			}
			inputoutputtoggle.$set(inputoutputtoggle_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(inputoutputtoggle.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(inputoutputtoggle.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(inputoutputtoggle, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1$1.name, type: "if", source: "(219:2) {#if mobile}", ctx });
	return block;
}

function create_fragment$2(ctx) {
	var title_value, meta0, meta1, meta2, t0, div, updating_name, updating_zen_mode, t1, div_class_value, current, dispose;

	add_render_callback(ctx.onwindowresize);

	document.title = title_value = "" + ctx.name + " • REPL • Svelte";

	function appcontrols_name_binding(value) {
		ctx.appcontrols_name_binding.call(null, value);
		updating_name = true;
		add_flush_callback(() => updating_name = false);
	}

	function appcontrols_zen_mode_binding(value_1) {
		ctx.appcontrols_zen_mode_binding.call(null, value_1);
		updating_zen_mode = true;
		add_flush_callback(() => updating_zen_mode = false);
	}

	let appcontrols_props = { gist: ctx.gist, repl: ctx.repl };
	if (ctx.name !== void 0) {
		appcontrols_props.name = ctx.name;
	}
	if (ctx.zen_mode !== void 0) {
		appcontrols_props.zen_mode = ctx.zen_mode;
	}
	var appcontrols = new Index({ props: appcontrols_props, $$inline: true });

	binding_callbacks.push(() => bind(appcontrols, 'name', appcontrols_name_binding));
	binding_callbacks.push(() => bind(appcontrols, 'zen_mode', appcontrols_zen_mode_binding));
	appcontrols.$on("forked", ctx.handle_fork);

	var if_block =  create_if_block$2(ctx);

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t0 = space();
			div = element("div");
			appcontrols.$$.fragment.c();
			t1 = space();
			if (if_block) if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			meta0 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta0_nodes = children(meta0);

			meta0_nodes.forEach(detach_dev);

			meta1 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta1_nodes = children(meta1);

			meta1_nodes.forEach(detach_dev);

			meta2 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta2_nodes = children(meta2);

			meta2_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			appcontrols.$$.fragment.l(div_nodes);
			t1 = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte REPL");
			add_location(meta0, file$2, 189, 1, 4321);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", "Cybernetically enhanced web apps");
			add_location(meta1, file$2, 190, 1, 4373);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", "Interactive Svelte playground");
			add_location(meta2, file$2, 191, 1, 4452);
			attr_dev(div, "class", div_class_value = "repl-outer " + (ctx.zen_mode ? 'zen-mode' : '') + " svelte-1jnlh7l");
			toggle_class(div, "mobile", ctx.mobile);
			add_location(div, file$2, 196, 0, 4581);
			dispose = listen_dev(window_1, "resize", ctx.onwindowresize);
		},

		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t0, anchor);
			insert_dev(target, div, anchor);
			mount_component(appcontrols, div, null);
			append_dev(div, t1);
			if (if_block) if_block.m(div, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.name) && title_value !== (title_value = "" + ctx.name + " • REPL • Svelte")) {
				document.title = title_value;
			}

			var appcontrols_changes = {};
			if (changed.gist) appcontrols_changes.gist = ctx.gist;
			if (changed.repl) appcontrols_changes.repl = ctx.repl;
			if (!updating_name && changed.name) {
				appcontrols_changes.name = ctx.name;
			}
			if (!updating_zen_mode && changed.zen_mode) {
				appcontrols_changes.zen_mode = ctx.zen_mode;
			}
			appcontrols.$set(appcontrols_changes);

			if_block.p(changed, ctx);

			if ((!current || changed.zen_mode) && div_class_value !== (div_class_value = "repl-outer " + (ctx.zen_mode ? 'zen-mode' : '') + " svelte-1jnlh7l")) {
				attr_dev(div, "class", div_class_value);
			}

			if ((changed.zen_mode || changed.mobile)) {
				toggle_class(div, "mobile", ctx.mobile);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(appcontrols.$$.fragment, local);

			transition_in(if_block);
			current = true;
		},

		o: function outro(local) {
			transition_out(appcontrols.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},

		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);

			if (detaching) {
				detach_dev(t0);
				detach_dev(div);
			}

			destroy_component(appcontrols);

			if (if_block) if_block.d();
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$2.name, type: "component", source: "", ctx });
	return block;
}

function preload({ params, query }) {
	return {
		version: query.version || '3',
		id: params.id
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let $session;

	

	let { version, id } = $$props;

	const { session } = stores$1(); validate_store(session, 'session'); component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

	let repl;
	let gist;
	let name = 'Loading...';
	let zen_mode = false;
	let is_relaxed_gist = false;
	let width =  window.innerWidth ;
	let checked = false;

	function update_query_string(version) {
		const params = [];

		if (version !== 'latest') params.push(`version=${version}`);

		const url = params.length > 0
			? `repl/${id}?${params.join('&')}`
			: `repl/${id}`;

		history.replaceState({}, 'x', url);
	}

	function fetch_gist(id) {
		if (gist && gist.uid === id) {
			// if the id changed because we just forked, don't refetch
			return;
		}

		// TODO handle `relaxed` logic
		fetch(`repl/${id}.json`).then(r => {
			if (r.ok) {
				r.json().then(data => {
					$$invalidate('gist', gist = data);
					$$invalidate('name', name = data.name);

					$$invalidate('is_relaxed_gist', is_relaxed_gist = data.relaxed);

					const components = data.files.map(file => {
						let [name, type] = file.name.split('.');
						if (type === 'html') type = 'svelte'; // TODO do this on the server
						return { name, type, source: file.source };
					});

					components.sort((a, b) => {
						if (a.name === 'App' && a.type === 'svelte') return -1;
						if (b.name === 'App' && b.type === 'svelte') return 1;

						if (a.type !== b.type) return a.type === 'svelte' ? -1 : 1;

						return a.name < b.name ? -1 : 1;
					});

					repl.set({ components });
				});
			} else {
				console.warn('TODO: 404 Gist');
			}
		});
	}

	onMount(() => {
		if (version !== 'local') {
			fetch(`https://unpkg.com/svelte@${version || '3'}/package.json`)
				.then(r => r.json())
				.then(pkg => {
					$$invalidate('version', version = pkg.version);
				});
		}
	});

	function handle_fork(event) {
		console.log('> handle_fork', event);
		$$invalidate('gist', gist = event.detail.gist);
		goto(`/repl/${gist.uid}?version=${version}`);
	}

	const rollupUrl = `https://unpkg.com/rollup@1/dist/rollup.browser.js`;

	// needed for context API example
	const mapbox_setup = `window.MAPBOX_ACCESS_TOKEN = undefined;`;

	const writable_props = ['version', 'id'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1.warn(`<Index> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		width = window_1.innerWidth; $$invalidate('width', width);
	}

	function appcontrols_name_binding(value) {
		name = value;
		$$invalidate('name', name);
	}

	function appcontrols_zen_mode_binding(value_1) {
		zen_mode = value_1;
		$$invalidate('zen_mode', zen_mode);
	}

	function repl_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('repl', repl = $$value);
		});
	}

	function inputoutputtoggle_checked_binding(value) {
		checked = value;
		$$invalidate('checked', checked);
	}

	$$self.$set = $$props => {
		if ('version' in $$props) $$invalidate('version', version = $$props.version);
		if ('id' in $$props) $$invalidate('id', id = $$props.id);
	};

	$$self.$capture_state = () => {
		return { version, id, repl, gist, name, zen_mode, is_relaxed_gist, width, checked, svelteUrl, mobile, relaxed, $session };
	};

	$$self.$inject_state = $$props => {
		if ('version' in $$props) $$invalidate('version', version = $$props.version);
		if ('id' in $$props) $$invalidate('id', id = $$props.id);
		if ('repl' in $$props) $$invalidate('repl', repl = $$props.repl);
		if ('gist' in $$props) $$invalidate('gist', gist = $$props.gist);
		if ('name' in $$props) $$invalidate('name', name = $$props.name);
		if ('zen_mode' in $$props) $$invalidate('zen_mode', zen_mode = $$props.zen_mode);
		if ('is_relaxed_gist' in $$props) $$invalidate('is_relaxed_gist', is_relaxed_gist = $$props.is_relaxed_gist);
		if ('width' in $$props) $$invalidate('width', width = $$props.width);
		if ('checked' in $$props) $$invalidate('checked', checked = $$props.checked);
		if ('svelteUrl' in $$props) $$invalidate('svelteUrl', svelteUrl = $$props.svelteUrl);
		if ('mobile' in $$props) $$invalidate('mobile', mobile = $$props.mobile);
		if ('relaxed' in $$props) $$invalidate('relaxed', relaxed = $$props.relaxed);
		if ('$session' in $$props) session.set($session);
	};

	let svelteUrl, mobile, relaxed;

	$$self.$$.update = ($$dirty = { version: 1, id: 1, width: 1, is_relaxed_gist: 1, $session: 1, gist: 1 }) => {
		if ($$dirty.version) { if (typeof history !== 'undefined') update_query_string(version); }
		if ($$dirty.id) { fetch_gist(id); }
		if ($$dirty.version) { $$invalidate('svelteUrl', svelteUrl =  version === 'local' ?
				`${location.origin}/repl/local` :
				`https://unpkg.com/svelte@${version}`); }
		if ($$dirty.width) { $$invalidate('mobile', mobile = width < 540); }
		if ($$dirty.is_relaxed_gist || $$dirty.$session || $$dirty.gist) { $$invalidate('relaxed', relaxed = is_relaxed_gist || ($session.user && gist && $session.user.uid === gist.owner)); }
	};

	return {
		version,
		id,
		session,
		repl,
		gist,
		name,
		zen_mode,
		width,
		checked,
		handle_fork,
		rollupUrl,
		mapbox_setup,
		svelteUrl,
		mobile,
		relaxed,
		onwindowresize,
		appcontrols_name_binding,
		appcontrols_zen_mode_binding,
		repl_1_binding,
		inputoutputtoggle_checked_binding
	};
}

class Index$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["version", "id"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$2.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.version === undefined && !('version' in props)) {
			console_1.warn("<Index> was created without expected prop 'version'");
		}
		if (ctx.id === undefined && !('id' in props)) {
			console_1.warn("<Index> was created without expected prop 'id'");
		}
	}

	get version() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set version(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Index$1;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNzlmOWI4YmIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvcmVwbC9baWRdL19jb21wb25lbnRzL0FwcENvbnRyb2xzL1VzZXJNZW51LnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9kby1ub3QtemlwL2Rpc3QvaW5kZXguZXMuanMiLCIuLi8uLi8uLi9zcmMvcm91dGVzL3JlcGwvX3V0aWxzL2Rvd25sb2FkQmxvYi5qcyIsIi4uLy4uLy4uL3NyYy91dGlscy9ldmVudHMuanMiLCIuLi8uLi8uLi9zcmMvdXRpbHMvY29tcGF0LmpzIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9yZXBsL1tpZF0vX2NvbXBvbmVudHMvQXBwQ29udHJvbHMvaW5kZXguc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9yZXBsL1tpZF0vaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcblx0aW1wb3J0IHsgZ2V0Q29udGV4dCB9IGZyb20gJ3N2ZWx0ZSc7XHJcblx0aW1wb3J0IHsgc3RvcmVzIH0gZnJvbSAnQHNhcHBlci9hcHAnO1xyXG5cdGNvbnN0IHsgc2Vzc2lvbiB9ID0gc3RvcmVzKCk7XHJcblxyXG5cdGNvbnN0IHsgbG9nb3V0IH0gPSBnZXRDb250ZXh0KCdhcHAnKTtcclxuXHJcblx0bGV0IHNob3dNZW51ID0gZmFsc2U7XHJcblx0bGV0IG5hbWU7XHJcblxyXG5cdCQ6IG5hbWUgPSAkc2Vzc2lvbi51c2VyLm5hbWUgfHwgJHNlc3Npb24udXNlci51c2VybmFtZTtcclxuPC9zY3JpcHQ+XHJcblxyXG48ZGl2IGNsYXNzPVwidXNlclwiIG9uOm1vdXNlZW50ZXI9XCJ7KCkgPT4gc2hvd01lbnUgPSB0cnVlfVwiIG9uOm1vdXNlbGVhdmU9XCJ7KCkgPT4gc2hvd01lbnUgPSBmYWxzZX1cIj5cclxuXHQ8c3Bhbj57bmFtZX08L3NwYW4+XHJcblx0PGltZyBhbHQ9XCJ7bmFtZX0gYXZhdGFyXCIgc3JjPVwieyRzZXNzaW9uLnVzZXIuYXZhdGFyfVwiPlxyXG5cclxuXHR7I2lmIHNob3dNZW51fVxyXG5cdFx0PGRpdiBjbGFzcz1cIm1lbnVcIj5cclxuXHRcdFx0PGEgaHJlZj1cImFwcHNcIj5Zb3VyIHNhdmVkIGFwcHM8L2E+XHJcblx0XHRcdDxidXR0b24gb246Y2xpY2s9e2xvZ291dH0+TG9nIG91dDwvYnV0dG9uPlxyXG5cdFx0PC9kaXY+XHJcblx0ey9pZn1cclxuPC9kaXY+XHJcblxyXG48c3R5bGU+XHJcblx0LnVzZXIge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG5cdFx0cGFkZGluZzogMGVtIDEuMnJlbSAwIDEuNnJlbTtcclxuXHRcdGhlaWdodDogMC44ZW07XHJcblx0XHRsaW5lLWhlaWdodDogMTtcclxuXHRcdHotaW5kZXg6IDk5O1xyXG5cdH1cclxuXHJcblx0LnVzZXI6OmFmdGVyIHtcclxuXHRcdC8qIGVtYmlnZ2VuIGhpdCB6b25lLCBzbyBsb2cgb3V0IG1lbnUgZG9lc24ndCBkaXNhcHBlYXIgKi9cclxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuXHRcdGNvbnRlbnQ6ICcnO1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRoZWlnaHQ6IDMuMnJlbTtcclxuXHRcdGxlZnQ6IDA7XHJcblx0XHR0b3A6IDA7XHJcblx0fVxyXG5cclxuXHRzcGFuIHtcclxuXHRcdC8qIHBvc2l0aW9uOiByZWxhdGl2ZTsgcGFkZGluZzogMCAyZW0gMCAwOyAqL1xyXG5cdFx0bGluZS1oZWlnaHQ6IDE7XHJcblx0XHRkaXNwbGF5OiBub25lO1xyXG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQpO1xyXG5cdFx0Zm9udC1zaXplOiAxLjZyZW07XHJcblx0XHRvcGFjaXR5OiAwLjc7XHJcblx0fVxyXG5cclxuXHQudXNlcjpob3ZlciBzcGFuIHtcclxuXHRcdG9wYWNpdHk6IDE7XHJcblx0fVxyXG5cclxuXHRpbWcge1xyXG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xyXG5cdFx0dG9wOiAtMC4wNWVtO1xyXG5cdFx0cmlnaHQ6IDA7XHJcblx0XHR3aWR0aDogMi4xcmVtO1xyXG5cdFx0aGVpZ2h0OiAyLjFyZW07XHJcblx0XHRib3JkZXI6IDFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMyk7XHJcblx0XHRib3JkZXItcmFkaXVzOiAwLjJyZW07XHJcblx0fVxyXG5cclxuXHQubWVudSB7XHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHR3aWR0aDogY2FsYygxMDAlICsgMS42cmVtKTtcclxuXHRcdG1pbi13aWR0aDogMTBlbTtcclxuXHRcdHRvcDogM3JlbTtcclxuXHRcdHJpZ2h0OiAtMS42cmVtO1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcclxuXHRcdHBhZGRpbmc6IDAuOHJlbSAxLjZyZW07XHJcblx0XHR6LWluZGV4OiA5OTtcclxuXHRcdHRleHQtYWxpZ246IGxlZnQ7XHJcblx0XHRib3JkZXItcmFkaXVzOiAwLjRyZW07XHJcblx0XHRkaXNwbGF5OiBmbGV4O1xyXG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuXHR9XHJcblxyXG5cdC5tZW51IGJ1dHRvbiwgLm1lbnUgYSB7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuXHRcdGZvbnQtZmFtaWx5OiB2YXIoLS1mb250KTtcclxuXHRcdGZvbnQtc2l6ZTogMS42cmVtO1xyXG5cdFx0b3BhY2l0eTogMC43O1xyXG5cdFx0cGFkZGluZzogMC40cmVtIDA7XHJcblx0XHR0ZXh0LWRlY29yYXRpb246IG5vbmU7XHJcblx0XHR0ZXh0LWFsaWduOiBsZWZ0O1xyXG5cdFx0Ym9yZGVyOiBub25lO1xyXG5cdFx0Y29sb3I6IGluaGVyaXQ7XHJcblx0fVxyXG5cclxuXHQubWVudSBidXR0b246aG92ZXIsIC5tZW51IGE6aG92ZXIge1xyXG5cdFx0b3BhY2l0eTogMTtcclxuXHRcdGNvbG9yOiBpbmhlcml0O1xyXG5cdH1cclxuXHJcblx0QG1lZGlhIChtaW4td2lkdGg6IDYwMHB4KSB7XHJcblx0XHQudXNlciB7XHJcblx0XHRcdHBhZGRpbmc6IDBlbSAzLjJyZW0gMCAxLjZyZW07XHJcblx0XHR9XHJcblxyXG5cdFx0aW1nIHtcclxuXHRcdFx0d2lkdGg6IDIuNHJlbTtcclxuXHRcdFx0aGVpZ2h0OiAyLjRyZW07XHJcblx0XHR9XHJcblxyXG5cdFx0c3BhbiB7XHJcblx0XHRcdGRpc3BsYXk6IGlubGluZS1ibG9jaztcclxuXHRcdH1cclxuXHR9XHJcbjwvc3R5bGU+XHJcbiIsImNvbnN0IHRhYmxlID0gW107XHJcbmZvciAobGV0IG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcclxuXHRsZXQgYyA9IG47XHJcblx0Zm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcclxuXHRcdGMgPSBjICYgMSA/IDB4RURCODgzMjAgXiAoYyA+Pj4gMSkgOiBjID4+PiAxO1xyXG5cdH1cclxuXHR0YWJsZVtuXSA9IGM7XHJcbn1cclxuXHJcbnZhciBjcmMzMiA9IGJ5dGVzID0+IHtcclxuXHRsZXQgc3VtID0gLTE7XHJcblx0Zm9yIChjb25zdCBieXRlIG9mIGJ5dGVzKSB7XHJcblx0XHRzdW0gPSAoc3VtID4+PiA4KSBeIHRhYmxlWyhzdW0gXiBieXRlKSAmIDB4RkZdO1xyXG5cdH1cclxuXHRyZXR1cm4gc3VtIF4gLTE7XHJcbn07XHJcblxyXG5jb25zdCBpbnQgPSAobiwgbGVuZ3RoKSA9PiB7XHJcblx0Y29uc3Qgb3V0ID0gW107XHJcblx0d2hpbGUgKGxlbmd0aC0tKSB7XHJcblx0XHRvdXQucHVzaChuICYgMHhGRik7XHJcblx0XHRuID4+Pj0gODtcclxuXHR9XHJcblx0cmV0dXJuIG91dDtcclxufTtcclxuXHJcbmNvbnN0IHRvQnl0ZXMgPSBkYXRhID0+IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IFsuLi5kYXRhXS5tYXAoY2hhciA9PiBjaGFyLmNoYXJDb2RlQXQoMCkpIDogZGF0YTtcclxuXHJcbnZhciB0b0FycmF5ID0gZmlsZXMgPT4ge1xyXG5cdGxldCBmaWxlRGF0YSA9IFtdO1xyXG5cdGNvbnN0IGNlbnRyYWxEaXJlY3RvcnkgPSBbXTtcclxuXHRmb3IgKGNvbnN0IHsgcGF0aCwgZGF0YSB9IG9mIGZpbGVzKSB7XHJcblx0XHRjb25zdCBkYXRhQnl0ZXMgPSB0b0J5dGVzKGRhdGEpO1xyXG5cdFx0Y29uc3QgcGF0aEJ5dGVzID0gdG9CeXRlcyhwYXRoKTtcclxuXHRcdGNvbnN0IGNvbW1vbkhlYWRlciA9IFsweDBBLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAuLi5pbnQoY3JjMzIoZGF0YUJ5dGVzKSwgNCksIC4uLmludChkYXRhQnl0ZXMubGVuZ3RoLCA0KSwgLi4uaW50KGRhdGFCeXRlcy5sZW5ndGgsIDQpLCAuLi5pbnQocGF0aEJ5dGVzLmxlbmd0aCwgMiksIDB4MDAsIDB4MDBdO1xyXG5cdFx0Y2VudHJhbERpcmVjdG9yeS5wdXNoKDB4NTAsIDB4NEIsIDB4MDEsIDB4MDIsIDB4MTQsIDB4MDAsIC4uLmNvbW1vbkhlYWRlciwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLi4uaW50KGZpbGVEYXRhLmxlbmd0aCwgNCksIC4uLnBhdGhCeXRlcyk7XHJcblx0XHRmaWxlRGF0YSA9IFsuLi5maWxlRGF0YSwgMHg1MCwgMHg0QiwgMHgwMywgMHgwNCwgLi4uY29tbW9uSGVhZGVyLCAuLi5wYXRoQnl0ZXMsIC4uLmRhdGFCeXRlc107XHJcblx0fVxyXG5cdHJldHVybiBbLi4uZmlsZURhdGEsIC4uLmNlbnRyYWxEaXJlY3RvcnksIDB4NTAsIDB4NEIsIDB4MDUsIDB4MDYsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC4uLmludChmaWxlcy5sZW5ndGgsIDIpLCAuLi5pbnQoZmlsZXMubGVuZ3RoLCAyKSwgLi4uaW50KGNlbnRyYWxEaXJlY3RvcnkubGVuZ3RoLCA0KSwgLi4uaW50KGZpbGVEYXRhLmxlbmd0aCwgNCksIDB4MDAsIDB4MDBdO1xyXG59O1xyXG5cclxudmFyIHRvQmxvYiA9IGZpbGVzID0+IG5ldyBCbG9iKFtVaW50OEFycmF5LmZyb20odG9BcnJheShmaWxlcykpXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vemlwJyB9KTtcclxuXHJcbnZhciB0b0J1ZmZlciA9IGZpbGVzID0+IEJ1ZmZlci5mcm9tKHRvQXJyYXkoZmlsZXMpKTtcclxuXHJcbnZhciB0b0F1dG8gPSBmaWxlcyA9PiAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnID8gdG9CdWZmZXIgOiB0b0Jsb2IpKGZpbGVzKTtcclxuXHJcbmV4cG9ydCB7IHRvQXJyYXksIHRvQXV0bywgdG9CbG9iLCB0b0J1ZmZlciB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcclxuIiwiZXhwb3J0IGRlZmF1bHQgKGJsb2IsIGZpbGVuYW1lKSA9PiB7XHJcblx0Y29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuXHRjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG5cdGxpbmsuaHJlZiA9IHVybDtcclxuXHRsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XHJcblx0bGluay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcblx0bGluay5jbGljaygpO1xyXG5cdFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcclxuXHRsaW5rLnJlbW92ZSgpO1xyXG59O1xyXG4iLCJleHBvcnQgZnVuY3Rpb24ga2V5RXZlbnQoY29kZSkge1xyXG5cdHJldHVybiBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcclxuXHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleWRvd24pO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcclxuXHRcdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IGNvZGUpIHtcclxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGRlc3Ryb3koKSB7XHJcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5ZG93bik7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGVudGVyID0ga2V5RXZlbnQoMTMpO1xyXG4iLCJleHBvcnQgY29uc3QgaXNNYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCc7XHJcbiIsIjxzY3JpcHQ+XHJcblx0aW1wb3J0IHsgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcclxuXHRpbXBvcnQgeyBzdG9yZXMgfSBmcm9tICdAc2FwcGVyL2FwcCc7XHJcblx0aW1wb3J0IFVzZXJNZW51IGZyb20gJy4vVXNlck1lbnUuc3ZlbHRlJztcclxuXHRpbXBvcnQgeyBJY29uIH0gZnJvbSAnQHN2ZWx0ZWpzL3NpdGUta2l0JztcclxuXHRpbXBvcnQgKiBhcyBkb05vdFppcCBmcm9tICdkby1ub3QtemlwJztcclxuXHRpbXBvcnQgZG93bmxvYWRCbG9iIGZyb20gJy4uLy4uLy4uL191dGlscy9kb3dubG9hZEJsb2IuanMnO1xyXG5cdGltcG9ydCB7IGVudGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vdXRpbHMvZXZlbnRzLmpzJztcclxuXHRpbXBvcnQgeyBpc01hYyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3V0aWxzL2NvbXBhdC5qcyc7XHJcblxyXG5cdGNvbnN0IGRpc3BhdGNoID0gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCk7XHJcblx0Y29uc3QgeyBzZXNzaW9uIH0gPSBzdG9yZXMoKTtcclxuXHRjb25zdCB7IGxvZ2luIH0gPSBnZXRDb250ZXh0KCdhcHAnKTtcclxuXHJcblx0ZXhwb3J0IGxldCByZXBsO1xyXG5cdGV4cG9ydCBsZXQgZ2lzdDtcclxuXHRleHBvcnQgbGV0IG5hbWU7XHJcblx0ZXhwb3J0IGxldCB6ZW5fbW9kZTtcclxuXHRleHBvcnQgbGV0IGJ1bmRsZTtcclxuXHJcblx0bGV0IHNhdmluZyA9IGZhbHNlO1xyXG5cdGxldCBkb3dubG9hZGluZyA9IGZhbHNlO1xyXG5cdGxldCBqdXN0U2F2ZWQgPSBmYWxzZTtcclxuXHRsZXQganVzdEZvcmtlZCA9IGZhbHNlO1xyXG5cclxuXHRmdW5jdGlvbiB3YWl0KG1zKSB7XHJcblx0XHRyZXR1cm4gbmV3IFByb21pc2UoZiA9PiBzZXRUaW1lb3V0KGYsIG1zKSk7XHJcblx0fVxyXG5cclxuXHQkOiBjYW5TYXZlID0gJHNlc3Npb24udXNlciAmJiBnaXN0ICYmIGdpc3Qub3duZXIgPT09ICRzZXNzaW9uLnVzZXIudWlkO1xyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVLZXlkb3duKGV2ZW50KSB7XHJcblx0XHRpZiAoZXZlbnQud2hpY2ggPT09IDgzICYmIChpc01hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5KSkge1xyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRzYXZlKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRhc3luYyBmdW5jdGlvbiBmb3JrKGludGVudFdhc1NhdmUpIHtcclxuXHRcdHNhdmluZyA9IHRydWU7XHJcblxyXG5cdFx0Y29uc3QgeyBjb21wb25lbnRzIH0gPSByZXBsLnRvSlNPTigpO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdGNvbnN0IHIgPSBhd2FpdCBmZXRjaChgcmVwbC9jcmVhdGUuanNvbmAsIHtcclxuXHRcdFx0XHRtZXRob2Q6ICdQT1NUJyxcclxuXHRcdFx0XHRjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxyXG5cdFx0XHRcdGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuXHRcdFx0XHRcdG5hbWUsXHJcblx0XHRcdFx0XHRmaWxlczogY29tcG9uZW50cy5tYXAoY29tcG9uZW50ID0+ICh7XHJcblx0XHRcdFx0XHRcdG5hbWU6IGAke2NvbXBvbmVudC5uYW1lfS4ke2NvbXBvbmVudC50eXBlfWAsXHJcblx0XHRcdFx0XHRcdHNvdXJjZTogY29tcG9uZW50LnNvdXJjZVxyXG5cdFx0XHRcdFx0fSkpXHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAoci5zdGF0dXMgPCAyMDAgfHwgci5zdGF0dXMgPj0gMzAwKSB7XHJcblx0XHRcdFx0Y29uc3QgeyBlcnJvciB9ID0gYXdhaXQgci5qc29uKCk7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBhbiBIVFRQICR7ci5zdGF0dXN9IHJlc3BvbnNlOiAke2Vycm9yfWApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBnaXN0ID0gYXdhaXQgci5qc29uKCk7XHJcblx0XHRcdGRpc3BhdGNoKCdmb3JrZWQnLCB7IGdpc3QgfSk7XHJcblxyXG5cdFx0XHRpZiAoaW50ZW50V2FzU2F2ZSkge1xyXG5cdFx0XHRcdGp1c3RTYXZlZCA9IHRydWU7XHJcblx0XHRcdFx0YXdhaXQgd2FpdCg2MDApO1xyXG5cdFx0XHRcdGp1c3RTYXZlZCA9IGZhbHNlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGp1c3RGb3JrZWQgPSB0cnVlO1xyXG5cdFx0XHRcdGF3YWl0IHdhaXQoNjAwKTtcclxuXHRcdFx0XHRqdXN0Rm9ya2VkID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRpZiAobmF2aWdhdG9yLm9uTGluZSkge1xyXG5cdFx0XHRcdGFsZXJ0KGVyci5tZXNzYWdlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRhbGVydChgSXQgbG9va3MgbGlrZSB5b3UncmUgb2ZmbGluZSEgRmluZCB0aGUgaW50ZXJuZXQgYW5kIHRyeSBhZ2FpbmApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0c2F2aW5nID0gZmFsc2U7XHJcblx0fVxyXG5cclxuXHRhc3luYyBmdW5jdGlvbiBzYXZlKCkge1xyXG5cdFx0aWYgKHNhdmluZykgcmV0dXJuO1xyXG5cclxuXHRcdGlmICghY2FuU2F2ZSkge1xyXG5cdFx0XHRmb3JrKHRydWUpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0c2F2aW5nID0gdHJ1ZTtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBTZW5kIGFsbCBmaWxlcyBiYWNrIHRvIEFQSVxyXG5cdFx0XHQvLyB+PiBBbnkgbWlzc2luZyBmaWxlcyBhcmUgY29uc2lkZXJlZCBkZWxldGVkIVxyXG5cdFx0XHRjb25zdCB7IGNvbXBvbmVudHMgfSA9IHJlcGwudG9KU09OKCk7XHJcblxyXG5cdFx0XHRjb25zdCByID0gYXdhaXQgZmV0Y2goYHJlcGwvJHtnaXN0LnVpZH0uanNvbmAsIHtcclxuXHRcdFx0XHRtZXRob2Q6ICdQQVRDSCcsXHJcblx0XHRcdFx0Y3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcclxuXHRcdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcblx0XHRcdFx0XHRuYW1lLFxyXG5cdFx0XHRcdFx0ZmlsZXM6IGNvbXBvbmVudHMubWFwKGNvbXBvbmVudCA9PiAoe1xyXG5cdFx0XHRcdFx0XHRuYW1lOiBgJHtjb21wb25lbnQubmFtZX0uJHtjb21wb25lbnQudHlwZX1gLFxyXG5cdFx0XHRcdFx0XHRzb3VyY2U6IGNvbXBvbmVudC5zb3VyY2VcclxuXHRcdFx0XHRcdH0pKVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0aWYgKHIuc3RhdHVzIDwgMjAwIHx8IHIuc3RhdHVzID49IDMwMCkge1xyXG5cdFx0XHRcdGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHIuanNvbigpO1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgYW4gSFRUUCAke3Iuc3RhdHVzfSByZXNwb25zZTogJHtlcnJvcn1gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXdhaXQgci5qc29uKCk7XHJcblxyXG5cdFx0XHRqdXN0U2F2ZWQgPSB0cnVlO1xyXG5cdFx0XHRhd2FpdCB3YWl0KDYwMCk7XHJcblx0XHRcdGp1c3RTYXZlZCA9IGZhbHNlO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGlmIChuYXZpZ2F0b3Iub25MaW5lKSB7XHJcblx0XHRcdFx0YWxlcnQoZXJyLm1lc3NhZ2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGFsZXJ0KGBJdCBsb29rcyBsaWtlIHlvdSdyZSBvZmZsaW5lISBGaW5kIHRoZSBpbnRlcm5ldCBhbmQgdHJ5IGFnYWluYCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzYXZpbmcgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKCkge1xyXG5cdFx0ZG93bmxvYWRpbmcgPSB0cnVlO1xyXG5cclxuXHRcdGNvbnN0IHsgY29tcG9uZW50cywgaW1wb3J0cyB9ID0gcmVwbC50b0pTT04oKTtcclxuXHJcblx0XHRjb25zdCBmaWxlcyA9IGF3YWl0IChhd2FpdCBmZXRjaCgnL3N2ZWx0ZS1hcHAuanNvbicpKS5qc29uKCk7XHJcblxyXG5cdFx0aWYgKGltcG9ydHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRjb25zdCBpZHggPSBmaWxlcy5maW5kSW5kZXgoKHsgcGF0aCB9KSA9PiBwYXRoID09PSAncGFja2FnZS5qc29uJyk7XHJcblx0XHRcdGNvbnN0IHBrZyA9IEpTT04ucGFyc2UoZmlsZXNbaWR4XS5kYXRhKTtcclxuXHRcdFx0Y29uc3QgeyBkZXZEZXBlbmRlbmNpZXMgfSA9IHBrZztcclxuXHRcdFx0aW1wb3J0cy5mb3JFYWNoKG1vZCA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbWF0Y2ggPSAvXihAW14vXStcXC8pP1teQC9dKy8uZXhlYyhtb2QpO1xyXG5cdFx0XHRcdGRldkRlcGVuZGVuY2llc1ttYXRjaFswXV0gPSAnbGF0ZXN0JztcclxuXHRcdFx0fSk7XHJcblx0XHRcdHBrZy5kZXZEZXBlbmRlbmNpZXMgPSBkZXZEZXBlbmRlbmNpZXM7XHJcblx0XHRcdGZpbGVzW2lkeF0uZGF0YSA9IEpTT04uc3RyaW5naWZ5KHBrZywgbnVsbCwgJyAgJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZmlsZXMucHVzaCguLi5jb21wb25lbnRzLm1hcChjb21wb25lbnQgPT4gKHsgcGF0aDogYHNyYy8ke2NvbXBvbmVudC5uYW1lfS4ke2NvbXBvbmVudC50eXBlfWAsIGRhdGE6IGNvbXBvbmVudC5zb3VyY2UgfSkpKTtcclxuXHRcdGZpbGVzLnB1c2goe1xyXG5cdFx0XHRwYXRoOiBgc3JjL21haW4uanNgLCBkYXRhOiBgaW1wb3J0IEFwcCBmcm9tICcuL0FwcC5zdmVsdGUnO1xyXG5cclxudmFyIGFwcCA9IG5ldyBBcHAoe1xyXG5cdHRhcmdldDogZG9jdW1lbnQuYm9keVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFwcDtgIH0pO1xyXG5cclxuXHRcdGRvd25sb2FkQmxvYihkb05vdFppcC50b0Jsb2IoZmlsZXMpLCAnc3ZlbHRlLWFwcC56aXAnKTtcclxuXHJcblx0XHRkb3dubG9hZGluZyA9IGZhbHNlO1xyXG5cdH1cclxuPC9zY3JpcHQ+XHJcblxyXG48c3ZlbHRlOndpbmRvdyBvbjprZXlkb3duPXtoYW5kbGVLZXlkb3dufSAvPlxyXG5cclxuPGRpdiBjbGFzcz1cImFwcC1jb250cm9sc1wiPlxyXG5cdDxpbnB1dFxyXG5cdFx0YmluZDp2YWx1ZT17bmFtZX1cclxuXHRcdG9uOmZvY3VzPVwie2UgPT4gZS50YXJnZXQuc2VsZWN0KCl9XCJcclxuXHRcdHVzZTplbnRlcj1cIntlID0+IGUudGFyZ2V0LmJsdXIoKX1cIlxyXG5cdD5cclxuXHJcblx0PGRpdiBzdHlsZT1cInRleHQtYWxpZ246IHJpZ2h0OyBtYXJnaW4tcmlnaHQ6LjRyZW1cIj5cclxuXHRcdDxidXR0b24gY2xhc3M9XCJpY29uXCIgb246Y2xpY2s9XCJ7KCkgPT4gemVuX21vZGUgPSAhemVuX21vZGV9XCIgdGl0bGU9XCJmdWxsc2NyZWVuIGVkaXRvclwiPlxyXG5cdFx0XHR7I2lmIHplbl9tb2RlfVxyXG5cdFx0XHRcdDxJY29uIG5hbWU9XCJjbG9zZVwiIC8+XHJcblx0XHRcdHs6ZWxzZX1cclxuXHRcdFx0XHQ8SWNvbiBuYW1lPVwibWF4aW1pemVcIiAvPlxyXG5cdFx0XHR7L2lmfVxyXG5cdFx0PC9idXR0b24+XHJcblxyXG5cdFx0PGJ1dHRvbiBjbGFzcz1cImljb25cIiBkaXNhYmxlZD17ZG93bmxvYWRpbmd9IG9uOmNsaWNrPXtkb3dubG9hZH0gdGl0bGU9XCJkb3dubG9hZCB6aXAgZmlsZVwiPlxyXG5cdFx0XHQ8SWNvbiBuYW1lPVwiZG93bmxvYWRcIiAvPlxyXG5cdFx0PC9idXR0b24+XHJcblxyXG5cdFx0PGJ1dHRvbiBjbGFzcz1cImljb25cIiBkaXNhYmxlZD1cIntzYXZpbmcgfHwgISRzZXNzaW9uLnVzZXJ9XCIgb246Y2xpY2s9eygpID0+IGZvcmsoZmFsc2UpfSB0aXRsZT1cImZvcmtcIj5cclxuXHRcdFx0eyNpZiBqdXN0Rm9ya2VkfVxyXG5cdFx0XHRcdDxJY29uIG5hbWU9XCJjaGVja1wiIC8+XHJcblx0XHRcdHs6ZWxzZX1cclxuXHRcdFx0XHQ8SWNvbiBuYW1lPVwiZ2l0LWJyYW5jaFwiIC8+XHJcblx0XHRcdHsvaWZ9XHJcblx0XHQ8L2J1dHRvbj5cclxuXHJcblx0XHQ8YnV0dG9uIGNsYXNzPVwiaWNvblwiIGRpc2FibGVkPVwie3NhdmluZyB8fCAhJHNlc3Npb24udXNlcn1cIiBvbjpjbGljaz17c2F2ZX0gdGl0bGU9XCJzYXZlXCI+XHJcblx0XHRcdHsjaWYganVzdFNhdmVkfVxyXG5cdFx0XHRcdDxJY29uIG5hbWU9XCJjaGVja1wiIC8+XHJcblx0XHRcdHs6ZWxzZX1cclxuXHRcdFx0XHQ8SWNvbiBuYW1lPVwic2F2ZVwiIC8+XHJcblx0XHRcdHsvaWZ9XHJcblx0XHQ8L2J1dHRvbj5cclxuXHJcblx0XHR7I2lmICRzZXNzaW9uLnVzZXJ9XHJcblx0XHRcdDxVc2VyTWVudS8+XHJcblx0XHR7OmVsc2V9XHJcblx0XHRcdDxidXR0b24gY2xhc3M9XCJpY29uXCIgb246Y2xpY2t8cHJldmVudERlZmF1bHQ9e2xvZ2lufT5cclxuXHRcdFx0XHQ8SWNvbiBuYW1lPVwibG9nLWluXCIgLz5cclxuXHRcdFx0XHQ8c3Bhbj4mbmJzcDtMb2cgaW4gdG8gc2F2ZTwvc3Bhbj5cclxuXHRcdFx0PC9idXR0b24+XHJcblx0XHR7L2lmfVxyXG5cdDwvZGl2PlxyXG48L2Rpdj5cclxuXHJcbjxzdHlsZT5cclxuXHQuYXBwLWNvbnRyb2xzIHtcclxuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuXHRcdHRvcDogMDtcclxuXHRcdGxlZnQ6IDA7XHJcblx0XHR3aWR0aDogMTAwJTtcclxuXHRcdGhlaWdodDogdmFyKC0tYXBwLWNvbnRyb2xzLWgpO1xyXG5cdFx0ZGlzcGxheTogZmxleDtcclxuXHRcdGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcblx0XHRwYWRkaW5nOiAuNnJlbSB2YXIoLS1zaWRlLW5hdik7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zZWNvbmQpO1xyXG5cdFx0Y29sb3I6IHdoaXRlO1xyXG5cdH1cclxuXHJcblx0Lmljb24ge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0dG9wOiAtMC4xcmVtO1xyXG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xyXG5cdFx0cGFkZGluZzogMC4yZW07XHJcblx0XHRvcGFjaXR5OiAuNztcclxuXHRcdHRyYW5zaXRpb246IG9wYWNpdHkgLjNzO1xyXG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQpO1xyXG5cdFx0Zm9udC1zaXplOiAxLjZyZW07XHJcblx0XHRjb2xvcjogd2hpdGU7XHJcblx0XHQvKiB3aWR0aDogMS42ZW07XHJcblx0XHRoZWlnaHQ6IDEuNmVtOyAqL1xyXG5cdFx0bGluZS1oZWlnaHQ6IDE7XHJcblx0XHRtYXJnaW46IDAgMCAwIDAuMmVtO1xyXG5cdH1cclxuXHJcblx0Lmljb246aG92ZXIgICAgeyBvcGFjaXR5OiAxIH1cclxuXHQuaWNvbjpkaXNhYmxlZCB7IG9wYWNpdHk6IC4zIH1cclxuXHJcblx0Lmljb25bdGl0bGVePSdmdWxsc2NyZWVuJ10geyBkaXNwbGF5OiBub25lIH1cclxuXHJcblx0aW5wdXQge1xyXG5cdFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XHJcblx0XHRib3JkZXI6IG5vbmU7XHJcblx0XHRjb2xvcjogY3VycmVudENvbG9yO1xyXG5cdFx0Zm9udC1mYW1pbHk6IHZhcigtLWZvbnQpO1xyXG5cdFx0Zm9udC1zaXplOiAxLjZyZW07XHJcblx0XHRvcGFjaXR5OiAwLjc7XHJcblx0XHRvdXRsaW5lOiBub25lO1xyXG5cdFx0ZmxleDogMTtcclxuXHR9XHJcblxyXG5cdGlucHV0OmZvY3VzIHtcclxuXHRcdG9wYWNpdHk6IDE7XHJcblx0fVxyXG5cclxuXHRidXR0b24gc3BhbiB7XHJcblx0XHRkaXNwbGF5OiBub25lO1xyXG5cdH1cclxuXHJcblx0QG1lZGlhIChtaW4td2lkdGg6IDYwMHB4KSB7XHJcblx0XHQuaWNvblt0aXRsZV49J2Z1bGxzY3JlZW4nXSB7IGRpc3BsYXk6IGlubGluZSB9XHJcblxyXG5cdFx0YnV0dG9uIHNwYW4ge1xyXG5cdFx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XHJcblx0XHR9XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iLCI8c2NyaXB0IGNvbnRleHQ9XCJtb2R1bGVcIj5cclxuXHRleHBvcnQgZnVuY3Rpb24gcHJlbG9hZCh7IHBhcmFtcywgcXVlcnkgfSkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dmVyc2lvbjogcXVlcnkudmVyc2lvbiB8fCAnMycsXHJcblx0XHRcdGlkOiBwYXJhbXMuaWRcclxuXHRcdH07XHJcblx0fVxyXG48L3NjcmlwdD5cclxuXHJcbjxzY3JpcHQ+XHJcblx0aW1wb3J0IFJlcGwgZnJvbSAnQHN2ZWx0ZWpzL3N2ZWx0ZS1yZXBsJztcclxuXHRpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcclxuXHRpbXBvcnQgeyBnb3RvLCBzdG9yZXMgfSBmcm9tICdAc2FwcGVyL2FwcCc7XHJcblx0aW1wb3J0IElucHV0T3V0cHV0VG9nZ2xlIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvUmVwbC9JbnB1dE91dHB1dFRvZ2dsZS5zdmVsdGUnO1xyXG5cdGltcG9ydCBBcHBDb250cm9scyBmcm9tICcuL19jb21wb25lbnRzL0FwcENvbnRyb2xzL2luZGV4LnN2ZWx0ZSc7XHJcblxyXG5cdGV4cG9ydCBsZXQgdmVyc2lvbjtcclxuXHRleHBvcnQgbGV0IGlkO1xyXG5cclxuXHRjb25zdCB7IHNlc3Npb24gfSA9IHN0b3JlcygpO1xyXG5cclxuXHRsZXQgcmVwbDtcclxuXHRsZXQgZ2lzdDtcclxuXHRsZXQgbmFtZSA9ICdMb2FkaW5nLi4uJztcclxuXHRsZXQgemVuX21vZGUgPSBmYWxzZTtcclxuXHRsZXQgaXNfcmVsYXhlZF9naXN0ID0gZmFsc2U7XHJcblx0bGV0IHdpZHRoID0gcHJvY2Vzcy5icm93c2VyID8gd2luZG93LmlubmVyV2lkdGggOiAxMDAwO1xyXG5cdGxldCBjaGVja2VkID0gZmFsc2U7XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZV9xdWVyeV9zdHJpbmcodmVyc2lvbikge1xyXG5cdFx0Y29uc3QgcGFyYW1zID0gW107XHJcblxyXG5cdFx0aWYgKHZlcnNpb24gIT09ICdsYXRlc3QnKSBwYXJhbXMucHVzaChgdmVyc2lvbj0ke3ZlcnNpb259YCk7XHJcblxyXG5cdFx0Y29uc3QgdXJsID0gcGFyYW1zLmxlbmd0aCA+IDBcclxuXHRcdFx0PyBgcmVwbC8ke2lkfT8ke3BhcmFtcy5qb2luKCcmJyl9YFxyXG5cdFx0XHQ6IGByZXBsLyR7aWR9YDtcclxuXHJcblx0XHRoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7fSwgJ3gnLCB1cmwpO1xyXG5cdH1cclxuXHJcblx0JDogaWYgKHR5cGVvZiBoaXN0b3J5ICE9PSAndW5kZWZpbmVkJykgdXBkYXRlX3F1ZXJ5X3N0cmluZyh2ZXJzaW9uKTtcclxuXHJcblx0ZnVuY3Rpb24gZmV0Y2hfZ2lzdChpZCkge1xyXG5cdFx0aWYgKGdpc3QgJiYgZ2lzdC51aWQgPT09IGlkKSB7XHJcblx0XHRcdC8vIGlmIHRoZSBpZCBjaGFuZ2VkIGJlY2F1c2Ugd2UganVzdCBmb3JrZWQsIGRvbid0IHJlZmV0Y2hcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gaGFuZGxlIGByZWxheGVkYCBsb2dpY1xyXG5cdFx0ZmV0Y2goYHJlcGwvJHtpZH0uanNvbmApLnRoZW4ociA9PiB7XHJcblx0XHRcdGlmIChyLm9rKSB7XHJcblx0XHRcdFx0ci5qc29uKCkudGhlbihkYXRhID0+IHtcclxuXHRcdFx0XHRcdGdpc3QgPSBkYXRhO1xyXG5cdFx0XHRcdFx0bmFtZSA9IGRhdGEubmFtZTtcclxuXHJcblx0XHRcdFx0XHRpc19yZWxheGVkX2dpc3QgPSBkYXRhLnJlbGF4ZWQ7XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgY29tcG9uZW50cyA9IGRhdGEuZmlsZXMubWFwKGZpbGUgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgW25hbWUsIHR5cGVdID0gZmlsZS5uYW1lLnNwbGl0KCcuJyk7XHJcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSAnaHRtbCcpIHR5cGUgPSAnc3ZlbHRlJzsgLy8gVE9ETyBkbyB0aGlzIG9uIHRoZSBzZXJ2ZXJcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHsgbmFtZSwgdHlwZSwgc291cmNlOiBmaWxlLnNvdXJjZSB9O1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0Y29tcG9uZW50cy5zb3J0KChhLCBiKSA9PiB7XHJcblx0XHRcdFx0XHRcdGlmIChhLm5hbWUgPT09ICdBcHAnICYmIGEudHlwZSA9PT0gJ3N2ZWx0ZScpIHJldHVybiAtMTtcclxuXHRcdFx0XHRcdFx0aWYgKGIubmFtZSA9PT0gJ0FwcCcgJiYgYi50eXBlID09PSAnc3ZlbHRlJykgcmV0dXJuIDE7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoYS50eXBlICE9PSBiLnR5cGUpIHJldHVybiBhLnR5cGUgPT09ICdzdmVsdGUnID8gLTEgOiAxO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGEubmFtZSA8IGIubmFtZSA/IC0xIDogMTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRcdHJlcGwuc2V0KHsgY29tcG9uZW50cyB9KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zb2xlLndhcm4oJ1RPRE86IDQwNCBHaXN0Jyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0JDogaWYgKHByb2Nlc3MuYnJvd3NlcikgZmV0Y2hfZ2lzdChpZCk7XHJcblxyXG5cdG9uTW91bnQoKCkgPT4ge1xyXG5cdFx0aWYgKHZlcnNpb24gIT09ICdsb2NhbCcpIHtcclxuXHRcdFx0ZmV0Y2goYGh0dHBzOi8vdW5wa2cuY29tL3N2ZWx0ZUAke3ZlcnNpb24gfHwgJzMnfS9wYWNrYWdlLmpzb25gKVxyXG5cdFx0XHRcdC50aGVuKHIgPT4gci5qc29uKCkpXHJcblx0XHRcdFx0LnRoZW4ocGtnID0+IHtcclxuXHRcdFx0XHRcdHZlcnNpb24gPSBwa2cudmVyc2lvbjtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlX2ZvcmsoZXZlbnQpIHtcclxuXHRcdGNvbnNvbGUubG9nKCc+IGhhbmRsZV9mb3JrJywgZXZlbnQpO1xyXG5cdFx0Z2lzdCA9IGV2ZW50LmRldGFpbC5naXN0O1xyXG5cdFx0Z290byhgL3JlcGwvJHtnaXN0LnVpZH0/dmVyc2lvbj0ke3ZlcnNpb259YCk7XHJcblx0fVxyXG5cclxuXHQkOiBzdmVsdGVVcmwgPSBwcm9jZXNzLmJyb3dzZXIgJiYgdmVyc2lvbiA9PT0gJ2xvY2FsJyA/XHJcblx0XHRgJHtsb2NhdGlvbi5vcmlnaW59L3JlcGwvbG9jYWxgIDpcclxuXHRcdGBodHRwczovL3VucGtnLmNvbS9zdmVsdGVAJHt2ZXJzaW9ufWA7XHJcblxyXG5cdGNvbnN0IHJvbGx1cFVybCA9IGBodHRwczovL3VucGtnLmNvbS9yb2xsdXBAMS9kaXN0L3JvbGx1cC5icm93c2VyLmpzYDtcclxuXHJcblx0Ly8gbmVlZGVkIGZvciBjb250ZXh0IEFQSSBleGFtcGxlXHJcblx0Y29uc3QgbWFwYm94X3NldHVwID0gYHdpbmRvdy5NQVBCT1hfQUNDRVNTX1RPS0VOID0gcHJvY2Vzcy5lbnYuTUFQQk9YX0FDQ0VTU19UT0tFTjtgO1xyXG5cclxuXHQkOiBtb2JpbGUgPSB3aWR0aCA8IDU0MDtcclxuXHJcblx0JDogcmVsYXhlZCA9IGlzX3JlbGF4ZWRfZ2lzdCB8fCAoJHNlc3Npb24udXNlciAmJiBnaXN0ICYmICRzZXNzaW9uLnVzZXIudWlkID09PSBnaXN0Lm93bmVyKTtcclxuPC9zY3JpcHQ+XHJcblxyXG48c3R5bGU+XHJcblx0LnJlcGwtb3V0ZXIge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0aGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0tbmF2LWgpKTtcclxuXHRcdC0tYXBwLWNvbnRyb2xzLWg6IDUuNnJlbTtcclxuXHRcdC0tcGFuZS1jb250cm9scy1oOiA0LjJyZW07XHJcblx0XHRvdmVyZmxvdzogaGlkZGVuO1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYmFjayk7XHJcblx0XHRwYWRkaW5nOiB2YXIoLS1hcHAtY29udHJvbHMtaCkgMCAwIDA7XHJcblx0XHQvKiBtYXJnaW46IDAgY2FsYyh2YXIoLS1zaWRlLW5hdikgKiAtMSk7ICovXHJcblx0XHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG5cdH1cclxuXHJcblx0LnZpZXdwb3J0IHtcclxuXHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0aGVpZ2h0OiAxMDAlO1xyXG5cdH1cclxuXHJcblx0Lm1vYmlsZSAudmlld3BvcnQge1xyXG5cdFx0d2lkdGg6IDIwMCU7XHJcblx0XHRoZWlnaHQ6IGNhbGMoMTAwJSAtIDQycHgpO1xyXG5cdFx0dHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3M7XHJcblx0fVxyXG5cclxuXHQubW9iaWxlIC5vZmZzZXQge1xyXG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgMCk7XHJcblx0fVxyXG5cclxuXHQvKiB0ZW1wIGZpeCBmb3IgIzI0OTkgYW5kICMyNTUwIHdoaWxlIHdhaXRpbmcgZm9yIGEgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlLXJlcGwvaXNzdWVzLzggKi9cclxuXHJcblx0LnZpZXdwb3J0IDpnbG9iYWwoLnRhYi1jb250ZW50KSxcclxuXHQudmlld3BvcnQgOmdsb2JhbCgudGFiLWNvbnRlbnQudmlzaWJsZSkge1xyXG5cdFx0cG9pbnRlci1ldmVudHM6IGFsbDtcclxuXHRcdG9wYWNpdHk6IDE7XHJcblx0fVxyXG5cdC52aWV3cG9ydCA6Z2xvYmFsKC50YWItY29udGVudCkge1xyXG5cdFx0dmlzaWJpbGl0eTogaGlkZGVuO1xyXG5cdH1cclxuXHQudmlld3BvcnQgOmdsb2JhbCgudGFiLWNvbnRlbnQudmlzaWJsZSkge1xyXG5cdFx0dmlzaWJpbGl0eTogdmlzaWJsZTtcclxuXHR9XHJcblxyXG5cdC56ZW4tbW9kZSB7XHJcblx0XHRwb3NpdGlvbjogZml4ZWQ7XHJcblx0XHR3aWR0aDogMTAwJTtcclxuXHRcdGhlaWdodDogMTAwJTtcclxuXHRcdHRvcDogMDtcclxuXHRcdHotaW5kZXg6IDExMTtcclxuXHR9XHJcblxyXG5cdC5wYW5lIHsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJSB9XHJcblxyXG5cdC5sb2FkaW5nIHtcclxuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcclxuXHRcdGNvbG9yOiB2YXIoLS1zZWNvbmQpO1xyXG5cdFx0Zm9udC13ZWlnaHQ6IDQwMDtcclxuXHRcdG1hcmdpbjogMmVtIDAgMCAwO1xyXG5cdFx0b3BhY2l0eTogMDtcclxuXHRcdGFuaW1hdGlvbjogZmFkZS1pbiAuNHM7XHJcblx0XHRhbmltYXRpb24tZGVsYXk6IC4ycztcclxuXHRcdGFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XHJcblx0fVxyXG5cclxuXHRAa2V5ZnJhbWVzIGZhZGUtaW4ge1xyXG5cdFx0MCUgICB7IG9wYWNpdHk6IDAgfVxyXG5cdFx0MTAwJSB7IG9wYWNpdHk6IDEgfVxyXG5cdH1cclxuXHJcblx0LmlucHV0IHtcclxuXHRcdHBhZGRpbmc6IDIuNGVtIDAgMCAwO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuXHJcbjxzdmVsdGU6aGVhZD5cclxuXHQ8dGl0bGU+e25hbWV9IOKAoiBSRVBMIOKAoiBTdmVsdGU8L3RpdGxlPlxyXG5cclxuXHQ8bWV0YSBuYW1lPVwidHdpdHRlcjp0aXRsZVwiIGNvbnRlbnQ9XCJTdmVsdGUgUkVQTFwiPlxyXG5cdDxtZXRhIG5hbWU9XCJ0d2l0dGVyOmRlc2NyaXB0aW9uXCIgY29udGVudD1cIkN5YmVybmV0aWNhbGx5IGVuaGFuY2VkIHdlYiBhcHBzXCI+XHJcblx0PG1ldGEgbmFtZT1cIkRlc2NyaXB0aW9uXCIgY29udGVudD1cIkludGVyYWN0aXZlIFN2ZWx0ZSBwbGF5Z3JvdW5kXCI+XHJcbjwvc3ZlbHRlOmhlYWQ+XHJcblxyXG48c3ZlbHRlOndpbmRvdyBiaW5kOmlubmVyV2lkdGg9e3dpZHRofS8+XHJcblxyXG48ZGl2IGNsYXNzPVwicmVwbC1vdXRlciB7emVuX21vZGUgPyAnemVuLW1vZGUnIDogJyd9XCIgY2xhc3M6bW9iaWxlPlxyXG5cdDxBcHBDb250cm9sc1xyXG5cdFx0e2dpc3R9XHJcblx0XHR7cmVwbH1cclxuXHRcdGJpbmQ6bmFtZVxyXG5cdFx0YmluZDp6ZW5fbW9kZVxyXG5cdFx0b246Zm9ya2VkPXtoYW5kbGVfZm9ya31cclxuXHQvPlxyXG5cclxuXHR7I2lmIHByb2Nlc3MuYnJvd3Nlcn1cclxuXHRcdDxkaXYgY2xhc3M9XCJ2aWV3cG9ydFwiIGNsYXNzOm9mZnNldD17Y2hlY2tlZH0+XHJcblx0XHRcdDxSZXBsXHJcblx0XHRcdFx0YmluZDp0aGlzPXtyZXBsfVxyXG5cdFx0XHRcdHdvcmtlcnNVcmw9XCJ3b3JrZXJzXCJcclxuXHRcdFx0XHR7c3ZlbHRlVXJsfVxyXG5cdFx0XHRcdHtyb2xsdXBVcmx9XHJcblx0XHRcdFx0e3JlbGF4ZWR9XHJcblx0XHRcdFx0Zml4ZWQ9e21vYmlsZX1cclxuXHRcdFx0XHRpbmplY3RlZEpTPXttYXBib3hfc2V0dXB9XHJcblx0XHRcdC8+XHJcblx0XHQ8L2Rpdj5cclxuXHJcblx0XHR7I2lmIG1vYmlsZX1cclxuXHRcdFx0PElucHV0T3V0cHV0VG9nZ2xlIGJpbmQ6Y2hlY2tlZC8+XHJcblx0XHR7L2lmfVxyXG5cdHsvaWZ9XHJcbjwvZGl2PlxyXG4iXSwibmFtZXMiOlsic3RvcmVzIiwiZG9Ob3RaaXAudG9CbG9iIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkNBb0JxQixNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUJBSHJCLFFBQVE7Ozs7OztpQkFITixJQUFJOzs7Ozs7Ozs7Ozs7Ozs7bUNBQUosSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBQ0EsSUFBSTs0Q0FBZ0IsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNOzs7Ozs7O2tDQUZsQjtrQ0FBd0M7Ozs7Ozs7Ozs7Ozs7Ozs7eUJBQ2xFLElBQUk7OztxRUFDQSxJQUFJOzs7O29FQUFnQixRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU07Ozs7V0FFOUMsUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FkYixNQUFNLEVBQUUsT0FBTyxFQUFFLEdBQUdBLFFBQU0sb0pBQUUsQ0FBQzs7Q0FFN0IsTUFBTSxFQUFFLE1BQU0sRUFBRSxHQUFHLFVB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
