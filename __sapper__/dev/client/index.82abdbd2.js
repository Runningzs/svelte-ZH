import { S as SvelteComponentDev, i as init, d as dispatch_dev, s as safe_not_equal, L as getContext, l as space, e as element, p as claim_space, c as claim_element, a as children, b as detach_dev, f as attr_dev, h as add_location, j as insert_dev, n as noop, E as text, F as claim_text, k as append_dev, H as set_data_dev, T as listen_dev, a8 as prevent_default, m as empty, R as destroy_each } from './index.4e52d202.js';

/* src\routes\apps\index.svelte generated by Svelte v3.12.0 */

const file = "src\\routes\\apps\\index.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.app = list[i];
	return child_ctx;
}

// (75:1) {:else}
function create_else_block(ctx) {
	var p, t0, a, t1, t2, dispose;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Please ");
			a = element("a");
			t1 = text("log in");
			t2 = text(" to see your saved apps.");
			this.h();
		},

		l: function claim(nodes) {
			p = claim_element(nodes, "P", {}, false);
			var p_nodes = children(p);

			t0 = claim_text(p_nodes, "Please ");

			a = claim_element(p_nodes, "A", { href: true }, false);
			var a_nodes = children(a);

			t1 = claim_text(a_nodes, "log in");
			a_nodes.forEach(detach_dev);
			t2 = claim_text(p_nodes, " to see your saved apps.");
			p_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "href", "auth/login");
			add_location(a, file, 75, 12, 1619);
			add_location(p, file, 75, 2, 1609);
			dispose = listen_dev(a, "click", prevent_default(ctx.login), false, true);
		},

		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			append_dev(p, a);
			append_dev(a, t1);
			append_dev(p, t2);
		},

		p: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(p);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_else_block.name, type: "else", source: "(75:1) {:else}", ctx });
	return block;
}

// (48:1) {#if user}
function create_if_block(ctx) {
	var header, h1, t0, t1, div, img, img_alt_value, img_src_value, t2, span, t3_value = ctx.user.name || ctx.user.username + "", t3, t4, a, t5, t6, t7, ul, t8, if_block_anchor, dispose;

	let each_value = ctx.apps;

	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	var if_block = (ctx.offset !== null) && create_if_block_1(ctx);

	const block = {
		c: function create() {
			header = element("header");
			h1 = element("h1");
			t0 = text("Your apps");
			t1 = space();
			div = element("div");
			img = element("img");
			t2 = space();
			span = element("span");
			t3 = text(t3_value);
			t4 = text("\r\n\t\t\t\t\t(");
			a = element("a");
			t5 = text("log out");
			t6 = text(")");
			t7 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t8 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true }, false);
			var header_nodes = children(header);

			h1 = claim_element(header_nodes, "H1", { class: true }, false);
			var h1_nodes = children(h1);

			t0 = claim_text(h1_nodes, "Your apps");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(header_nodes);

			div = claim_element(header_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			img = claim_element(div_nodes, "IMG", { class: true, alt: true, src: true }, false);
			var img_nodes = children(img);

			img_nodes.forEach(detach_dev);
			t2 = claim_space(div_nodes);

			span = claim_element(div_nodes, "SPAN", {}, false);
			var span_nodes = children(span);

			t3 = claim_text(span_nodes, t3_value);
			t4 = claim_text(span_nodes, "\r\n\t\t\t\t\t(");

			a = claim_element(span_nodes, "A", { href: true }, false);
			var a_nodes = children(a);

			t5 = claim_text(a_nodes, "log out");
			a_nodes.forEach(detach_dev);
			t6 = claim_text(span_nodes, ")");
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			t7 = claim_space(nodes);

			ul = claim_element(nodes, "UL", { class: true }, false);
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			t8 = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr_dev(h1, "class", "svelte-2bannn");
			add_location(h1, file, 49, 3, 1007);
			attr_dev(img, "class", "avatar svelte-2bannn");
			attr_dev(img, "alt", img_alt_value = "" + (ctx.user.name || ctx.user.username) + " avatar");
			attr_dev(img, "src", img_src_value = ctx.user.avatar);
			add_location(img, file, 52, 4, 1056);
			attr_dev(a, "href", "auth/logout");
			add_location(a, file, 55, 6, 1193);
			add_location(span, file, 53, 4, 1144);
			attr_dev(div, "class", "user svelte-2bannn");
			add_location(div, file, 51, 3, 1032);
			attr_dev(header, "class", "svelte-2bannn");
			add_location(header, file, 48, 2, 994);
			attr_dev(ul, "class", "svelte-2bannn");
			add_location(ul, file, 60, 2, 1303);
			dispose = listen_dev(a, "click", prevent_default(ctx.logout), false, true);
		},

		m: function mount(target, anchor) {
			insert_dev(target, header, anchor);
			append_dev(header, h1);
			append_dev(h1, t0);
			append_dev(header, t1);
			append_dev(header, div);
			append_dev(div, img);
			append_dev(div, t2);
			append_dev(div, span);
			append_dev(span, t3);
			append_dev(span, t4);
			append_dev(span, a);
			append_dev(a, t5);
			append_dev(span, t6);
			insert_dev(target, t7, anchor);
			insert_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert_dev(target, t8, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
		},

		p: function update(changed, ctx) {
			if ((changed.user) && img_alt_value !== (img_alt_value = "" + (ctx.user.name || ctx.user.username) + " avatar")) {
				attr_dev(img, "alt", img_alt_value);
			}

			if ((changed.user) && img_src_value !== (img_src_value = ctx.user.avatar)) {
				attr_dev(img, "src", img_src_value);
			}

			if ((changed.user) && t3_value !== (t3_value = ctx.user.name || ctx.user.username + "")) {
				set_data_dev(t3, t3_value);
			}

			if (changed.apps || changed.format) {
				each_value = ctx.apps;

				let i;
				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(changed, child_ctx);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if (ctx.offset !== null) {
				if (if_block) {
					if_block.p(changed, ctx);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(header);
				detach_dev(t7);
				detach_dev(ul);
			}

			destroy_each(each_blocks, detaching);

			if (detaching) {
				detach_dev(t8);
			}

			if (if_block) if_block.d(detaching);

			if (detaching) {
				detach_dev(if_block_anchor);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(48:1) {#if user}", ctx });
	return block;
}

// (62:3) {#each apps as app}
function create_each_block(ctx) {
	var li, a, h2, t0_value = ctx.app.name + "", t0, t1, span, t2, t3_value = ctx.format(ctx.app.updated_at) + "", t3, a_href_value, t4;

	const block = {
		c: function create() {
			li = element("li");
			a = element("a");
			h2 = element("h2");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text("updated ");
			t3 = text(t3_value);
			t4 = space();
			this.h();
		},

		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true }, false);
			var li_nodes = children(li);

			a = claim_element(li_nodes, "A", { href: true, class: true }, false);
			var a_nodes = children(a);

			h2 = claim_element(a_nodes, "H2", { class: true }, false);
			var h2_nodes = children(h2);

			t0 = claim_text(h2_nodes, t0_value);
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(a_nodes);

			span = claim_element(a_nodes, "SPAN", { class: true }, false);
			var span_nodes = children(span);

			t2 = claim_text(span_nodes, "updated ");
			t3 = claim_text(span_nodes, t3_value);
			span_nodes.forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			t4 = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(h2, "class", "svelte-2bannn");
			add_location(h2, file, 64, 6, 1381);
			attr_dev(span, "class", "svelte-2bannn");
			add_location(span, file, 65, 6, 1408);
			attr_dev(a, "href", a_href_value = "repl/" + ctx.app.uid);
			attr_dev(a, "class", "svelte-2bannn");
			add_location(a, file, 63, 5, 1348);
			attr_dev(li, "class", "svelte-2bannn");
			add_location(li, file, 62, 4, 1337);
		},

		m: function mount(target, anchor) {
			insert_dev(target, li, anchor);
			append_dev(li, a);
			append_dev(a, h2);
			append_dev(h2, t0);
			append_dev(a, t1);
			append_dev(a, span);
			append_dev(span, t2);
			append_dev(span, t3);
			append_dev(li, t4);
		},

		p: function update(changed, ctx) {
			if ((changed.apps) && t0_value !== (t0_value = ctx.app.name + "")) {
				set_data_dev(t0, t0_value);
			}

			if ((changed.apps) && t3_value !== (t3_value = ctx.format(ctx.app.updated_at) + "")) {
				set_data_dev(t3, t3_value);
			}

			if ((changed.apps) && a_href_value !== (a_href_value = "repl/" + ctx.app.uid)) {
				attr_dev(a, "href", a_href_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(li);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(62:3) {#each apps as app}", ctx });
	return block;
}

// (72:2) {#if offset !== null}
function create_if_block_1(ctx) {
	var div, a, t, a_href_value;

	const block = {
		c: function create() {
			div = element("div");
			a = element("a");
			t = text("Next page...");
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			a = claim_element(div_nodes, "A", { href: true }, false);
			var a_nodes = children(a);

			t = claim_text(a_nodes, "Next page...");
			a_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "href", a_href_value = "apps?offset=" + ctx.offset);
			add_location(a, file, 72, 8, 1533);
			add_location(div, file, 72, 3, 1528);
		},

		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, a);
			append_dev(a, t);
		},

		p: function update(changed, ctx) {
			if ((changed.offset) && a_href_value !== (a_href_value = "apps?offset=" + ctx.offset)) {
				attr_dev(a, "href", a_href_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(72:2) {#if offset !== null}", ctx });
	return block;
}

function create_fragment(ctx) {
	var t, div;

	function select_block_type(changed, ctx) {
		if (ctx.user) return create_if_block;
		return create_else_block;
	}

	var current_block_type = select_block_type(null, ctx);
	var if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			t = space();
			div = element("div");
			if_block.c();
			this.h();
		},

		l: function claim(nodes) {
			t = claim_space(nodes);

			div = claim_element(nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			document.title = "Your apps • Svelte";
			attr_dev(div, "class", "apps svelte-2bannn");
			add_location(div, file, 46, 0, 959);
		},

		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			insert_dev(target, div, anchor);
			if_block.m(div, null);
		},

		p: function update(changed, ctx) {
			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
				if_block.p(changed, ctx);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);
				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},

		i: noop,
		o: noop,

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t);
				detach_dev(div);
			}

			if_block.d();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

async function preload(page, { user }) {
	let apps = [];
	let offset = null;

	if (user) {
		let url = 'apps.json';
		if (page.query.offset) {
			url += `?offset=${encodeURIComponent(page.query.offset)}`;
		}
		const r = await this.fetch(url, {
			credentials: 'include'
		});
		if (!r.ok) return this.error(r.status, await r.text());

		({ apps, offset } = await r.json());
	}

	return { user, apps, offset };
}

function instance($$self, $$props, $$invalidate) {
	let { user, apps, offset } = $$props;

	const { login, logout } = getContext('app');

	const formatter = new Intl.DateTimeFormat(undefined, {
		year: 'numeric',
		month: 'short',
		day: 'numeric',
		hour: 'numeric',
		minute: '2-digit'
	});

	const format = str => formatter.format(new Date(str));

	const writable_props = ['user', 'apps', 'offset'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('user' in $$props) $$invalidate('user', user = $$props.user);
		if ('apps' in $$props) $$invalidate('apps', apps = $$props.apps);
		if ('offset' in $$props) $$invalidate('offset', offset = $$props.offset);
	};

	$$self.$capture_state = () => {
		return { user, apps, offset };
	};

	$$self.$inject_state = $$props => {
		if ('user' in $$props) $$invalidate('user', user = $$props.user);
		if ('apps' in $$props) $$invalidate('apps', apps = $$props.apps);
		if ('offset' in $$props) $$invalidate('offset', offset = $$props.offset);
	};

	return {
		user,
		apps,
		offset,
		login,
		logout,
		format
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["user", "apps", "offset"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.user === undefined && !('user' in props)) {
			console.warn("<Index> was created without expected prop 'user'");
		}
		if (ctx.apps === undefined && !('apps' in props)) {
			console.warn("<Index> was created without expected prop 'apps'");
		}
		if (ctx.offset === undefined && !('offset' in props)) {
			console.warn("<Index> was created without expected prop 'offset'");
		}
	}

	get user() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set user(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get apps() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set apps(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get offset() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set offset(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Index;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguODJhYmRiZDIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvYXBwcy9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XHJcblx0ZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByZWxvYWQocGFnZSwgeyB1c2VyIH0pIHtcclxuXHRcdGxldCBhcHBzID0gW107XHJcblx0XHRsZXQgb2Zmc2V0ID0gbnVsbDtcclxuXHJcblx0XHRpZiAodXNlcikge1xyXG5cdFx0XHRsZXQgdXJsID0gJ2FwcHMuanNvbic7XHJcblx0XHRcdGlmIChwYWdlLnF1ZXJ5Lm9mZnNldCkge1xyXG5cdFx0XHRcdHVybCArPSBgP29mZnNldD0ke2VuY29kZVVSSUNvbXBvbmVudChwYWdlLnF1ZXJ5Lm9mZnNldCl9YDtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zdCByID0gYXdhaXQgdGhpcy5mZXRjaCh1cmwsIHtcclxuXHRcdFx0XHRjcmVkZW50aWFsczogJ2luY2x1ZGUnXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZiAoIXIub2spIHJldHVybiB0aGlzLmVycm9yKHIuc3RhdHVzLCBhd2FpdCByLnRleHQoKSk7XHJcblxyXG5cdFx0XHQoeyBhcHBzLCBvZmZzZXQgfSA9IGF3YWl0IHIuanNvbigpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geyB1c2VyLCBhcHBzLCBvZmZzZXQgfTtcclxuXHR9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHNjcmlwdD5cclxuXHRpbXBvcnQgeyBnZXRDb250ZXh0IH0gZnJvbSAnc3ZlbHRlJztcclxuXHJcblx0ZXhwb3J0IGxldCB1c2VyO1xyXG5cdGV4cG9ydCBsZXQgYXBwcztcclxuXHRleHBvcnQgbGV0IG9mZnNldDtcclxuXHJcblx0Y29uc3QgeyBsb2dpbiwgbG9nb3V0IH0gPSBnZXRDb250ZXh0KCdhcHAnKTtcclxuXHJcblx0Y29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodW5kZWZpbmVkLCB7XHJcblx0XHR5ZWFyOiAnbnVtZXJpYycsXHJcblx0XHRtb250aDogJ3Nob3J0JyxcclxuXHRcdGRheTogJ251bWVyaWMnLFxyXG5cdFx0aG91cjogJ251bWVyaWMnLFxyXG5cdFx0bWludXRlOiAnMi1kaWdpdCdcclxuXHR9KTtcclxuXHJcblx0Y29uc3QgZm9ybWF0ID0gc3RyID0+IGZvcm1hdHRlci5mb3JtYXQobmV3IERhdGUoc3RyKSk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN2ZWx0ZTpoZWFkPlxyXG5cdDx0aXRsZT5Zb3VyIGFwcHMg4oCiwqBTdmVsdGU8L3RpdGxlPlxyXG48L3N2ZWx0ZTpoZWFkPlxyXG5cclxuPGRpdiBjbGFzcz1cImFwcHNcIj5cclxuXHR7I2lmIHVzZXJ9XHJcblx0XHQ8aGVhZGVyPlxyXG5cdFx0XHQ8aDE+WW91ciBhcHBzPC9oMT5cclxuXHJcblx0XHRcdDxkaXYgY2xhc3M9XCJ1c2VyXCI+XHJcblx0XHRcdFx0PGltZyBjbGFzcz1cImF2YXRhclwiIGFsdD1cInt1c2VyLm5hbWUgfHwgdXNlci51c2VybmFtZX0gYXZhdGFyXCIgc3JjPVwie3VzZXIuYXZhdGFyfVwiPlxyXG5cdFx0XHRcdDxzcGFuPlxyXG5cdFx0XHRcdFx0e3VzZXIubmFtZSB8fCB1c2VyLnVzZXJuYW1lfVxyXG5cdFx0XHRcdFx0KDxhIG9uOmNsaWNrfHByZXZlbnREZWZhdWx0PXtsb2dvdXR9IGhyZWY9XCJhdXRoL2xvZ291dFwiPmxvZyBvdXQ8L2E+KVxyXG5cdFx0XHRcdDwvc3Bhbj5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQ8L2hlYWRlcj5cclxuXHJcblx0XHQ8dWw+XHJcblx0XHRcdHsjZWFjaCBhcHBzIGFzIGFwcH1cclxuXHRcdFx0XHQ8bGk+XHJcblx0XHRcdFx0XHQ8YSBocmVmPVwicmVwbC97YXBwLnVpZH1cIj5cclxuXHRcdFx0XHRcdFx0PGgyPnthcHAubmFtZX08L2gyPlxyXG5cdFx0XHRcdFx0XHQ8c3Bhbj51cGRhdGVkIHtmb3JtYXQoYXBwLnVwZGF0ZWRfYXQpfTwvc3Bhbj5cclxuXHRcdFx0XHRcdDwvYT5cclxuXHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHR7L2VhY2h9XHJcblx0XHQ8L3VsPlxyXG5cclxuXHRcdHsjaWYgb2Zmc2V0ICE9PSBudWxsfVxyXG5cdFx0XHQ8ZGl2PjxhIGhyZWY9XCJhcHBzP29mZnNldD17b2Zmc2V0fVwiPk5leHQgcGFnZS4uLjwvYT48L2Rpdj5cclxuXHRcdHsvaWZ9XHJcblx0ezplbHNlfVxyXG5cdFx0PHA+UGxlYXNlIDxhIG9uOmNsaWNrfHByZXZlbnREZWZhdWx0PXtsb2dpbn0gaHJlZj1cImF1dGgvbG9naW5cIj5sb2cgaW48L2E+IHRvIHNlZSB5b3VyIHNhdmVkIGFwcHMuPC9wPlxyXG5cdHsvaWZ9XHJcbjwvZGl2PlxyXG5cclxuPHN0eWxlPlxyXG5cdC5hcHBzIHtcclxuXHRcdHBhZGRpbmc6IHZhcigtLXRvcC1vZmZzZXQpIHZhcigtLXNpZGUtbmF2KSA2cmVtIHZhcigtLXNpZGUtbmF2KTtcclxuXHRcdG1heC13aWR0aDogdmFyKC0tbWFpbi13aWR0aCk7XHJcblx0XHRtYXJnaW46IDAgYXV0bztcclxuXHR9XHJcblxyXG5cdGhlYWRlciB7XHJcblx0XHRtYXJnaW46IDAgMCAxZW0gMDtcclxuXHR9XHJcblxyXG5cdGgxIHtcclxuXHRcdGZvbnQtc2l6ZTogNHJlbTtcclxuXHRcdGZvbnQtd2VpZ2h0OiA0MDA7XHJcblx0fVxyXG5cclxuXHQudXNlciB7XHJcblx0XHRkaXNwbGF5OiBmbGV4O1xyXG5cdFx0cGFkZGluZzogMCAwIDAgMy4ycmVtO1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0bWFyZ2luOiAxcmVtIDAgNXJlbSAwO1xyXG5cdFx0Y29sb3I6IHZhcigtLXRleHQpO1xyXG5cdH1cclxuXHJcblx0LmF2YXRhciB7XHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHRsZWZ0OiAwO1xyXG5cdFx0dG9wOiAwLjFyZW07XHJcblx0XHR3aWR0aDogMi40cmVtO1xyXG5cdFx0aGVpZ2h0OiAyLjRyZW07XHJcblx0XHRib3JkZXI6IDFweCBzb2xpZCByZ2JhKDAsMCwwLDAuMyk7XHJcblx0XHRib3JkZXItcmFkaXVzOiAwLjJyZW07XHJcblx0fVxyXG5cclxuXHR1bCB7XHJcblx0XHRsaXN0LXN0eWxlOiBub25lO1xyXG5cdH1cclxuXHJcblx0bGkge1xyXG5cdFx0bWFyZ2luOiAwIDAgMWVtIDA7XHJcblx0fVxyXG5cclxuXHRoMiB7XHJcblx0XHRjb2xvcjogdmFyKC0tdGV4dCk7XHJcblx0XHRmb250LXNpemU6IHZhcigtLWgzKTtcclxuXHRcdGZvbnQtd2VpZ2h0OiA0MDA7XHJcblx0fVxyXG5cclxuXHRsaSBhIHtcclxuXHRcdGJvcmRlcjogbm9uZTtcclxuXHR9XHJcblxyXG5cdGxpIGE6aG92ZXIgaDIge1xyXG5cdFx0Y29sb3I6IHZhcigtLWZsYXNoKTtcclxuXHR9XHJcblxyXG5cdGxpIHNwYW4ge1xyXG5cdFx0Zm9udC1zaXplOiAxNHB4O1xyXG5cdFx0Y29sb3I6ICM5OTk7XHJcblx0fVxyXG48L3N0eWxlPlxyXG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3REEyRXdDLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswRkFyQnZDLElBQUksQ0FBQyxJQUFJLFFBQUksSUFBSSxDQUFDLFFBQVE7O3NCQU90QixJQUFJOzs7O2dDQUFUOzs7O3FCQVVFLE1BQU0sS0FBSyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0FWakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQUFBOzs7Ozs7Ozs7Ozs7Ozs7a0RBVHlCLElBQUksQ0FBQyxJQUFJLFFBQUksSUFBSSxDQUFDLFFBQVE7NENBQWdCLElBQUksQ0FBQyxNQUFNOzs7Ozs7Ozs7Ozt3REFHakQsTUFBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
