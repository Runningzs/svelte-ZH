import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, e as element, c as claim_element, a as children, b as detach_dev, f as attr_dev, h as add_location, j as insert_dev, R as destroy_each, l as space, E as text, p as claim_space, F as claim_text, Q as toggle_class, g as set_style, T as listen_dev, k as append_dev, w as mount_component, H as set_data_dev, x as transition_in, y as transition_out, z as destroy_component, a1 as prop_dev, W as add_render_callback, L as getContext, V as binding_callbacks, a4 as bind, P as HtmlTag, B as check_outros, G as globals, A as group_outros, a5 as add_flush_callback } from './index.4e52d202.js';
import './index.ad9ca859.js';
import { g as goto } from './app.623f0ee4.js';
import { b as Icon } from './index.abf9c6bd.js';
import { R as Repl } from './Repl.f1ddc62a.js';
import { s as svelteUrl, r as rollupUrl, m as mapbox_setup, S as ScreenToggle } from './config.582076a5.js';

/* src\routes\tutorial\[slug]\_TableOfContents.svelte generated by Svelte v3.12.0 */

const file = "src\\routes\\tutorial\\[slug]\\_TableOfContents.svelte";

function get_each_context_1(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.chapter = list[i];
	child_ctx.i = i;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.section = list[i];
	child_ctx.i = i;
	return child_ctx;
}

// (83:5) {#each section.chapters as chapter, i}
function create_each_block_1(ctx) {
	var option, t0_value = String.fromCharCode(ctx.i + 97) + "", t0, t1, t2_value = ctx.chapter.title + "", t2, option_value_value;

	const block = {
		c: function create() {
			option = element("option");
			t0 = text(t0_value);
			t1 = text(". ");
			t2 = text(t2_value);
			this.h();
		},

		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { value: true }, false);
			var option_nodes = children(option);

			t0 = claim_text(option_nodes, t0_value);
			t1 = claim_text(option_nodes, ". ");
			t2 = claim_text(option_nodes, t2_value);
			option_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			option.__value = option_value_value = ctx.chapter.slug;
			option.value = option.__value;
			add_location(option, file, 83, 6, 1589);
		},

		m: function mount(target, anchor) {
			insert_dev(target, option, anchor);
			append_dev(option, t0);
			append_dev(option, t1);
			append_dev(option, t2);
		},

		p: function update(changed, ctx) {
			if ((changed.sections) && t2_value !== (t2_value = ctx.chapter.title + "")) {
				set_data_dev(t2, t2_value);
			}

			if ((changed.sections) && option_value_value !== (option_value_value = ctx.chapter.slug)) {
				prop_dev(option, "__value", option_value_value);
			}

			option.value = option.__value;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(option);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block_1.name, type: "each", source: "(83:5) {#each section.chapters as chapter, i}", ctx });
	return block;
}

// (81:3) {#each sections as section, i}
function create_each_block(ctx) {
	var optgroup, optgroup_label_value;

	let each_value_1 = ctx.section.chapters;

	let each_blocks = [];

	for (let i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
		each_blocks[i_1] = create_each_block_1(get_each_context_1(ctx, each_value_1, i_1));
	}

	const block = {
		c: function create() {
			optgroup = element("optgroup");

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].c();
			}
			this.h();
		},

		l: function claim(nodes) {
			optgroup = claim_element(nodes, "OPTGROUP", { label: true }, false);
			var optgroup_nodes = children(optgroup);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].l(optgroup_nodes);
			}

			optgroup_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(optgroup, "label", optgroup_label_value = "" + (ctx.i + 1) + ". " + ctx.section.title);
			add_location(optgroup, file, 81, 4, 1493);
		},

		m: function mount(target, anchor) {
			insert_dev(target, optgroup, anchor);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].m(optgroup, null);
			}
		},

		p: function update(changed, ctx) {
			if (changed.sections) {
				each_value_1 = ctx.section.chapters;

				let i_1;
				for (i_1 = 0; i_1 < each_value_1.length; i_1 += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i_1);

					if (each_blocks[i_1]) {
						each_blocks[i_1].p(changed, child_ctx);
					} else {
						each_blocks[i_1] = create_each_block_1(child_ctx);
						each_blocks[i_1].c();
						each_blocks[i_1].m(optgroup, null);
					}
				}

				for (; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].d(1);
				}
				each_blocks.length = each_value_1.length;
			}

			if ((changed.sections) && optgroup_label_value !== (optgroup_label_value = "" + (ctx.i + 1) + ". " + ctx.section.title)) {
				attr_dev(optgroup, "label", optgroup_label_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(optgroup);
			}

			destroy_each(each_blocks, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_each_block.name, type: "each", source: "(81:3) {#each sections as section, i}", ctx });
	return block;
}

function create_fragment(ctx) {
	var nav, a0, a0_href_value, t0, div, span1, strong, span0, t1, t2_value = ctx.selected.section.title + "", t2, t3, t4, t5_value = ctx.selected.chapter.title + "", t5, t6, select, select_value_value, t7, a1, a1_href_value, current, dispose;

	var icon0 = new Icon({
		props: { name: "arrow-left" },
		$$inline: true
	});

	var icon1 = new Icon({ props: { name: "menu" }, $$inline: true });

	let each_value = ctx.sections;

	let each_blocks = [];

	for (let i_1 = 0; i_1 < each_value.length; i_1 += 1) {
		each_blocks[i_1] = create_each_block(get_each_context(ctx, each_value, i_1));
	}

	var icon2 = new Icon({
		props: { name: "arrow-right" },
		$$inline: true
	});

	const block = {
		c: function create() {
			nav = element("nav");
			a0 = element("a");
			icon0.$$.fragment.c();
			t0 = space();
			div = element("div");
			span1 = element("span");
			strong = element("strong");
			span0 = element("span");
			icon1.$$.fragment.c();
			t1 = space();
			t2 = text(t2_value);
			t3 = text(" /");
			t4 = space();
			t5 = text(t5_value);
			t6 = space();
			select = element("select");

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].c();
			}

			t7 = space();
			a1 = element("a");
			icon2.$$.fragment.c();
			this.h();
		},

		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true }, false);
			var nav_nodes = children(nav);

			a0 = claim_element(nav_nodes, "A", { rel: true, class: true, href: true }, false);
			var a0_nodes = children(a0);

			icon0.$$.fragment.l(a0_nodes);
			a0_nodes.forEach(detach_dev);
			t0 = claim_space(nav_nodes);

			div = claim_element(nav_nodes, "DIV", { class: true }, false);
			var div_nodes = children(div);

			span1 = claim_element(div_nodes, "SPAN", { class: true }, false);
			var span1_nodes = children(span1);

			strong = claim_element(span1_nodes, "STRONG", { class: true }, false);
			var strong_nodes = children(strong);

			span0 = claim_element(strong_nodes, "SPAN", { style: true, class: true }, false);
			var span0_nodes = children(span0);

			icon1.$$.fragment.l(span0_nodes);
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(strong_nodes);
			t2 = claim_text(strong_nodes, t2_value);
			t3 = claim_text(strong_nodes, " /");
			strong_nodes.forEach(detach_dev);
			t4 = claim_space(span1_nodes);
			t5 = claim_text(span1_nodes, t5_value);
			span1_nodes.forEach(detach_dev);
			t6 = claim_space(div_nodes);

			select = claim_element(div_nodes, "SELECT", { value: true, class: true }, false);
			var select_nodes = children(select);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			t7 = claim_space(nav_nodes);

			a1 = claim_element(nav_nodes, "A", { rel: true, class: true, href: true }, false);
			var a1_nodes = children(a1);

			icon2.$$.fragment.l(a1_nodes);
			a1_nodes.forEach(detach_dev);
			nav_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a0, "rel", "prefetch");
			attr_dev(a0, "class", "no-underline svelte-ob1q54");
			attr_dev(a0, "href", a0_href_value = "tutorial/" + (ctx.selected.prev || ctx.selected).slug);
			toggle_class(a0, "disabled", !ctx.selected.prev);
			add_location(a0, file, 66, 1, 1027);
			set_style(span0, "position", "relative");
			set_style(span0, "top", "-0.1em");
			set_style(span0, "margin", "0 0.5em 0 0");
			attr_dev(span0, "class", "svelte-ob1q54");
			add_location(span0, file, 73, 4, 1225);
			attr_dev(strong, "class", "svelte-ob1q54");
			add_location(strong, file, 72, 3, 1211);
			attr_dev(span1, "class", "svelte-ob1q54");
			add_location(span1, file, 71, 2, 1200);
			attr_dev(select, "class", "svelte-ob1q54");
			add_location(select, file, 79, 2, 1410);
			attr_dev(div, "class", "svelte-ob1q54");
			add_location(div, file, 70, 1, 1191);
			attr_dev(a1, "rel", "prefetch");
			attr_dev(a1, "class", "no-underline svelte-ob1q54");
			attr_dev(a1, "href", a1_href_value = "tutorial/" + (ctx.selected.next || ctx.selected).slug);
			toggle_class(a1, "disabled", !ctx.selected.next);
			add_location(a1, file, 90, 1, 1743);
			attr_dev(nav, "class", "svelte-ob1q54");
			add_location(nav, file, 65, 0, 1019);
			dispose = listen_dev(select, "change", navigate);
		},

		m: function mount(target, anchor) {
			insert_dev(target, nav, anchor);
			append_dev(nav, a0);
			mount_component(icon0, a0, null);
			append_dev(nav, t0);
			append_dev(nav, div);
			append_dev(div, span1);
			append_dev(span1, strong);
			append_dev(strong, span0);
			mount_component(icon1, span0, null);
			append_dev(strong, t1);
			append_dev(strong, t2);
			append_dev(strong, t3);
			append_dev(span1, t4);
			append_dev(span1, t5);
			append_dev(div, t6);
			append_dev(div, select);

			for (let i_1 = 0; i_1 < each_blocks.length; i_1 += 1) {
				each_blocks[i_1].m(select, null);
			}

			select_value_value = ctx.slug;
			for (var i = 0; i < select.options.length; i += 1) {
				var option = select.options[i];

				if (option.__value === select_value_value) {
					option.selected = true;
					break;
				}
			}

			append_dev(nav, t7);
			append_dev(nav, a1);
			mount_component(icon2, a1, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.selected) && a0_href_value !== (a0_href_value = "tutorial/" + (ctx.selected.prev || ctx.selected).slug)) {
				attr_dev(a0, "href", a0_href_value);
			}

			if (changed.selected) {
				toggle_class(a0, "disabled", !ctx.selected.prev);
			}

			if ((!current || changed.selected) && t2_value !== (t2_value = ctx.selected.section.title + "")) {
				set_data_dev(t2, t2_value);
			}

			if ((!current || changed.selected) && t5_value !== (t5_value = ctx.selected.chapter.title + "")) {
				set_data_dev(t5, t5_value);
			}

			if (changed.sections) {
				each_value = ctx.sections;

				let i_1;
				for (i_1 = 0; i_1 < each_value.length; i_1 += 1) {
					const child_ctx = get_each_context(ctx, each_value, i_1);

					if (each_blocks[i_1]) {
						each_blocks[i_1].p(changed, child_ctx);
					} else {
						each_blocks[i_1] = create_each_block(child_ctx);
						each_blocks[i_1].c();
						each_blocks[i_1].m(select, null);
					}
				}

				for (; i_1 < each_blocks.length; i_1 += 1) {
					each_blocks[i_1].d(1);
				}
				each_blocks.length = each_value.length;
			}

			if ((!current || changed.slug) && select_value_value !== (select_value_value = ctx.slug)) {
				for (var i = 0; i < select.options.length; i += 1) {
					var option = select.options[i];

					if (option.__value === select_value_value) {
						option.selected = true;
						break;
					}
				}
			}

			if ((!current || changed.selected) && a1_href_value !== (a1_href_value = "tutorial/" + (ctx.selected.next || ctx.selected).slug)) {
				attr_dev(a1, "href", a1_href_value);
			}

			if (changed.selected) {
				toggle_class(a1, "disabled", !ctx.selected.next);
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);

			transition_in(icon1.$$.fragment, local);

			transition_in(icon2.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			transition_out(icon2.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(nav);
			}

			destroy_component(icon0);

			destroy_component(icon1);

			destroy_each(each_blocks, detaching);

			destroy_component(icon2);

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment.name, type: "component", source: "", ctx });
	return block;
}

function navigate(e) {
	goto(`tutorial/${e.target.value}`);
}

function instance($$self, $$props, $$invalidate) {
	

	let { sections, slug, selected } = $$props;

	const writable_props = ['sections', 'slug', 'selected'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<TableOfContents> was created with unknown prop '${key}'`);
	});

	$$self.$set = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
	};

	$$self.$capture_state = () => {
		return { sections, slug, selected };
	};

	$$self.$inject_state = $$props => {
		if ('sections' in $$props) $$invalidate('sections', sections = $$props.sections);
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
	};

	return { sections, slug, selected };
}

class TableOfContents extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, ["sections", "slug", "selected"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "TableOfContents", options, id: create_fragment.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.sections === undefined && !('sections' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'sections'");
		}
		if (ctx.slug === undefined && !('slug' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'slug'");
		}
		if (ctx.selected === undefined && !('selected' in props)) {
			console.warn("<TableOfContents> was created without expected prop 'selected'");
		}
	}

	get sections() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get slug() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slug(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selected() {
		throw new Error("<TableOfContents>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selected(value) {
		throw new Error("<TableOfContents>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\routes\tutorial\[slug]\index.svelte generated by Svelte v3.12.0 */
const { window: window_1 } = globals;

const file$1 = "src\\routes\\tutorial\\[slug]\\index.svelte";

// (282:5) {#if chapter.app_b}
function create_if_block_2(ctx) {
	var button, t_value = ctx.completed ? 'Reset' : 'Show me' + "", t, dispose;

	const block = {
		c: function create() {
			button = element("button");
			t = text(t_value);
			this.h();
		},

		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true }, false);
			var button_nodes = children(button);

			t = claim_text(button_nodes, t_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(button, "class", "show svelte-ie4axf");
			add_location(button, file$1, 284, 6, 6336);
			dispose = listen_dev(button, "click", ctx.click_handler);
		},

		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
		},

		p: function update(changed, ctx) {
			if ((changed.completed) && t_value !== (t_value = ctx.completed ? 'Reset' : 'Show me' + "")) {
				set_data_dev(t, t_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(button);
			}

			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_2.name, type: "if", source: "(282:5) {#if chapter.app_b}", ctx });
	return block;
}

// (290:5) {#if selected.next}
function create_if_block_1(ctx) {
	var a, t, a_href_value;

	const block = {
		c: function create() {
			a = element("a");
			t = text("Next");
			this.h();
		},

		l: function claim(nodes) {
			a = claim_element(nodes, "A", { class: true, href: true }, false);
			var a_nodes = children(a);

			t = claim_text(a_nodes, "Next");
			a_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(a, "class", "next svelte-ie4axf");
			attr_dev(a, "href", a_href_value = "tutorial/" + ctx.selected.next.slug);
			add_location(a, file$1, 290, 6, 6516);
		},

		m: function mount(target, anchor) {
			insert_dev(target, a, anchor);
			append_dev(a, t);
		},

		p: function update(changed, ctx) {
			if ((changed.selected) && a_href_value !== (a_href_value = "tutorial/" + ctx.selected.next.slug)) {
				attr_dev(a, "href", a_href_value);
			}
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(a);
			}
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block_1.name, type: "if", source: "(290:5) {#if selected.next}", ctx });
	return block;
}

// (316:1) {#if mobile}
function create_if_block(ctx) {
	var updating_offset, current;

	function screentoggle_offset_binding(value) {
		ctx.screentoggle_offset_binding.call(null, value);
		updating_offset = true;
		add_flush_callback(() => updating_offset = false);
	}

	let screentoggle_props = { labels: ['tutorial', 'input', 'output'] };
	if (ctx.offset !== void 0) {
		screentoggle_props.offset = ctx.offset;
	}
	var screentoggle = new ScreenToggle({
		props: screentoggle_props,
		$$inline: true
	});

	binding_callbacks.push(() => bind(screentoggle, 'offset', screentoggle_offset_binding));

	const block = {
		c: function create() {
			screentoggle.$$.fragment.c();
		},

		l: function claim(nodes) {
			screentoggle.$$.fragment.l(nodes);
		},

		m: function mount(target, anchor) {
			mount_component(screentoggle, target, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var screentoggle_changes = {};
			if (!updating_offset && changed.offset) {
				screentoggle_changes.offset = ctx.offset;
			}
			screentoggle.$set(screentoggle_changes);
		},

		i: function intro(local) {
			if (current) return;
			transition_in(screentoggle.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(screentoggle.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			destroy_component(screentoggle, detaching);
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_if_block.name, type: "if", source: "(316:1) {#if mobile}", ctx });
	return block;
}

function create_fragment$1(ctx) {
	var title_value, meta0, meta1, meta1_content_value, meta2, meta2_content_value, t0, div7, div6, div4, div0, t1, div3, html_tag, raw_value = ctx.chapter.html + "", t2, div1, t3, t4, div2, a, t5, t6, div5, div6_class_value, t7, current, dispose;

	add_render_callback(ctx.onwindowresize);

	document.title = title_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title + " • Svelte Tutorial";

	var tableofcontents = new TableOfContents({
		props: {
		sections: ctx.sections,
		slug: ctx.slug,
		selected: ctx.selected
	},
		$$inline: true
	});

	var if_block0 = (ctx.chapter.app_b) && create_if_block_2(ctx);

	var if_block1 = (ctx.selected.next) && create_if_block_1(ctx);

	let repl_1_props = {
		workersUrl: "workers",
		svelteUrl: svelteUrl,
		rollupUrl: rollupUrl,
		orientation: ctx.mobile ? 'columns' : 'rows',
		fixed: ctx.mobile,
		injectedJS: mapbox_setup,
		relaxed: true
	};
	var repl_1 = new Repl({ props: repl_1_props, $$inline: true });

	ctx.repl_1_binding(repl_1);
	repl_1.$on("change", ctx.handle_change);

	var if_block2 = (ctx.mobile) && create_if_block(ctx);

	const block = {
		c: function create() {
			meta0 = element("meta");
			meta1 = element("meta");
			meta2 = element("meta");
			t0 = space();
			div7 = element("div");
			div6 = element("div");
			div4 = element("div");
			div0 = element("div");
			tableofcontents.$$.fragment.c();
			t1 = space();
			div3 = element("div");
			t2 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			div2 = element("div");
			a = element("a");
			t5 = text("Edit this chapter");
			t6 = space();
			div5 = element("div");
			repl_1.$$.fragment.c();
			t7 = space();
			if (if_block2) if_block2.c();
			this.h();
		},

		l: function claim(nodes) {
			meta0 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta0_nodes = children(meta0);

			meta0_nodes.forEach(detach_dev);

			meta1 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta1_nodes = children(meta1);

			meta1_nodes.forEach(detach_dev);

			meta2 = claim_element(nodes, "META", { name: true, content: true }, false);
			var meta2_nodes = children(meta2);

			meta2_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);

			div7 = claim_element(nodes, "DIV", { class: true }, false);
			var div7_nodes = children(div7);

			div6 = claim_element(div7_nodes, "DIV", { class: true }, false);
			var div6_nodes = children(div6);

			div4 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div4_nodes = children(div4);

			div0 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div0_nodes = children(div0);

			tableofcontents.$$.fragment.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t1 = claim_space(div4_nodes);

			div3 = claim_element(div4_nodes, "DIV", { class: true }, false);
			var div3_nodes = children(div3);

			t2 = claim_space(div3_nodes);

			div1 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div1_nodes = children(div1);

			if (if_block0) if_block0.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			if (if_block1) if_block1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			t4 = claim_space(div3_nodes);

			div2 = claim_element(div3_nodes, "DIV", { class: true }, false);
			var div2_nodes = children(div2);

			a = claim_element(div2_nodes, "A", { class: true, href: true }, false);
			var a_nodes = children(a);

			t5 = claim_text(a_nodes, "Edit this chapter");
			a_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			div4_nodes.forEach(detach_dev);
			t6 = claim_space(div6_nodes);

			div5 = claim_element(div6_nodes, "DIV", { class: true }, false);
			var div5_nodes = children(div5);

			repl_1.$$.fragment.l(div5_nodes);
			div5_nodes.forEach(detach_dev);
			div6_nodes.forEach(detach_dev);
			t7 = claim_space(div7_nodes);
			if (if_block2) if_block2.l(div7_nodes);
			div7_nodes.forEach(detach_dev);
			this.h();
		},

		h: function hydrate() {
			attr_dev(meta0, "name", "twitter:title");
			attr_dev(meta0, "content", "Svelte tutorial");
			add_location(meta0, file$1, 263, 1, 5572);
			attr_dev(meta1, "name", "twitter:description");
			attr_dev(meta1, "content", meta1_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title);
			add_location(meta1, file$1, 264, 1, 5628);
			attr_dev(meta2, "name", "Description");
			attr_dev(meta2, "content", meta2_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title);
			add_location(meta2, file$1, 265, 1, 5726);
			attr_dev(div0, "class", "table-of-contents");
			add_location(div0, file$1, 273, 3, 5982);
			html_tag = new HtmlTag(raw_value, t2);
			attr_dev(div1, "class", "controls svelte-ie4axf");
			add_location(div1, file$1, 280, 4, 6169);
			attr_dev(a, "class", "no-underline svelte-ie4axf");
			attr_dev(a, "href", ctx.improve_link);
			add_location(a, file$1, 295, 5, 6645);
			attr_dev(div2, "class", "improve-chapter svelte-ie4axf");
			add_location(div2, file$1, 294, 4, 6609);
			attr_dev(div3, "class", "chapter-markup svelte-ie4axf");
			add_location(div3, file$1, 277, 3, 6084);
			attr_dev(div4, "class", "tutorial-text svelte-ie4axf");
			add_location(div4, file$1, 272, 2, 5950);
			attr_dev(div5, "class", "tutorial-repl");
			add_location(div5, file$1, 300, 2, 6749);
			attr_dev(div6, "class", div6_class_value = "viewport offset-" + ctx.offset + " svelte-ie4axf");
			add_location(div6, file$1, 271, 1, 5908);
			attr_dev(div7, "class", "tutorial-outer svelte-ie4axf");
			add_location(div7, file$1, 270, 0, 5877);
			dispose = listen_dev(window_1, "resize", ctx.onwindowresize);
		},

		m: function mount(target, anchor) {
			append_dev(document.head, meta0);
			append_dev(document.head, meta1);
			append_dev(document.head, meta2);
			insert_dev(target, t0, anchor);
			insert_dev(target, div7, anchor);
			append_dev(div7, div6);
			append_dev(div6, div4);
			append_dev(div4, div0);
			mount_component(tableofcontents, div0, null);
			append_dev(div4, t1);
			append_dev(div4, div3);
			html_tag.m(div3);
			append_dev(div3, t2);
			append_dev(div3, div1);
			if (if_block0) if_block0.m(div1, null);
			append_dev(div1, t3);
			if (if_block1) if_block1.m(div1, null);
			append_dev(div3, t4);
			append_dev(div3, div2);
			append_dev(div2, a);
			append_dev(a, t5);
			ctx.div3_binding(div3);
			append_dev(div6, t6);
			append_dev(div6, div5);
			mount_component(repl_1, div5, null);
			append_dev(div7, t7);
			if (if_block2) if_block2.m(div7, null);
			current = true;
		},

		p: function update(changed, ctx) {
			if ((!current || changed.selected) && title_value !== (title_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title + " • Svelte Tutorial")) {
				document.title = title_value;
			}

			if ((!current || changed.selected) && meta1_content_value !== (meta1_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title)) {
				attr_dev(meta1, "content", meta1_content_value);
			}

			if ((!current || changed.selected) && meta2_content_value !== (meta2_content_value = "" + ctx.selected.section.title + " / " + ctx.selected.chapter.title)) {
				attr_dev(meta2, "content", meta2_content_value);
			}

			var tableofcontents_changes = {};
			if (changed.slug) tableofcontents_changes.slug = ctx.slug;
			if (changed.selected) tableofcontents_changes.selected = ctx.selected;
			tableofcontents.$set(tableofcontents_changes);

			if ((!current || changed.chapter) && raw_value !== (raw_value = ctx.chapter.html + "")) {
				html_tag.p(raw_value);
			}

			if (ctx.chapter.app_b) {
				if (if_block0) {
					if_block0.p(changed, ctx);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(div1, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (ctx.selected.next) {
				if (if_block1) {
					if_block1.p(changed, ctx);
				} else {
					if_block1 = create_if_block_1(ctx);
					if_block1.c();
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || changed.improve_link) {
				attr_dev(a, "href", ctx.improve_link);
			}

			var repl_1_changes = {};
			if (changed.mobile) repl_1_changes.orientation = ctx.mobile ? 'columns' : 'rows';
			if (changed.mobile) repl_1_changes.fixed = ctx.mobile;
			repl_1.$set(repl_1_changes);

			if ((!current || changed.offset) && div6_class_value !== (div6_class_value = "viewport offset-" + ctx.offset + " svelte-ie4axf")) {
				attr_dev(div6, "class", div6_class_value);
			}

			if (ctx.mobile) {
				if (if_block2) {
					if_block2.p(changed, ctx);
					transition_in(if_block2, 1);
				} else {
					if_block2 = create_if_block(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div7, null);
				}
			} else if (if_block2) {
				group_outros();
				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});
				check_outros();
			}
		},

		i: function intro(local) {
			if (current) return;
			transition_in(tableofcontents.$$.fragment, local);

			transition_in(repl_1.$$.fragment, local);

			transition_in(if_block2);
			current = true;
		},

		o: function outro(local) {
			transition_out(tableofcontents.$$.fragment, local);
			transition_out(repl_1.$$.fragment, local);
			transition_out(if_block2);
			current = false;
		},

		d: function destroy(detaching) {
			detach_dev(meta0);
			detach_dev(meta1);
			detach_dev(meta2);

			if (detaching) {
				detach_dev(t0);
				detach_dev(div7);
			}

			destroy_component(tableofcontents);

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			ctx.div3_binding(null);
			ctx.repl_1_binding(null);

			destroy_component(repl_1);

			if (if_block2) if_block2.d();
			dispose();
		}
	};
	dispatch_dev("SvelteRegisterBlock", { block, id: create_fragment$1.name, type: "component", source: "", ctx });
	return block;
}

async function preload({ params }) {
	const res = await this.fetch(`tutorial/${params.slug}.json`);

	if (!res.ok) {
		return this.redirect(301, `tutorial/basics`);
	}

	return {
		slug: params.slug,
		chapter: await res.json()
	};
}

const tutorial_repo_link = 'https://github.com/sveltejs/svelte/tree/master/site/content/tutorial';

function instance$1($$self, $$props, $$invalidate) {
	

	let { slug, chapter } = $$props;

	const { sections } = getContext('tutorial');

	let repl;
	let prev;
	let scrollable;
	const lookup = new Map();

	let width =  window.innerWidth ;
	let offset = 0;

	sections.forEach(section => {
		section.chapters.forEach(chapter => {
			const obj = {
				slug: chapter.slug,
				section,
				chapter,
				prev
			};

			lookup.set(chapter.slug, obj);

			{ // pending https://github.com/sveltejs/svelte/issues/2135
				if (prev) prev.next = obj;
				prev = obj;
			}
		});
	});

	const clone = file => ({
		name: file.name,
		type: file.type,
		source: file.source
	});

	function reset() {
		repl.update({
			components: chapter.app_a.map(clone)
		});
	}

	function complete() {
		repl.update({
			components: chapter.app_b.map(clone)
		});
	}

	let completed = false;

	function handle_change(event) {
		$$invalidate('completed', completed = event.detail.components.every((file, i) => {
			const expected = chapter.app_b[i];
			return expected && (
				file.name === expected.name &&
				file.type === expected.type &&
				file.source.trim().replace(/\s+$/gm, '') === expected.source.trim().replace(/\s+$/gm, '')
			);
		}));
	}

	const writable_props = ['slug', 'chapter'];
	Object.keys($$props).forEach(key => {
		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Index> was created with unknown prop '${key}'`);
	});

	function onwindowresize() {
		width = window_1.innerWidth; $$invalidate('width', width);
	}

	const click_handler = () => completed ? reset() : complete();

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('scrollable', scrollable = $$value);
		});
	}

	function repl_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			$$invalidate('repl', repl = $$value);
		});
	}

	function screentoggle_offset_binding(value) {
		offset = value;
		$$invalidate('offset', offset);
	}

	$$self.$set = $$props => {
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('chapter' in $$props) $$invalidate('chapter', chapter = $$props.chapter);
	};

	$$self.$capture_state = () => {
		return { slug, chapter, repl, prev, scrollable, width, offset, completed, selected, improve_link, mobile };
	};

	$$self.$inject_state = $$props => {
		if ('slug' in $$props) $$invalidate('slug', slug = $$props.slug);
		if ('chapter' in $$props) $$invalidate('chapter', chapter = $$props.chapter);
		if ('repl' in $$props) $$invalidate('repl', repl = $$props.repl);
		if ('prev' in $$props) prev = $$props.prev;
		if ('scrollable' in $$props) $$invalidate('scrollable', scrollable = $$props.scrollable);
		if ('width' in $$props) $$invalidate('width', width = $$props.width);
		if ('offset' in $$props) $$invalidate('offset', offset = $$props.offset);
		if ('completed' in $$props) $$invalidate('completed', completed = $$props.completed);
		if ('selected' in $$props) $$invalidate('selected', selected = $$props.selected);
		if ('improve_link' in $$props) $$invalidate('improve_link', improve_link = $$props.improve_link);
		if ('mobile' in $$props) $$invalidate('mobile', mobile = $$props.mobile);
	};

	let selected, improve_link, mobile;

	$$self.$$.update = ($$dirty = { scrollable: 1, chapter: 1, slug: 1, selected: 1, repl: 1, width: 1 }) => {
		if ($$dirty.scrollable || $$dirty.chapter) { if (scrollable) scrollable.scrollTo(0, 0); }
		if ($$dirty.slug) { $$invalidate('selected', selected = lookup.get(slug)); }
		if ($$dirty.selected) { $$invalidate('improve_link', improve_link = `${tutorial_repo_link}/${selected.chapter.section_dir}/${selected.chapter.chapter_dir}`); }
		if ($$dirty.repl || $$dirty.chapter) { if (repl) {
				$$invalidate('completed', completed = false);
				repl.set({
					components: chapter.app_a.map(clone)
				});
			} }
		if ($$dirty.width) { $$invalidate('mobile', mobile = width < 768); }
	};

	return {
		slug,
		chapter,
		sections,
		repl,
		scrollable,
		width,
		offset,
		reset,
		complete,
		completed,
		handle_change,
		selected,
		improve_link,
		mobile,
		onwindowresize,
		click_handler,
		div3_binding,
		repl_1_binding,
		screentoggle_offset_binding
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["slug", "chapter"]);
		dispatch_dev("SvelteRegisterComponent", { component: this, tagName: "Index", options, id: create_fragment$1.name });

		const { ctx } = this.$$;
		const props = options.props || {};
		if (ctx.slug === undefined && !('slug' in props)) {
			console.warn("<Index> was created without expected prop 'slug'");
		}
		if (ctx.chapter === undefined && !('chapter' in props)) {
			console.warn("<Index> was created without expected prop 'chapter'");
		}
	}

	get slug() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slug(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get chapter() {
		throw new Error("<Index>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set chapter(value) {
		throw new Error("<Index>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Index;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNjIyMDYwNjkuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9yb3V0ZXMvdHV0b3JpYWwvW3NsdWddL19UYWJsZU9mQ29udGVudHMuc3ZlbHRlIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy90dXRvcmlhbC9bc2x1Z10vaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XHJcblx0aW1wb3J0IHsgZ290byB9IGZyb20gJ0BzYXBwZXIvYXBwJztcclxuXHRpbXBvcnQgeyBJY29uIH0gZnJvbSAnQHN2ZWx0ZWpzL3NpdGUta2l0JztcclxuXHJcblx0ZXhwb3J0IGxldCBzZWN0aW9ucztcclxuXHRleHBvcnQgbGV0IHNsdWc7XHJcblx0ZXhwb3J0IGxldCBzZWxlY3RlZDtcclxuXHJcblx0ZnVuY3Rpb24gbmF2aWdhdGUoZSkge1xyXG5cdFx0Z290byhgdHV0b3JpYWwvJHtlLnRhcmdldC52YWx1ZX1gKTtcclxuXHR9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdG5hdiB7XHJcblx0XHRkaXNwbGF5OiBncmlkO1xyXG5cdFx0Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAyLjVlbSAxZnIgMi41ZW07XHJcblx0XHRib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSgyNTUsMjU1LDI1NSwwLjEpO1xyXG5cdH1cclxuXHJcblx0ZGl2IHtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuXHRcdHBhZGRpbmc6IDFlbSAwLjVlbTtcclxuXHRcdGZvbnQtd2VpZ2h0OiAzMDA7XHJcblx0XHRmb250LXNpemU6IHZhcigtLWg2KTtcclxuXHRcdGNvbG9yOiB3aGl0ZTtcclxuXHR9XHJcblxyXG5cdGEge1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0XHRwYWRkaW5nOiAwLjdlbSAwO1xyXG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xyXG5cdFx0b3BhY2l0eTogMC43NTtcclxuXHRcdGNvbG9yOiB3aGl0ZTtcclxuXHR9XHJcblxyXG5cdGE6aG92ZXIge1xyXG5cdFx0b3BhY2l0eTogMTtcclxuXHR9XHJcblxyXG5cdGEuZGlzYWJsZWQsIGEuZGlzYWJsZWQ6aG92ZXIsIGEuZGlzYWJsZWQ6YWN0aXZlIHtcclxuXHRcdGNvbG9yOiB3aGl0ZTtcclxuXHRcdG9wYWNpdHk6IDAuMztcclxuXHR9XHJcblxyXG5cdHNwYW4ge1xyXG5cdFx0d2hpdGUtc3BhY2U6IG5vd3JhcDtcclxuXHRcdHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICAgIFx0dG9wOiAwLjNlbTtcclxuXHR9XHJcblxyXG5cdHN0cm9uZyB7IG9wYWNpdHk6IDAuNyB9XHJcblxyXG5cdHNlbGVjdCB7XHJcblx0XHRwb3NpdGlvbjogYWJzb2x1dGU7XHJcblx0XHRsZWZ0OiAwO1xyXG5cdFx0dG9wOiAwO1xyXG5cdFx0d2lkdGg6IDEwMCU7XHJcblx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRvcGFjaXR5OiAwLjAwMDE7XHJcblx0XHRjdXJzb3I6IHBvaW50ZXI7XHJcblx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XHJcblx0fVxyXG48L3N0eWxlPlxyXG5cclxuPG5hdj5cclxuXHQ8YSByZWw9XCJwcmVmZXRjaFwiIGNsYXNzPVwibm8tdW5kZXJsaW5lXCIgaHJlZj1cInR1dG9yaWFsL3soc2VsZWN0ZWQucHJldiB8fCBzZWxlY3RlZCkuc2x1Z31cIiBjbGFzczpkaXNhYmxlZD17IXNlbGVjdGVkLnByZXZ9PlxyXG5cdFx0PEljb24gbmFtZT1cImFycm93LWxlZnRcIiAvPlxyXG5cdDwvYT5cclxuXHJcblx0PGRpdj5cclxuXHRcdDxzcGFuPlxyXG5cdFx0XHQ8c3Ryb25nPlxyXG5cdFx0XHRcdDxzcGFuIHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlOyB0b3A6IC0wLjFlbTsgbWFyZ2luOiAwIDAuNWVtIDAgMFwiPjxJY29uIG5hbWU9XCJtZW51XCIvPjwvc3Bhbj5cclxuXHRcdFx0XHR7c2VsZWN0ZWQuc2VjdGlvbi50aXRsZX0gL1xyXG5cdFx0XHQ8L3N0cm9uZz5cclxuXHRcdFx0e3NlbGVjdGVkLmNoYXB0ZXIudGl0bGV9XHJcblx0XHQ8L3NwYW4+XHJcblxyXG5cdFx0PHNlbGVjdCB2YWx1ZT17c2x1Z30gb246Y2hhbmdlPXtuYXZpZ2F0ZX0+XHJcblx0XHRcdHsjZWFjaCBzZWN0aW9ucyBhcyBzZWN0aW9uLCBpfVxyXG5cdFx0XHRcdDxvcHRncm91cCBsYWJlbD1cIntpICsgMX0uIHtzZWN0aW9uLnRpdGxlfVwiPlxyXG5cdFx0XHRcdFx0eyNlYWNoIHNlY3Rpb24uY2hhcHRlcnMgYXMgY2hhcHRlciwgaX1cclxuXHRcdFx0XHRcdFx0PG9wdGlvbiB2YWx1ZT17Y2hhcHRlci5zbHVnfT57U3RyaW5nLmZyb21DaGFyQ29kZShpICsgOTcpfS4ge2NoYXB0ZXIudGl0bGV9PC9vcHRpb24+XHJcblx0XHRcdFx0XHR7L2VhY2h9XHJcblx0XHRcdFx0PC9vcHRncm91cD5cclxuXHRcdFx0ey9lYWNofVxyXG5cdFx0PC9zZWxlY3Q+XHJcblx0PC9kaXY+XHJcblxyXG5cdDxhIHJlbD1cInByZWZldGNoXCIgY2xhc3M9XCJuby11bmRlcmxpbmVcIiBocmVmPVwidHV0b3JpYWwveyhzZWxlY3RlZC5uZXh0IHx8IHNlbGVjdGVkKS5zbHVnfVwiIGNsYXNzOmRpc2FibGVkPXshc2VsZWN0ZWQubmV4dH0+XHJcblx0XHQ8SWNvbiBuYW1lPVwiYXJyb3ctcmlnaHRcIiAvPlxyXG5cdDwvYT5cclxuPC9uYXY+XHJcbiIsIjxzY3JpcHQgY29udGV4dD1cIm1vZHVsZVwiPlxyXG5cdGV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmVsb2FkKHsgcGFyYW1zIH0pIHtcclxuXHRcdGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2goYHR1dG9yaWFsLyR7cGFyYW1zLnNsdWd9Lmpzb25gKTtcclxuXHJcblx0XHRpZiAoIXJlcy5vaykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5yZWRpcmVjdCgzMDEsIGB0dXRvcmlhbC9iYXNpY3NgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzbHVnOiBwYXJhbXMuc2x1ZyxcclxuXHRcdFx0Y2hhcHRlcjogYXdhaXQgcmVzLmpzb24oKVxyXG5cdFx0fTtcclxuXHR9XHJcbjwvc2NyaXB0PlxyXG5cclxuPHNjcmlwdD5cclxuXHRpbXBvcnQgUmVwbCBmcm9tICdAc3ZlbHRlanMvc3ZlbHRlLXJlcGwnO1xyXG5cdGltcG9ydCB7IGdldENvbnRleHQgfSBmcm9tICdzdmVsdGUnO1xyXG5cclxuXHRpbXBvcnQgU2NyZWVuVG9nZ2xlIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvU2NyZWVuVG9nZ2xlLnN2ZWx0ZSc7XHJcblx0aW1wb3J0IFRhYmxlT2ZDb250ZW50cyBmcm9tICcuL19UYWJsZU9mQ29udGVudHMuc3ZlbHRlJztcclxuXHJcblx0aW1wb3J0IHtcclxuXHRcdG1hcGJveF9zZXR1cCwgLy8gbmVlZGVkIGZvciBjb250ZXh0IEFQSSB0dXRvcmlhbFxyXG5cdFx0cm9sbHVwVXJsLFxyXG5cdFx0c3ZlbHRlVXJsXHJcblx0fSBmcm9tICcuLi8uLi8uLi9jb25maWcnO1xyXG5cclxuXHRleHBvcnQgbGV0IHNsdWc7XHJcblx0ZXhwb3J0IGxldCBjaGFwdGVyO1xyXG5cclxuXHRjb25zdCB7IHNlY3Rpb25zIH0gPSBnZXRDb250ZXh0KCd0dXRvcmlhbCcpO1xyXG5cclxuXHRsZXQgcmVwbDtcclxuXHRsZXQgcHJldjtcclxuXHRsZXQgc2Nyb2xsYWJsZTtcclxuXHRjb25zdCBsb29rdXAgPSBuZXcgTWFwKCk7XHJcblxyXG5cdGxldCB3aWR0aCA9IHByb2Nlc3MuYnJvd3NlciA/IHdpbmRvdy5pbm5lcldpZHRoIDogMTAwMDtcclxuXHRsZXQgb2Zmc2V0ID0gMDtcclxuXHJcblx0c2VjdGlvbnMuZm9yRWFjaChzZWN0aW9uID0+IHtcclxuXHRcdHNlY3Rpb24uY2hhcHRlcnMuZm9yRWFjaChjaGFwdGVyID0+IHtcclxuXHRcdFx0Y29uc3Qgb2JqID0ge1xyXG5cdFx0XHRcdHNsdWc6IGNoYXB0ZXIuc2x1ZyxcclxuXHRcdFx0XHRzZWN0aW9uLFxyXG5cdFx0XHRcdGNoYXB0ZXIsXHJcblx0XHRcdFx0cHJldlxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0bG9va3VwLnNldChjaGFwdGVyLnNsdWcsIG9iaik7XHJcblxyXG5cdFx0XHRpZiAocHJvY2Vzcy5icm93c2VyKSB7IC8vIHBlbmRpbmcgaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMjEzNVxyXG5cdFx0XHRcdGlmIChwcmV2KSBwcmV2Lm5leHQgPSBvYmo7XHJcblx0XHRcdFx0cHJldiA9IG9iajtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdC8vIFRPRE8gaXMgdGhlcmUgYSBub24taGFja3kgd2F5IHRvIHRyaWdnZXIgc2Nyb2xsIHdoZW4gY2hhcHRlciBjaGFuZ2VzP1xyXG5cdCQ6IGlmIChzY3JvbGxhYmxlKSBjaGFwdGVyLCBzY3JvbGxhYmxlLnNjcm9sbFRvKDAsIDApO1xyXG5cclxuXHQvLyBUT0RPOiB0aGlzIHdpbGwgbmVlZCB0byBiZSBjaGFuZ2VkIHRvIHRoZSBtYXN0ZXIgYnJhbmNoLCBhbmQgcHJvYmFibHkgc2hvdWxkIGJlIGR5bmFtaWMgaW5zdGVhZCBvZiBpbmNsdWRlZFxyXG5cdC8vICAgaGVyZSBzdGF0aWNhbGx5XHJcblx0Y29uc3QgdHV0b3JpYWxfcmVwb19saW5rID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvdHJlZS9tYXN0ZXIvc2l0ZS9jb250ZW50L3R1dG9yaWFsJztcclxuXHJcblx0JDogc2VsZWN0ZWQgPSBsb29rdXAuZ2V0KHNsdWcpO1xyXG5cdCQ6IGltcHJvdmVfbGluayA9IGAke3R1dG9yaWFsX3JlcG9fbGlua30vJHtzZWxlY3RlZC5jaGFwdGVyLnNlY3Rpb25fZGlyfS8ke3NlbGVjdGVkLmNoYXB0ZXIuY2hhcHRlcl9kaXJ9YDtcclxuXHJcblx0Y29uc3QgY2xvbmUgPSBmaWxlID0+ICh7XHJcblx0XHRuYW1lOiBmaWxlLm5hbWUsXHJcblx0XHR0eXBlOiBmaWxlLnR5cGUsXHJcblx0XHRzb3VyY2U6IGZpbGUuc291cmNlXHJcblx0fSk7XHJcblxyXG5cdCQ6IGlmIChyZXBsKSB7XHJcblx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcclxuXHRcdHJlcGwuc2V0KHtcclxuXHRcdFx0Y29tcG9uZW50czogY2hhcHRlci5hcHBfYS5tYXAoY2xvbmUpXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdCQ6IG1vYmlsZSA9IHdpZHRoIDwgNzY4O1xyXG5cclxuXHRmdW5jdGlvbiByZXNldCgpIHtcclxuXHRcdHJlcGwudXBkYXRlKHtcclxuXHRcdFx0Y29tcG9uZW50czogY2hhcHRlci5hcHBfYS5tYXAoY2xvbmUpXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xyXG5cdFx0cmVwbC51cGRhdGUoe1xyXG5cdFx0XHRjb21wb25lbnRzOiBjaGFwdGVyLmFwcF9iLm1hcChjbG9uZSlcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0bGV0IGNvbXBsZXRlZCA9IGZhbHNlO1xyXG5cclxuXHRmdW5jdGlvbiBoYW5kbGVfY2hhbmdlKGV2ZW50KSB7XHJcblx0XHRjb21wbGV0ZWQgPSBldmVudC5kZXRhaWwuY29tcG9uZW50cy5ldmVyeSgoZmlsZSwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCBleHBlY3RlZCA9IGNoYXB0ZXIuYXBwX2JbaV07XHJcblx0XHRcdHJldHVybiBleHBlY3RlZCAmJiAoXHJcblx0XHRcdFx0ZmlsZS5uYW1lID09PSBleHBlY3RlZC5uYW1lICYmXHJcblx0XHRcdFx0ZmlsZS50eXBlID09PSBleHBlY3RlZC50eXBlICYmXHJcblx0XHRcdFx0ZmlsZS5zb3VyY2UudHJpbSgpLnJlcGxhY2UoL1xccyskL2dtLCAnJykgPT09IGV4cGVjdGVkLnNvdXJjZS50cmltKCkucmVwbGFjZSgvXFxzKyQvZ20sICcnKVxyXG5cdFx0XHQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG48L3NjcmlwdD5cclxuXHJcbjxzdHlsZT5cclxuXHQudHV0b3JpYWwtb3V0ZXIge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0aGVpZ2h0OiBjYWxjKDEwMHZoIC0gdmFyKC0tbmF2LWgpKTtcclxuXHRcdG92ZXJmbG93OiBoaWRkZW47XHJcblx0XHRwYWRkaW5nOiAwIDAgNDJweCAwO1xyXG5cdFx0Ym94LXNpemluZzogYm9yZGVyLWJveDtcclxuXHR9XHJcblxyXG5cdC52aWV3cG9ydCB7XHJcblx0XHRkaXNwbGF5OiBncmlkO1xyXG5cdFx0d2lkdGg6IDMwMCU7XHJcblx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDMzLjMzMyUgNjYuNjY2JTtcclxuXHRcdHRyYW5zaXRpb246IHRyYW5zZm9ybSAuM3M7XHJcblx0XHRncmlkLWF1dG8tcm93czogMTAwJTtcclxuXHR9XHJcblxyXG5cdC5vZmZzZXQtMSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMy4zMzMlLCAwKTsgfVxyXG5cdC5vZmZzZXQtMiB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC02Ni42NjYlLCAwKTsgfVxyXG5cclxuXHRAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcclxuXHRcdC50dXRvcmlhbC1vdXRlciB7IHBhZGRpbmc6IDAgfVxyXG5cclxuXHRcdC52aWV3cG9ydCB7XHJcblx0XHRcdHdpZHRoOiAxMDAlO1xyXG5cdFx0XHRoZWlnaHQ6IDEwMCU7XHJcblx0XHRcdGRpc3BsYXk6IGdyaWQ7XHJcblx0XHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogbWlubWF4KDMzLjMzMyUsIHZhcigtLXNpZGViYXItbGFyZ2UtdykpIGF1dG87XHJcblx0XHRcdGdyaWQtYXV0by1yb3dzOiAxMDAlO1xyXG5cdFx0XHR0cmFuc2l0aW9uOiBub25lO1xyXG5cdFx0fVxyXG5cclxuXHRcdC5vZmZzZXQtMSwgLm9mZnNldC0yIHsgdHJhbnNmb3JtOiBub25lOyB9XHJcblx0fVxyXG5cclxuXHQudHV0b3JpYWwtdGV4dCB7XHJcblx0XHRkaXNwbGF5OiBmbGV4O1xyXG5cdFx0ZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuXHRcdGhlaWdodDogMTAwJTtcclxuXHRcdGJvcmRlci1yaWdodDogMXB4IHNvbGlkIHZhcigtLXNlY29uZCk7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1zZWNvbmQpO1xyXG5cdFx0Y29sb3I6IHZhcigtLXNpZGViYXItdGV4dCk7XHJcblx0fVxyXG5cclxuXHQuY2hhcHRlci1tYXJrdXAge1xyXG5cdFx0cGFkZGluZzogMy4ycmVtIDRyZW07XHJcblx0XHRvdmVyZmxvdzogYXV0bztcclxuXHRcdGZsZXg6IDE7XHJcblx0XHRoZWlnaHQ6IDA7XHJcblx0fVxyXG5cclxuXHQuY2hhcHRlci1tYXJrdXAgOmdsb2JhbChoMikge1xyXG5cdFx0bWFyZ2luOiA0cmVtIDAgMS42cmVtIDA7XHJcblx0XHRmb250LXNpemU6IHZhcigtLWgzKTtcclxuXHRcdGxpbmUtaGVpZ2h0OiAxO1xyXG5cdFx0Zm9udC13ZWlnaHQ6IDQwMDtcclxuXHRcdGNvbG9yOiB3aGl0ZTtcclxuXHR9XHJcblxyXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKGgyOmZpcnN0LWNoaWxkKSB7XHJcblx0XHRtYXJnaW4tdG9wOiAuNHJlbTtcclxuXHR9XHJcblxyXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKGEpIHtcclxuXHRcdGNvbG9yOiB2YXIoLS1zaWRlYmFyLXRleHQpO1xyXG5cdH1cclxuXHJcblx0LmNoYXB0ZXItbWFya3VwIDpnbG9iYWwoYTpob3Zlcikge1xyXG5cdFx0Y29sb3I6IHdoaXRlO1xyXG5cdH1cclxuXHJcblxyXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKHVsKSB7XHJcblx0XHRwYWRkaW5nOiAwIDAgMCAyZW07XHJcblx0fVxyXG5cclxuXHQuY2hhcHRlci1tYXJrdXAgOmdsb2JhbChibG9ja3F1b3RlKSB7XHJcblx0XHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLC4xNyk7XHJcblx0XHRjb2xvcjogdmFyKC0tc2lkZWJhci10ZXh0KTtcclxuXHR9XHJcblxyXG5cdC5jaGFwdGVyLW1hcmt1cDo6LXdlYmtpdC1zY3JvbGxiYXIge1xyXG5cdFx0YmFja2dyb3VuZC1jb2xvcjogdmFyKC0tc2Vjb25kKTtcclxuXHRcdHdpZHRoOiA4cHg7XHJcblx0fVxyXG5cclxuXHQuY2hhcHRlci1tYXJrdXA6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iIHtcclxuXHRcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsLjcpO1xyXG5cdFx0Ym9yZGVyLXJhZGl1czogMWVtO1xyXG5cdFx0b3V0bGluZTogMXB4IHNvbGlkIGdyZWVuO1xyXG5cdH1cclxuXHJcblx0LmNoYXB0ZXItbWFya3VwIDpnbG9iYWwocCkgPiA6Z2xvYmFsKGNvZGUpLFxyXG5cdC5jaGFwdGVyLW1hcmt1cCA6Z2xvYmFsKHVsKSA6Z2xvYmFsKGNvZGUpIHtcclxuXHRcdGNvbG9yOiB2YXIoLS1zaWRlYmFyLXRleHQpO1xyXG5cdFx0YmFja2dyb3VuZDogcmdiYSgwLDAsMCwuMTIpO1xyXG5cdFx0cGFkZGluZzogLjJlbSAuNGVtIC4zZW07XHJcblx0XHR3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0dG9wOiAtMC4xZW07XHJcblx0fVxyXG5cclxuXHQuY29udHJvbHMge1xyXG5cdFx0Ym9yZGVyLXRvcDogMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsLjE1KTtcclxuXHRcdHBhZGRpbmc6IDFlbSAwIDAgMDtcclxuXHRcdGRpc3BsYXk6IGZsZXg7XHJcblx0fVxyXG5cclxuXHQuc2hvdyB7XHJcblx0XHRiYWNrZ3JvdW5kOiB2YXIoLS1wcmltZSk7XHJcblx0XHRwYWRkaW5nOiAuM2VtIC43ZW07XHJcblx0XHRib3JkZXItcmFkaXVzOiB2YXIoLS1ib3JkZXItcik7XHJcblx0XHR0b3A6IC4xZW07XHJcblx0XHRwb3NpdGlvbjogcmVsYXRpdmU7XHJcblx0XHRmb250LXNpemU6IHZhcigtLWg1KTtcclxuXHRcdGZvbnQtd2VpZ2h0OiAzMDA7XHJcblx0XHRjb2xvcjogcmdiYSgyNTUsMjU1LDI1NSwwLjcpO1xyXG5cdH1cclxuXHJcblx0LnNob3c6aG92ZXIge1xyXG5cdFx0Y29sb3I6IHdoaXRlO1xyXG5cdH1cclxuXHJcblx0YS5uZXh0IHtcclxuXHRcdHBhZGRpbmctcmlnaHQ6IDEuMmVtO1xyXG5cdFx0YmFja2dyb3VuZDogbm8tcmVwZWF0IDEwMCUgNTAlIHVybCgvaWNvbnMvYXJyb3ctcmlnaHQuc3ZnKTtcclxuXHRcdGJhY2tncm91bmQtc2l6ZTogMWVtIDFlbTtcclxuXHRcdG1hcmdpbi1sZWZ0OiBhdXRvO1xyXG5cdH1cclxuXHJcblx0LmltcHJvdmUtY2hhcHRlciB7XHJcblx0XHRwYWRkaW5nOiAxZW0gMCAuNWVtIDA7XHJcblx0fVxyXG5cclxuXHQuaW1wcm92ZS1jaGFwdGVyIGEge1xyXG5cdFx0cGFkZGluZzogMCAuMWVtO1xyXG5cdFx0Zm9udC1zaXplOiAxNHB4O1xyXG5cdFx0dGV4dC1kZWNvcmF0aW9uOiBub25lO1xyXG5cdFx0b3BhY2l0eTogLjM7XHJcblx0XHRwYWRkaW5nLWxlZnQ6IDEuMmVtO1xyXG5cdFx0YmFja2dyb3VuZDogbm8tcmVwZWF0IDAgNTAlIHVybCgvaWNvbnMvZWRpdC5zdmcpO1xyXG5cdFx0YmFja2dyb3VuZC1zaXplOiAxZW0gMWVtO1xyXG5cdH1cclxuXHJcblx0LmltcHJvdmUtY2hhcHRlciBhOmhvdmVyIHtcclxuXHRcdG9wYWNpdHk6IDE7XHJcblx0fVxyXG48L3N0eWxlPlxyXG5cclxuPHN2ZWx0ZTpoZWFkPlxyXG5cdDx0aXRsZT57c2VsZWN0ZWQuc2VjdGlvbi50aXRsZX0gLyB7c2VsZWN0ZWQuY2hhcHRlci50aXRsZX0g4oCiIFN2ZWx0ZSBUdXRvcmlhbDwvdGl0bGU+XHJcblxyXG5cdDxtZXRhIG5hbWU9XCJ0d2l0dGVyOnRpdGxlXCIgY29udGVudD1cIlN2ZWx0ZSB0dXRvcmlhbFwiPlxyXG5cdDxtZXRhIG5hbWU9XCJ0d2l0dGVyOmRlc2NyaXB0aW9uXCIgY29udGVudD1cIntzZWxlY3RlZC5zZWN0aW9uLnRpdGxlfSAvIHtzZWxlY3RlZC5jaGFwdGVyLnRpdGxlfVwiPlxyXG5cdDxtZXRhIG5hbWU9XCJEZXNjcmlwdGlvblwiIGNvbnRlbnQ9XCJ7c2VsZWN0ZWQuc2VjdGlvbi50aXRsZX0gLyB7c2VsZWN0ZWQuY2hhcHRlci50aXRsZX1cIj5cclxuPC9zdmVsdGU6aGVhZD5cclxuXHJcbjxzdmVsdGU6d2luZG93IGJpbmQ6aW5uZXJXaWR0aD17d2lkdGh9Lz5cclxuXHJcbjxkaXYgY2xhc3M9XCJ0dXRvcmlhbC1vdXRlclwiPlxyXG5cdDxkaXYgY2xhc3M9XCJ2aWV3cG9ydCBvZmZzZXQte29mZnNldH1cIj5cclxuXHRcdDxkaXYgY2xhc3M9XCJ0dXRvcmlhbC10ZXh0XCI+XHJcblx0XHRcdDxkaXYgY2xhc3M9XCJ0YWJsZS1vZi1jb250ZW50c1wiPlxyXG5cdFx0XHRcdDxUYWJsZU9mQ29udGVudHMge3NlY3Rpb25zfSB7c2x1Z30ge3NlbGVjdGVkfS8+XHJcblx0XHRcdDwvZGl2PlxyXG5cclxuXHRcdFx0PGRpdiBjbGFzcz1cImNoYXB0ZXItbWFya3VwXCIgYmluZDp0aGlzPXtzY3JvbGxhYmxlfT5cclxuXHRcdFx0XHR7QGh0bWwgY2hhcHRlci5odG1sfVxyXG5cclxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiY29udHJvbHNcIj5cclxuXHRcdFx0XHRcdHsjaWYgY2hhcHRlci5hcHBfYn1cclxuXHRcdFx0XHRcdFx0PCEtLSBUT0RPIGRpc2FibGUgdGhpcyBidXR0b24gd2hlbiB0aGUgY29udGVudHMgb2YgdGhlIFJFUExcclxuXHRcdFx0XHRcdFx0XHRtYXRjaGVzIHRoZSBleHBlY3RlZCBlbmQgcmVzdWx0IC0tPlxyXG5cdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzPVwic2hvd1wiIG9uOmNsaWNrPVwieygpID0+IGNvbXBsZXRlZCA/IHJlc2V0KCkgOiBjb21wbGV0ZSgpfVwiPlxyXG5cdFx0XHRcdFx0XHRcdHtjb21wbGV0ZWQgPyAnUmVzZXQnIDogJ1Nob3cgbWUnfVxyXG5cdFx0XHRcdFx0XHQ8L2J1dHRvbj5cclxuXHRcdFx0XHRcdHsvaWZ9XHJcblxyXG5cdFx0XHRcdFx0eyNpZiBzZWxlY3RlZC5uZXh0fVxyXG5cdFx0XHRcdFx0XHQ8YSBjbGFzcz1cIm5leHRcIiBocmVmPVwidHV0b3JpYWwve3NlbGVjdGVkLm5leHQuc2x1Z31cIj5OZXh0PC9hPlxyXG5cdFx0XHRcdFx0ey9pZn1cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cImltcHJvdmUtY2hhcHRlclwiPlxyXG5cdFx0XHRcdFx0PGEgY2xhc3M9XCJuby11bmRlcmxpbmVcIiBocmVmPXtpbXByb3ZlX2xpbmt9PkVkaXQgdGhpcyBjaGFwdGVyPC9hPlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8L2Rpdj5cclxuXHRcdDwvZGl2PlxyXG5cclxuXHRcdDxkaXYgY2xhc3M9XCJ0dXRvcmlhbC1yZXBsXCI+XHJcblx0XHRcdDxSZXBsXHJcblx0XHRcdFx0YmluZDp0aGlzPXtyZXBsfVxyXG5cdFx0XHRcdHdvcmtlcnNVcmw9XCJ3b3JrZXJzXCJcclxuXHRcdFx0XHR7c3ZlbHRlVXJsfVxyXG5cdFx0XHRcdHtyb2xsdXBVcmx9XHJcblx0XHRcdFx0b3JpZW50YXRpb249e21vYmlsZSA/ICdjb2x1bW5zJyA6ICdyb3dzJ31cclxuXHRcdFx0XHRmaXhlZD17bW9iaWxlfVxyXG5cdFx0XHRcdG9uOmNoYW5nZT17aGFuZGxlX2NoYW5nZX1cclxuXHRcdFx0XHRpbmplY3RlZEpTPXttYXBib3hfc2V0dXB9XHJcblx0XHRcdFx0cmVsYXhlZFxyXG5cdFx0XHQvPlxyXG5cdFx0PC9kaXY+XHJcblx0PC9kaXY+XHJcblxyXG5cdHsjaWYgbW9iaWxlfVxyXG5cdFx0PFNjcmVlblRvZ2dsZSBiaW5kOm9mZnNldCBsYWJlbHM9e1sndHV0b3JpYWwnLCAnaW5wdXQnLCAnb3V0cHV0J119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
